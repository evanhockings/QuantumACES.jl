var documenterSearchIndex = {"docs":
[{"location":"internal/utils/","page":"utils.jl","title":"utils.jl","text":"CollapsedDocStrings = true","category":"page"},{"location":"internal/utils/#utils.jl","page":"utils.jl","title":"utils.jl","text":"","category":"section"},{"location":"internal/utils/#Public-functions","page":"utils.jl","title":"Public functions","text":"","category":"section"},{"location":"internal/utils/","page":"utils.jl","title":"utils.jl","text":"Modules = [QuantumACES]\nPages = [\"src/utils.jl\"]\nPrivate = false","category":"page"},{"location":"internal/utils/#QuantumACES.calc_pauli-Tuple{Pauli, Vector{Layer}}","page":"utils.jl","title":"QuantumACES.calc_pauli","text":"calc_pauli(initial::Pauli, circuit::Vector{Layer})\n\nReturns the Pauli to which the initial Pauli initial is mapped after the circuit circuit is applied.\n\n\n\n\n\n","category":"method"},{"location":"internal/utils/#QuantumACES.display_circuit-Tuple{String}","page":"utils.jl","title":"QuantumACES.display_circuit","text":"display_circuit(stim_circuit_string::String; without_noise::Bool = true)\ndisplay_circuit(qiskit_circuit::Py)\n\nDisplays the supplied Stim or Qiskit circuit stim_circuit_string or qiskit_circuit, and if without_noise is true, displays the Stim circuit without Pauli noise channels. Be careful: Python arrays stored in PythonCall index from 0, so it is easy to index into the wrong Qiskit circuit.\n\n\n\n\n\n","category":"method"},{"location":"internal/utils/#QuantumACES.eig_to_pair_idx-Tuple{Design, Vector{Int64}}","page":"utils.jl","title":"QuantumACES.eig_to_pair_idx","text":"eig_to_pair_idx(d::Design, eigenvalue_idx::Integer)\neig_to_pair_idx(d::Design, eigenvalue_indices::Vector{Int})\n\nReturns the (tuple_idx, mapping_idx) pair of indices for each eigenvalue index eigenvalue_idx corresponding to the design d.\n\n\n\n\n\n","category":"method"},{"location":"internal/utils/#QuantumACES.get_mapping_string-Union{Tuple{T}, Tuple{Mapping, T}} where T<:AbstractCircuit","page":"utils.jl","title":"QuantumACES.get_mapping_string","text":"get_mapping_string(m::Mapping, c::AbstractCircuit; two_qubit_only::Bool = false)\n\nReturns the string representation of the mapping m for the circuit c, including eigenvalues.\n\n\n\n\n\n","category":"method"},{"location":"internal/utils/#QuantumACES.get_pauli_string-Tuple{Pauli}","page":"utils.jl","title":"QuantumACES.get_pauli_string","text":"get_pauli_string(p::Pauli)\n\nReturns the string representation of the Pauli p.\n\n\n\n\n\n","category":"method"},{"location":"internal/utils/#QuantumACES.get_paulis-Tuple{Integer}","page":"utils.jl","title":"QuantumACES.get_paulis","text":"get_paulis(n::Integer)\n\nReturns a list of all n-qubit Paulis ordered lexicographically according to their bit string representation described in Pauli. For single-qubit gates, the Pauli error probabilities are ordered as I, X, Z, Y. For two-qubit gates, the Pauli error probabilities are ordered as II, XI, IX, XX, ZI, YI, ZX, YX, IZ, XZ, IY, XY, ZZ, YZ, ZY, YY.\n\n\n\n\n\n","category":"method"},{"location":"internal/utils/#QuantumACES.get_random_pauli-Tuple{Integer}","page":"utils.jl","title":"QuantumACES.get_random_pauli","text":"get_random_pauli(n::Integer)\n\nReturns the string representation of a random n-qubit Pauli.\n\n\n\n\n\n","category":"method"},{"location":"internal/utils/#QuantumACES.get_stim_circuit-Tuple{AbstractCircuit, Vector{Int64}, Dict{Gate, Vector{Float64}}}","page":"utils.jl","title":"QuantumACES.get_stim_circuit","text":"get_stim_circuit(c::AbstractCircuit)\nget_stim_circuit(c::AbstractCircuit, circuit_tuple::Vector{Int})\nget_stim_circuit(c::AbstractCircuit, gate_probabilities::Dict{Gate, Vector{Float64}})\nget_stim_circuit(c::AbstractCircuit, circuit_tuple::Vector{Int}, gate_probabilities::Dict{Gate, Vector{Float64}})\nget_stim_circuit(d::Design)\nget_stim_circuit(d::Design, gate_probabilities::Dict{Gate, Vector{Float64}})\nget_stim_circuit(d_rand::RandDesign)\nget_stim_circuit(d_rand::RandDesign, gate_probabilities::Dict{Gate, Vector{Float64}})\n\nReturns the Stim circuit for the circuit c, stored in the design d, or randomised design d_rand, optionally applying the tuple circuit_tuple with the gate probabilities gate_probabilities.\n\n\n\n\n\n","category":"method"},{"location":"internal/utils/#QuantumACES.get_support-Tuple{Pauli}","page":"utils.jl","title":"QuantumACES.get_support","text":"get_support(p::Pauli)\n\nReturns the support of the Pauli p.\n\n\n\n\n\n","category":"method"},{"location":"internal/utils/#QuantumACES.pair_to_eig_idx-Tuple{Design, Vector{Tuple{Int64, Int64}}}","page":"utils.jl","title":"QuantumACES.pair_to_eig_idx","text":"pair_to_eig_idx(d::Design, pair_idx::Tuple{Int, Int})\npair_to_eig_idx(d::Design, pair_indices::Vector{Tuple{Int, Int}})\n\nReturns the eigenvalue index eigenvalue_idx corresponding to the pair index (tuple_idx, mapping_idx) corresponding to the design d.\n\n\n\n\n\n","category":"method"},{"location":"internal/utils/#QuantumACES.parse_bitstring-Tuple{Vector{UInt8}, Integer}","page":"utils.jl","title":"QuantumACES.parse_bitstring","text":"parse_bitstring(uint8_vector::Vector{UInt8}, bit_num::Integer)\n\nReturns the UInt8 vector uint8_vector parsed into a bitstring of length bit_num.\n\n\n\n\n\n","category":"method"},{"location":"internal/utils/#QuantumACES.parse_qiskit_dict-Tuple{Dict{String, Int64}, Integer, Integer}","page":"utils.jl","title":"QuantumACES.parse_qiskit_dict","text":"parse_qiskit_dict(counts::Dict{String, Int}, shots::Integer, qiskit_qubit_num::Integer; qiskit_qubit_map::Union{Vector{Int}, Nothing} = nothing)\n\nReturns a parsed Stim-compatible matrix of UInt8 circuit outcomes determined from the dictionary counts output by Qiskit with shots shots, where the circuit acts on qiskit_qubit_num qubits, and if qiskit_qubit_map is not nothing, checks that the measurement outcomes for the qubits not included in the map are 0.\n\n\n\n\n\n","category":"method"},{"location":"internal/utils/#QuantumACES.parse_uint8_vector-Tuple{String}","page":"utils.jl","title":"QuantumACES.parse_uint8_vector","text":"parse_uint8_vector(bitstring::String)\n\nReturns the bitstring bitstring parsed into a UInt8 vector.\n\n\n\n\n\n","category":"method"},{"location":"internal/utils/#QuantumACES.pauli_to_string-Tuple{Pauli}","page":"utils.jl","title":"QuantumACES.pauli_to_string","text":"pauli_to_string(p::Pauli)\n\nReturns the string representation of the Pauli p.\n\n\n\n\n\n","category":"method"},{"location":"internal/utils/#QuantumACES.pretty_print-Tuple{IO, ACESData, Merit}","page":"utils.jl","title":"QuantumACES.pretty_print","text":"pretty_print(io::IO, aces_data::ACESData, merit::Merit; projected::Bool = false)\npretty_print(aces_data::ACESData, merit::Merit; projected::Bool = false)\n\nPrints the z-scores of the normalised RMS errors of the gate eigenvalue estimator vector for the GLS, WLS, and OLS estimators in aces_data using the predictions in the merit data merit, or for the projected gate eigenvalue estimator vector if projected is true.\n\n\n\n\n\n","category":"method"},{"location":"internal/utils/#QuantumACES.pretty_print-Tuple{IO, Design}","page":"utils.jl","title":"QuantumACES.pretty_print","text":"pretty_print(io::IO, d::Design)\npretty_print(d::Design)\n\nPrints the tuple set and shot weight data of the design d in a readable format.\n\n\n\n\n\n","category":"method"},{"location":"internal/utils/#QuantumACES.pretty_print-Union{Tuple{T}, Tuple{T, Vector{Int64}}} where T<:AbstractCircuit","page":"utils.jl","title":"QuantumACES.pretty_print","text":"pretty_print(c::AbstractCircuit)\npretty_print(c::AbstractCircuit, circuit_tuple::Vector{Int})\n\nPrints the circuit c using Stim in a readable format, optionally rearranged by the tuple circuit_tuple.\n\n\n\n\n\n","category":"method"},{"location":"internal/utils/#QuantumACES.string_to_pauli-Tuple{String}","page":"utils.jl","title":"QuantumACES.string_to_pauli","text":"string_to_pauli(pauli_string::String)\n\nReturns the Pauli corresponding to the string representation pauli_string.\n\n\n\n\n\n","category":"method"},{"location":"internal/utils/#Private-functions","page":"utils.jl","title":"Private functions","text":"","category":"section"},{"location":"internal/utils/","page":"utils.jl","title":"utils.jl","text":"Modules = [QuantumACES]\nPages = [\"src/utils.jl\"]\nPublic = false","category":"page"},{"location":"internal/utils/#QuantumACES.batch_shots-Tuple{Integer, Integer, Integer}","page":"utils.jl","title":"QuantumACES.batch_shots","text":"batch_shots(shots::Integer, measurements::Integer, max_samples::Integer)\n\nReturns the shots divided into batches for sampling from Stim.\n\n\n\n\n\n","category":"method"},{"location":"internal/utils/#QuantumACES.calc_gate_orbits-Tuple{Gate}","page":"utils.jl","title":"QuantumACES.calc_gate_orbits","text":"calc_gate_orbits(gate::Gate; ignore_sign::Bool = true)\n\nReturns the Pauli orbits generated by the gate gate, for all Paulis supported on that gate, ignoring the sign of the Pauli operators if ignore_sign is true.\n\n\n\n\n\n","category":"method"},{"location":"internal/utils/#QuantumACES.calc_orbit-Tuple{Pauli, Gate}","page":"utils.jl","title":"QuantumACES.calc_orbit","text":"calc_orbit(initial::Pauli, gate::Gate; ignore_sign::Bool = true)\n\nReturns the Pauli orbit generated by the gate gate acting on the Pauli initial, ignoring the sign of the Pauli operators if ignore_sign is true.\n\n\n\n\n\n","category":"method"},{"location":"internal/utils/#QuantumACES.get_orbit_indices-Tuple{Vector{Vector{Pauli}}}","page":"utils.jl","title":"QuantumACES.get_orbit_indices","text":"get_orbit_indices(gate_orbits::Vector{Vector{Pauli}})\n\nReturns the Pauli orbit indices for each of the Pauli orbits in gate_orbits.\n\n\n\n\n\n","category":"method"},{"location":"internal/utils/#QuantumACES.project_simplex-Tuple{Vector{Float64}}","page":"utils.jl","title":"QuantumACES.project_simplex","text":"project_simplex(probabilities::Vector{Float64})\n\nReturns a copy of the probability distribution probabilities projected into the probability simplex according to the Euclidean norm.\n\n\n\n\n\n","category":"method"},{"location":"internal/utils/#QuantumACES.scs_project_nonnegative-Tuple{Vector{Float64}, SparseArrays.SparseMatrixCSC{Float64, Int64}}","page":"utils.jl","title":"QuantumACES.scs_project_nonnegative","text":"scs_project_nonnegative(vector::Vector{Float64}, precision_matrix::SparseMatrixCSC{Float64, Int}; precision::Real = 1e-8, diagnostics::Bool = false)\n\nReturns a copy of the vector vector projected into the nonnegative orthant according to the quadratic form defined by the precision matrix precision_matrix using the solver SCS, with the specified precision precision, and printing diagonstics if diagnostics is true.\n\n\n\n\n\n","category":"method"},{"location":"internal/tableau/","page":"tableau.jl","title":"tableau.jl","text":"CollapsedDocStrings = true","category":"page"},{"location":"internal/tableau/#tableau.jl","page":"tableau.jl","title":"tableau.jl","text":"","category":"section"},{"location":"internal/tableau/#Public-functions","page":"tableau.jl","title":"Public functions","text":"","category":"section"},{"location":"internal/tableau/","page":"tableau.jl","title":"tableau.jl","text":"Modules = [QuantumACES]\nPages = [\"src/tableau.jl\"]\nPrivate = false","category":"page"},{"location":"internal/tableau/#QuantumACES.Gate","page":"tableau.jl","title":"QuantumACES.Gate","text":"Gate\n\nA gate in a stabiliser circuit.\n\nFields\n\ntype::String: String describing the gate type.\nindex::Int32: The index labelling the unique layer occurrences of the gate in a circuit.\ntargets::Vector{Int16}: The qubit target or targets of the gate.\n\nSupported gates\n\nH: Hadamard gate.\nS: Phase gate.\nS_DAG: Conjugate phase gate.\nCX or CNOT: Controlled-X gate; the first qubit is the control and the second qubit is the target.\nCZ: Controlled-Z gate.\nI: Identity gate.\nZ: Pauli Z gate.\nX: Pauli X gate.\nY: Pauli Y gate.\nII: Two-qubit identity gate.\nAB: Two-qubit Pauli gate, where A and B are Paulis Z, X, or Y.\nSQRT_AB: Two-qubit Pauli rotation, where A and B are Paulis Z, X, or Y.\nSQRT_AB_DAG : Two-qubit Pauli rotation, where A and B are Paulis Z, X, or Y.\nPZ: Prepare the Pauli Z eigenstate.\nPX: Prepare the Pauli X eigenstate.\nPY: Prepare the Pauli Y eigenstate.\nM or MZ: Measure in the computational Pauli Z basis.\nMX: Measure in the Pauli X basis.\nMY: Measure in the Pauli Y basis.\nR: Reset in the computational Z basis.\n\n\n\n\n\n","category":"type"},{"location":"internal/tableau/#QuantumACES.Layer","page":"tableau.jl","title":"QuantumACES.Layer","text":"Layer\n\nA layer of gates in a stabiliser circuit. Gates in a layer are simultaneously implemented by the device, and act on disjoint sets of qubits such that they trivially commute with each other.\n\nFields\n\nlayer::Vector{Gate}: The gates in the layer.\nqubit_num::Int16: The number of qubits in the circuit.\n\n\n\n\n\n","category":"type"},{"location":"internal/tableau/#QuantumACES.Tableau","page":"tableau.jl","title":"QuantumACES.Tableau","text":"Tableau\n\nA tableau representation of a stabiliser state.\n\nStabiliser circuit simulations follow Improved simulation of stabilizer circuits by S. Aaronson and D. Gottesman (2004).\n\nFields\n\ntableau::Matrix{Bool}: The tableau representation of the stabiliser state.\nqubit_num::Int16: The number of qubits in the stabiliser state.\n\n\n\n\n\n","category":"type"},{"location":"internal/tableau/#QuantumACES.apply!-Tuple{Tableau, Layer}","page":"tableau.jl","title":"QuantumACES.apply!","text":"apply!(t::Tableau, l::Layer; return_measurements::Bool = false)\n\nPerform on the tableau t all gates in the layer l, and return the list of measurement outcomes if return_measurements is true.\n\n\n\n\n\n","category":"method"},{"location":"internal/tableau/#QuantumACES.get_one_qubit_gates-Tuple{}","page":"tableau.jl","title":"QuantumACES.get_one_qubit_gates","text":"get_one_qubit_gates()\n\nReturns a list of the supported single-qubit gate types.\n\n\n\n\n\n","category":"method"},{"location":"internal/tableau/#QuantumACES.get_two_qubit_gates-Tuple{}","page":"tableau.jl","title":"QuantumACES.get_two_qubit_gates","text":"get_two_qubit_gates(; stim_supported::Bool = false)\n\nReturns a list of the supported two-qubit gate types, restricting to those also supported by Stim if stim_supported is true.\n\n\n\n\n\n","category":"method"},{"location":"internal/tableau/#QuantumACES.is_additive-Tuple{Gate}","page":"tableau.jl","title":"QuantumACES.is_additive","text":"is_additive(g::Gate; strict::Bool = false)\n\nReturns true if the noise associated with the gate g can only be estimated to additive precision, and false otherwise. If strict is true, this is true only for state preparation and measurement noise, as is proper, otherwise it is also true for mid-circuit measurement and reset noise, and measurement idle noise.\n\n\n\n\n\n","category":"method"},{"location":"internal/tableau/#QuantumACES.is_meas_idle-Tuple{Gate}","page":"tableau.jl","title":"QuantumACES.is_meas_idle","text":"is_meas_idle(g::Gate)\n\nReturns true if the gate g is a measurement idle gate, and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"internal/tableau/#QuantumACES.is_mid_meas-Tuple{Gate}","page":"tableau.jl","title":"QuantumACES.is_mid_meas","text":"is_mid_meas(g::Gate)\n\nReturns true if the gate g is a mid-circuit measurement gate, and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"internal/tableau/#QuantumACES.is_mid_meas_reset-Tuple{Gate}","page":"tableau.jl","title":"QuantumACES.is_mid_meas_reset","text":"is_mid_meas_reset(g::Gate)\n\nReturns true if the gate g is a mid-circuit measurement or reset gate, and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"internal/tableau/#QuantumACES.is_mid_reset-Tuple{Gate}","page":"tableau.jl","title":"QuantumACES.is_mid_reset","text":"is_mid_reset(g::Gate)\n\nReturns true if the gate g is a mid-circuit reset gate, and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"internal/tableau/#QuantumACES.is_one_qubit-Tuple{Gate}","page":"tableau.jl","title":"QuantumACES.is_one_qubit","text":"is_one_qubit(g::Gate)\n\nReturns true if the gate g is a supported single-qubit gate, and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"internal/tableau/#QuantumACES.is_pauli-Tuple{Gate}","page":"tableau.jl","title":"QuantumACES.is_pauli","text":"is_pauli(g::Gate)\n\nReturns true if the gate g is a Pauli gate, and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"internal/tableau/#QuantumACES.is_spam-Tuple{Gate}","page":"tableau.jl","title":"QuantumACES.is_spam","text":"is_spam(g::Gate)\n\nReturns true if the gate g is a state preparation or measurement gate, and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"internal/tableau/#QuantumACES.is_state_meas-Tuple{Gate}","page":"tableau.jl","title":"QuantumACES.is_state_meas","text":"is_state_meas(g::Gate)\n\nReturns true if the gate g is a state measurement gate, and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"internal/tableau/#QuantumACES.is_state_prep-Tuple{Gate}","page":"tableau.jl","title":"QuantumACES.is_state_prep","text":"is_state_prep(g::Gate)\n\nReturns true if the gate g is a state preparation gate, and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"internal/tableau/#QuantumACES.is_two_qubit-Tuple{Gate}","page":"tableau.jl","title":"QuantumACES.is_two_qubit","text":"is_two_qubit(g::Gate; stim_supported::Bool = false)\n\nReturns true if the gate g is a supported two-qubit gate, and false otherwise. If stim_supported is true, restrict to those gates also supported by Stim.\n\n\n\n\n\n","category":"method"},{"location":"internal/tableau/#QuantumACES.make_layer-Tuple{String, Vector{Int64}, Integer}","page":"tableau.jl","title":"QuantumACES.make_layer","text":"make_layer(gate_type::String, range::Vector{Int}, n::Integer; index::Integer = 0)\n\nReturns a layer of single-qubit gate_type gates acting on the qubits in range, where the layer acts on n qubits, optionally specifying the gate index index.\n\n\n\n\n\n","category":"method"},{"location":"internal/tableau/#QuantumACES.make_layer-Tuple{String, Vector{Vector{Int64}}, Integer}","page":"tableau.jl","title":"QuantumACES.make_layer","text":"make_layer(gate_type::String, range_set::Vector{Vector{Int}}, n::Integer; index::Integer = 0)\n\nReturns a layer of gate_type gates, each acting on the qubits in range_set, where the layer acts on n qubits, optionally specifying the gate index index.\n\n\n\n\n\n","category":"method"},{"location":"internal/tableau/#QuantumACES.make_layer-Tuple{Vector{String}, Vector{Vector{Int64}}, Integer}","page":"tableau.jl","title":"QuantumACES.make_layer","text":"make_layer(gate_types::Vector{String}, ranges::Vector{Vector{Int}}, n::Integer; index::Integer = 0)\n\nReturns a layer of single-qubit gates, with gate types specified by gate_types and the qubits upon which they act specified by ranges, where the layer acts on n qubits, optionally specifying the gate index index.\n\n\n\n\n\n","category":"method"},{"location":"internal/tableau/#QuantumACES.pad_layer-Tuple{Layer}","page":"tableau.jl","title":"QuantumACES.pad_layer","text":"pad_layer(l::Layer)\n\nReturns a copy of the layer l padded by single-qubit identity gates that act on each of the qubits not already acted upon by some gate in the layer.\n\n\n\n\n\n","category":"method"},{"location":"internal/tableau/#Private-functions","page":"tableau.jl","title":"Private functions","text":"","category":"section"},{"location":"internal/tableau/","page":"tableau.jl","title":"tableau.jl","text":"Modules = [QuantumACES]\nPages = [\"src/tableau.jl\"]\nPublic = false","category":"page"},{"location":"internal/tableau/#QuantumACES.cx!-Tuple{Tableau, Integer, Integer}","page":"tableau.jl","title":"QuantumACES.cx!","text":"cx!(t::Tableau, control::Integer, target::Integer)\n\nPerform a controlled-X gate on the tableau t with control qubit control and target qubit target.\n\n\n\n\n\n","category":"method"},{"location":"internal/tableau/#QuantumACES.cz!-Tuple{Tableau, Integer, Integer}","page":"tableau.jl","title":"QuantumACES.cz!","text":"cz!(t::Tableau, control::Integer, target::Integer)\n\nPerform a controlled-Z gate on the tableau t with control qubit control and target qubit target. The gate is symmetric, so the control and target qubits can be swapped.\n\n\n\n\n\n","category":"method"},{"location":"internal/tableau/#QuantumACES.hadamard!-Tuple{Tableau, Integer}","page":"tableau.jl","title":"QuantumACES.hadamard!","text":"hadamard!(t::Tableau,target::Integer)\n\nPerform a Hadamard gate on the tableau t with target qubit target.\n\n\n\n\n\n","category":"method"},{"location":"internal/tableau/#QuantumACES.measure!-Tuple{Tableau, Integer}","page":"tableau.jl","title":"QuantumACES.measure!","text":"measure!(t::Tableau, target::Integer)\n\nMeasure the tableau t at the target qubit target, and return the measurement outcome.\n\n\n\n\n\n","category":"method"},{"location":"internal/tableau/#QuantumACES.phase!-Tuple{Tableau, Integer}","page":"tableau.jl","title":"QuantumACES.phase!","text":"phase!(t::Tableau,target::Integer)\n\nPerform a phase gate on the tableau t with target qubit target.\n\n\n\n\n\n","category":"method"},{"location":"internal/tableau/#QuantumACES.reset!-Tuple{Tableau, Integer}","page":"tableau.jl","title":"QuantumACES.reset!","text":"reset!(t::Tableau, target::Integer)\n\nReset the tableau t at the target qubit target by measuring in the computational basis and flipping the phase if the measurement outcome is -1.\n\n\n\n\n\n","category":"method"},{"location":"internal/tableau/#QuantumACES.row_phase-NTuple{4, Bool}","page":"tableau.jl","title":"QuantumACES.row_phase","text":"row_phase(x_1::Bool, z_1::Bool, x_2::Bool, z_2::Bool)\n\nCalculate a phase for row_sum!.\n\n\n\n\n\n","category":"method"},{"location":"internal/tableau/#QuantumACES.row_sum!-Tuple{Tableau, Integer, Integer}","page":"tableau.jl","title":"QuantumACES.row_sum!","text":"row_sum!(t::Tableau, target::Integer, control::Integer)\n\nIn the tableau t, add the control row control to the target row target, while tracking the phase bit of the target row.\n\n\n\n\n\n","category":"method"},{"location":"internal/tableau/#QuantumACES.sqrt_zz!-Tuple{Tableau, Integer, Integer}","page":"tableau.jl","title":"QuantumACES.sqrt_zz!","text":"sqrt_zz!(t::Tableau, control::Integer, target::Integer)\n\nPerform a π/2 ZZ Pauli rotation gate on the tableau t with control qubit control and target qubit target. The gate is symmetric, so the control and target qubits can be swapped.\n\n\n\n\n\n","category":"method"},{"location":"internal/tableau/#QuantumACES.sqrt_zz_dag!-Tuple{Tableau, Integer, Integer}","page":"tableau.jl","title":"QuantumACES.sqrt_zz_dag!","text":"sqrt_zz_dag!(t::Tableau, control::Integer, target::Integer)\n\nPerform a -π/2 ZZ Pauli rotation gate on the tableau t with control qubit control and target qubit target. The gate is symmetric, so the control and target qubits can be swapped.\n\n\n\n\n\n","category":"method"},{"location":"internal/tableau/#QuantumACES.x!-Tuple{Tableau, Integer}","page":"tableau.jl","title":"QuantumACES.x!","text":"x!(t::Tableau,target::Integer)\n\nPerform a Pauli X gate on the tableau t with target qubit target, noting that X = H S^2 H.\n\n\n\n\n\n","category":"method"},{"location":"internal/tableau/#QuantumACES.y!-Tuple{Tableau, Integer}","page":"tableau.jl","title":"QuantumACES.y!","text":"y!(t::Tableau,target::Integer)\n\nPerform a Pauli Z gate on the tableau t with target qubit target, noting that Y = S H S^2 H S^3.\n\n\n\n\n\n","category":"method"},{"location":"internal/tableau/#QuantumACES.z!-Tuple{Tableau, Integer}","page":"tableau.jl","title":"QuantumACES.z!","text":"z!(t::Tableau,target::Integer)\n\nPerform a Pauli Z gate on the tableau t with target qubit target, noting that Z = S^2.\n\n\n\n\n\n","category":"method"},{"location":"internal/QuantumACES/","page":"QuantumACES.jl","title":"QuantumACES.jl","text":"CollapsedDocStrings = true","category":"page"},{"location":"internal/QuantumACES/#QuantumACES.jl","page":"QuantumACES.jl","title":"QuantumACES.jl","text":"","category":"section"},{"location":"internal/QuantumACES/#Public-functions","page":"QuantumACES.jl","title":"Public functions","text":"","category":"section"},{"location":"internal/QuantumACES/","page":"QuantumACES.jl","title":"QuantumACES.jl","text":"Modules = [QuantumACES]\nPages = [\"src/QuantumACES.jl\"]\nPrivate = false","category":"page"},{"location":"internal/QuantumACES/#QuantumACES.QuantumACES","page":"QuantumACES.jl","title":"QuantumACES.QuantumACES","text":"QuantumACES is a package for designing and simulating scalable and performant Pauli noise characterisation experiments for stabiliser circuits with averaged circuit eigenvalue sampling (ACES). It focuses on the context of quantum error correction and fault-tolerant circuits and, in particular, on the syndrome extraction circuits of topological quantum error correcting codes. It interfaces with Stim for stabiliser circuit simulation, PyMatching and BeliefMatching for decoding, and Qiskit for implementation on quantum devices.\n\nThe methods used in this package are based on arXiv:2404.06545 and arXiv:2502.21044, and they build on the original ACES protocol introduced in arXiv:2108.05803.\n\nThe code for arXiv:2404.06545 can be found in the scalable_aces folder on the scalable_aces branch.\n\nThe code for arXiv:2502.21044 can be found in the aces_decoding folder on the aces_decoding branch.\n\n\n\n\n\n","category":"module"},{"location":"internal/QuantumACES/#QuantumACES.AbstractCircuit","page":"QuantumACES.jl","title":"QuantumACES.AbstractCircuit","text":"AbstractCircuit\n\nCircuits should be stored in a subtype T <: AbstractCircuit, and generated by a method of get_circuit.\n\nNecessary fields\n\ncircuit_param::AbstractCircuitParameters: Circuit parameters.\ncircuit::Vector{Layer}: Circuit.\ncircuit_tuple::Vector{Int}: Tuple which arranges the order of the circuit layers; this is initialised as trivial.\nqubit_num::Int: Number of qubits in the circuit.\nunique_layer_indices::Vector{Int}: Unique non-measurement gate layer indices of the circuit.\nlayer_types::Vector{Symbol}: Types of the layers in the circuit, used for layer times and dynamical decoupling.\nlayer_times::Vector{Float64}: Times taken to implement each layer in the circuit, as well as measurement and reset.\ngates::Vector{Gate}: Gates in the circuit arranged by the tuple.\ntotal_gates::Vector{Gate}: Total gates in the circuit, including preparations if noisy_prep and measurements if noisy_meas.\ngate_index::Dict{Gate, Int}: Index of the gate eigenvalues for each gate in the original circuit.\nN::Int: Number of gate eigenvalues.\nmarginal_gate_index::Dict{Gate, Int}: Index of the marginal gate eigenvalues for each gate in the original circuit, where the marginals are determined by the Pauli orbits specified in get_orbit_indices_dict.\nN_marginal::Int: Number of marginal gate eigenvalues.\nN_relative::Int: Number of relative gate eigenvalues.\nnoise_param::AbstractNoiseParameters: Noise parameters.\ngate_probabilities::Dict{Gate, Vector{Float64}}: Pauli error probabilities for each gate, stored as a dictionary.\ngate_eigenvalues::Vector{Float64}: Eigenvalues for each gate, stored as a vector whose order is determined by gate_index.\nmarginal_gate_probabilities::Dict{Gate, Vector{Float64}}: Marginal Pauli error probabilities for each gate, stored as a dictionary.\nmarginal_gate_eigenvalues::Vector{Float64}: Marginal eigenvalues for each gate, stored as a vector whose order is determined by marginal_gate_index.\nrelative_gate_eigenvalues::Vector{Float64}: Marginal eigenvalues for each gate whose marginal eigenvalues can be estimated to relative precision, namely those which are not preparation or measurement, stored as a vector whose order is determined by marginal_gate_index.\nnoisy_prep::Bool: Whether to treat preparations as noisy and characterise the associated noise, which should default to false; a full-rank design cannot be produced if both noisy_prep and noisy_meas are true.\nnoisy_meas::Bool: Whether to treat measurements as noisy and characterise the associated noise, which should default to true; a full-rank design cannot be produced if both noisy_prep and noisy_meas are true.\nextra_fields::Dict{Symbol, Any}: Extra data for the circuit, including code parameters for syndrome extraction circuits stored as a :code_param field which is a CodeParameters object.\n\n\n\n\n\n","category":"type"},{"location":"internal/QuantumACES/#QuantumACES.AbstractCircuitParameters","page":"QuantumACES.jl","title":"QuantumACES.AbstractCircuitParameters","text":"AbstractCircuitParameters\n\nCircuit parameters should be stored in a subtype T <: AbstractCircuitParameters.\n\nThen add a method to get_circuit that generates a circuit according to these parameters. Such a circuit should either be a Circuit object, or a subtype T <: AbstractCircuit.\n\nNecessary fields\n\nparams::Dict{Symbol, Any}: Dictionary of the circuit parameters, which should in particular include a layer_time_dict field, which is a dictionary of the times taken to implement the different types of layers in the circuit, including the time for measurement and reset.\ncircuit_name::String: Name of the circuit, which should implicitly describe parameter settings.\n\n\n\n\n\n","category":"type"},{"location":"internal/QuantumACES/#QuantumACES.AbstractCodeParameters","page":"QuantumACES.jl","title":"QuantumACES.AbstractCodeParameters","text":"AbstractCodeParameters\n\nCode parameters for syndrome extraction circuits should be stored in subtypes T <: AbstractCodeParameters, usually a CodeParameters object.\n\n\n\n\n\n","category":"type"},{"location":"internal/QuantumACES/#QuantumACES.AbstractNoiseParameters","page":"QuantumACES.jl","title":"QuantumACES.AbstractNoiseParameters","text":"AbstractNoiseParameters\n\nNoise parameters should be stored in a subtype T <: AbstractNoiseParameters.\n\nNoise models should be generated by a method of init_gate_probabilities, which generates Pauli error probabilities for the supplied gates according to some supplied noise parameters.\n\nNecessary fields\n\nparams::Dict{Symbol, Any}: Dictionary of the noise parameters.\nnoise_name::String: Name of the noise model, which should implicitly describe parameter settings.\n\n\n\n\n\n","category":"type"},{"location":"internal/QuantumACES/#QuantumACES.AbstractScalingData","page":"QuantumACES.jl","title":"QuantumACES.AbstractScalingData","text":"AbstractScalingData\n\nScaling data for the figure of merit should be stored in a subtype T <: AbstractScalingData.\n\n\n\n\n\n","category":"type"},{"location":"internal/QuantumACES/#Private-functions","page":"QuantumACES.jl","title":"Private functions","text":"","category":"section"},{"location":"internal/QuantumACES/","page":"QuantumACES.jl","title":"QuantumACES.jl","text":"Modules = [QuantumACES]\nPages = [\"src/QuantumACES.jl\"]\nPublic = false","category":"page"},{"location":"internal/circuit/","page":"circuit.jl","title":"circuit.jl","text":"CollapsedDocStrings = true","category":"page"},{"location":"internal/circuit/#circuit.jl","page":"circuit.jl","title":"circuit.jl","text":"","category":"section"},{"location":"internal/circuit/#Public-functions","page":"circuit.jl","title":"Public functions","text":"","category":"section"},{"location":"internal/circuit/","page":"circuit.jl","title":"circuit.jl","text":"Modules = [QuantumACES]\nPages = [\"src/circuit.jl\"]\nPrivate = false","category":"page"},{"location":"internal/circuit/#QuantumACES.Circuit","page":"circuit.jl","title":"QuantumACES.Circuit","text":"Circuit\n\nCircuit information, including noise parameters.\n\nFields\n\ncircuit_param::AbstractCircuitParameters: Circuit parameters.\ncircuit::Vector{Layer}: Circuit.\ncircuit_tuple::Vector{Int}: Tuple which arranges the order of the circuit layers; this is initialised as trivial.\nqubit_num::Int: Number of qubits in the circuit.\nunique_layer_indices::Vector{Int}: Unique non-measurement gate layer indices of the circuit.\nlayer_types::Vector{Symbol}: Types of the layers in the circuit, used for layer times and dynamical decoupling.\nlayer_times::Vector{Float64}: Times taken to implement each layer in the circuit, as well as measurement and reset.\ngates::Vector{Gate}: Gates in the circuit arranged by the tuple.\ntotal_gates::Vector{Gate}: Total gates in the circuit, including preparations if noisy_prep and measurements if noisy_meas.\ngate_data::GateData: Gate data for the circuit.\nnoise_param::AbstractNoiseParameters: Noise parameters.\ngate_probabilities::Dict{Gate, Vector{Float64}}: Pauli error probabilities for each gate, stored as a dictionary.\ngate_eigenvalues::Vector{Float64}: Eigenvalues for each gate, stored as a vector whose order is determined by the gate order in total_gates and indexed by gate_data.\nnoisy_prep::Bool: Whether to treat preparations as noisy and characterise the associated noise, which should default to false; a full-rank design cannot be produced if both noisy_prep and noisy_meas are true.\nnoisy_meas::Bool: Whether to treat measurements as noisy and characterise the associated noise, which should default to true; a full-rank design cannot be produced if both noisy_prep and noisy_meas are true.\nextra_fields::Dict{Symbol, Any}: Extra data for the circuit, including code parameters for syndrome extraction circuits stored as a :code_param field which is a CodeParameters object.\n\n\n\n\n\n","category":"type"},{"location":"internal/circuit/#QuantumACES.CodeParameters","page":"circuit.jl","title":"QuantumACES.CodeParameters","text":"CodeParameters\n\nCode parameters for syndrome extraction circuits.\n\nNote that these expect the qubits to be arranged such that the data qubits are first, followed by the ancilla qubits, and these parameters should be checked with check_code_parameters.\n\nFields\n\nqubits::Vector{Tuple{Int, Int}}: Code qubit lattice locations.\nqubit_layout::Matrix{String}: Diagram of the layout of the code qubits.\ninverse_indices::Dict{Tuple{Int, Int}, Int}: Inverse mapping from the qubit lattice locations to their indices.\ndata_indices::Vector{Int}: Data qubit indices.\nancilla_indices::Vector{Int}: Ancilla qubit indices.\nancilla_x_indices::Vector{Int}: Ancilla X check qubit indices.\nancilla_z_indices::Vector{Int}: Ancilla Z check qubit indices.\ncheck_x_indices::Vector{Tuple{Vector{Int}, Vector{Int}}}: Pairs of (ancilla, data) qubit indices for each of the X checks.\ncheck_z_indices::Vector{Tuple{Vector{Int}, Vector{Int}}}: Pairs of (ancilla, data) qubit indices for each of the Z checks.\ninit_x_indices::Vector{Int}: Logical X initialisation qubit indices for which to initialise in the X basis.\ninit_z_indices::Vector{Int}: Logical Z initialisation qubit indices for which to initialise in the X basis.\nlogical_x_indices::Vector{Int}: Logical X operator qubit indices.\nlogical_z_indices::Vector{Int}: Logical Z operator qubit indices.\n\n\n\n\n\n","category":"type"},{"location":"internal/circuit/#QuantumACES.EmptyCircuitParameters","page":"circuit.jl","title":"QuantumACES.EmptyCircuitParameters","text":"EmptyCircuitParameters\n\nEmpty circuit parameters.\n\n\n\n\n\n","category":"type"},{"location":"internal/circuit/#QuantumACES.get_circuit-Union{Tuple{U}, Tuple{T}, Tuple{Vector{Layer}, Vector{Symbol}, Vector{Float64}, T}} where {T<:AbstractNoiseParameters, U<:AbstractCircuitParameters}","page":"circuit.jl","title":"QuantumACES.get_circuit","text":"get_circuit(circuit::Vector{Layer}, layer_types::Vector{Symbol}, layer_times::Vector{Float64}, noise_param::AbstractNoiseParameters; kwargs...)\n\nReturns a Circuit object given the supplied circuit and noise parameters.\n\nArguments\n\ncircuit::Vector{Layer}: Circuit.\nlayer_types::Vector{Symbol}: Types of the layers in the circuit.\nlayer_times::Vector{Float64}: Times taken to implement each layer in the circuit, as well as measurement and reset.\nnoise_param::AbstractNoiseParameters: Noise parameters for the circuit.\n\nKeyword arguments\n\ncircuit_param::AbstractCircuitParameters = EmptyCircuitParameters(): Circuit parameters.\nextra_fields::Dict{Symbol, Any} = Dict{Symbol, Any}(): Extra fields, including for CodeParameters.\nnoisy_prep::Bool = false: Whether to treat preparations as noisy and characterise the associated noise; a full-rank design cannot be produced if both noisy_prep and noisy_meas are true.\nnoisy_meas::Bool = true: Whether to treat measurements as noisy and characterise the associated noise; a full-rank design cannot be produced if both noisy_prep and noisy_meas are true.\ncombined::Bool = haskey(noise_param.params, :combined) ? noise_param.params[:combined] : false,: Whether to treat Pauli X, Y, and Z basis SPAM noise as the same.\nstrict::Bool = false: Whether to be strict about which gates count as estimable to relative precision.\n\n\n\n\n\n","category":"method"},{"location":"internal/circuit/#QuantumACES.get_combined_circuit-Tuple{T} where T<:AbstractCircuit","page":"circuit.jl","title":"QuantumACES.get_combined_circuit","text":"get_combined_circuit(c::AbstractCircuit)\n\nReturns a copy of the circuit c where the three parameters describing Pauli X, Y, and Z basis measurements have been combined into a single parameter for each qubit.\n\n\n\n\n\n","category":"method"},{"location":"internal/circuit/#QuantumACES.get_layer_times-Tuple{Vector{Symbol}, Dict{Symbol, Float64}}","page":"circuit.jl","title":"QuantumACES.get_layer_times","text":"get_layer_times(layer_types::Vector{Symbol}, layer_time_dict::Dict{Symbol, Float64})\n\nReturns the times taken to implement each layer in the circuit based on their types in layer_types and the times specified in `layertimedict, including the time for final measurement and reset.\n\n\n\n\n\n","category":"method"},{"location":"internal/circuit/#QuantumACES.update_noise-Union{Tuple{U}, Tuple{T}, Tuple{T, U}} where {T<:AbstractCircuit, U<:AbstractNoiseParameters}","page":"circuit.jl","title":"QuantumACES.update_noise","text":"update_noise(c::AbstractCircuit, noise_param::AbstractNoiseParameters)\nupdate_noise(c::AbstractCircuit, gate_probabilities::Dict{Gate, Vector{Float64}})\n\nReturns a copy of c where the circuit has been updated with noise generated according to noise_param, or the gate probabilities gate_probabilities.\n\n\n\n\n\n","category":"method"},{"location":"internal/circuit/#Private-functions","page":"circuit.jl","title":"Private functions","text":"","category":"section"},{"location":"internal/circuit/","page":"circuit.jl","title":"circuit.jl","text":"Modules = [QuantumACES]\nPages = [\"src/circuit.jl\"]\nPublic = false","category":"page"},{"location":"internal/circuit/#QuantumACES.EmptyNoiseParameters","page":"circuit.jl","title":"QuantumACES.EmptyNoiseParameters","text":"EmptyNoiseParameters\n\nEmpty noise parameters.\n\n\n\n\n\n","category":"type"},{"location":"internal/circuit/#QuantumACES.apply_tuple-Union{Tuple{T}, Tuple{T, Vector{Int64}}} where T<:AbstractCircuit","page":"circuit.jl","title":"QuantumACES.apply_tuple","text":"apply_tuple(c::AbstractCircuit, circuit_tuple::Vector{Int})\n\nReturns a copy of the circuit c arranged by the tuple circuit_tuple.\n\n\n\n\n\n","category":"method"},{"location":"internal/circuit/#QuantumACES.check_circuit-Tuple{Vector{Layer}, Vector{Int64}, Integer, Vector{Symbol}, Vector{Float64}}","page":"circuit.jl","title":"QuantumACES.check_circuit","text":"check_circuit(circuit::Vector{Layer}, circuit_tuple::Vector{Int}, qubit_num::Integer, layer_types::Vector{Symbol}, layer_times::Vector{Float64})\n\nChecks the provided circuit parameters are consistent with each other.\n\n\n\n\n\n","category":"method"},{"location":"internal/circuit/#QuantumACES.check_code_parameters-Tuple{CodeParameters, Integer}","page":"circuit.jl","title":"QuantumACES.check_code_parameters","text":"check_code_parameters(code_param::CodeParameters, qubit_num::Integer)\n\nChecks the provided code parameters are consistent with each other.\n\n\n\n\n\n","category":"method"},{"location":"internal/circuit/#QuantumACES.get_gates-Tuple{Vector{Vector{Gate}}}","page":"circuit.jl","title":"QuantumACES.get_gates","text":"get_gates(circuit::Vector{Vector{Gate}})\nget_gates(circuit::Vector{Layer})\n\nReturns the unique gates in the circuit circuit.\n\n\n\n\n\n","category":"method"},{"location":"internal/circuit/#QuantumACES.get_total_gates-Tuple{Vector{Layer}, Bool, Bool}","page":"circuit.jl","title":"QuantumACES.get_total_gates","text":"get_total_gates(circuit::Vector{Layer}, noisy_prep::Bool, noisy_meas::Bool)\n\nReturns the total gates in the circuit circuit, including preparations if noisy_prep and measurements if noisy_meas each on all of the qubits, as well as a separate list of the added measurement gates.\n\n\n\n\n\n","category":"method"},{"location":"internal/circuit/#QuantumACES.label_circuit-Tuple{Vector{Vector{Gate}}}","page":"circuit.jl","title":"QuantumACES.label_circuit","text":"label_circuit(circuit::Vector{Vector{Gate}})\nlabel_circuit(circuit::Vector{Layer})\n\nReturns a labelled copy of the circuit circuit, with indices indicating the unique layer appearances of each gate in the circuit. This function should only be applied to the original circuit before it is arranged by a tuple.\n\n\n\n\n\n","category":"method"},{"location":"internal/circuit/#QuantumACES.prepare_circuit-Union{Tuple{T}, Tuple{Vector{Layer}, T}} where T<:AbstractNoiseParameters","page":"circuit.jl","title":"QuantumACES.prepare_circuit","text":"prepare_circuit(circuit::Vector{Layer}, noise_param::AbstractNoiseParameters; noisy_prep::Bool = false, noisy_meas::Bool = true)\n\nReturns a labelled copy of the circuit as well as a number of required fields for subtypes T <: AbstractCircuit.\n\nArguments\n\ncircuit::Vector{Layer}: Circuit.\nnoise_param::AbstractNoiseParameters: Noise parameters.\n\nKeyword arguments\n\nnoisy_prep::Bool = false: Whether to treat preparations as noisy and aim to characterise them.\nnoisy_meas::Bool = true: Whether to treat measurements as noisy and aim to characterise them.\ncombined::Bool: Whether to treat Pauli X, Y, and Z basis SPAM noise as the same.\nstrict::Bool = false: Whether to be strict about which gates count as estimable to relative precision.\n\nReturns\n\ncircuit::Vector{Layer}: Circuit with labelled gates.\nunique_layer_indices::Vector{Int}: Unique non-measurement gate layer indices of the circuit.\ngates::Vector{Gate}: Gates in the circuit.\ntotal_gates::Vector{Gate}: Total gates in the circuit, including preparations if noisy_prep and measurements if noisy_meas.\ngate_data::GateData: Gate data for the circuit.\ngate_probabilities::Dict{Gate, Vector{Float64}}: Pauli error probabilities for each gate, stored as a dictionary.\ngate_eigenvalues::Vector{Float64}: Eigenvalues for each gate, stored as a vector whose order is determined by the gate order in total_gates and indexed by gate_data.\n\n\n\n\n\n","category":"method"},{"location":"internal/circuit/#QuantumACES.unwrap_circuit-Tuple{Vector{Layer}}","page":"circuit.jl","title":"QuantumACES.unwrap_circuit","text":"unwrap_circuit(circuit::Vector{Layer})\n\nReturns a copy of the circuit circuit where each layer has been unwrapped into a vector of gates.\n\n\n\n\n\n","category":"method"},{"location":"internal/device/","page":"device.jl","title":"device.jl","text":"CollapsedDocStrings = true","category":"page"},{"location":"internal/device/#device.jl","page":"device.jl","title":"device.jl","text":"","category":"section"},{"location":"internal/device/#Public-functions","page":"device.jl","title":"Public functions","text":"","category":"section"},{"location":"internal/device/","page":"device.jl","title":"device.jl","text":"Modules = [QuantumACES]\nPages = [\"src/device.jl\"]\nPrivate = false","category":"page"},{"location":"internal/device/#QuantumACES.estimate_qiskit_ensemble-Tuple{RandDesign, Vector{Int64}, Integer}","page":"device.jl","title":"QuantumACES.estimate_qiskit_ensemble","text":"estimate_qiskit_ensemble(d_rand::RandDesign, qiskit_qubit_map::Vector{Int}, experiment_shots::Integer; fail_jobs::Vector{Int} = Int[], backend::String = \"qiskit\", ls_type::Symbol = :fgls, split::Bool = false, min_eigenvalue::Real = 0.1)\n\nReturns estimated circuit eigenvalues, and gate noise estimates from Qiskit data processed with [process_qiskit_ensemble] for the randomised experimental design d_rand with experiment_shots shots per circuit. Avoids attempting to load failed jobs specified by fail_jobs. The simulated data is loaded according to the label implied by the supplied backend, and the estimation procedure uses the least squares estimator ls_type, splitting the gate eigenvalue estimator projection across the gates if split is true, and includes only circuit eigenvalues which are at least min_eigenvalue.\n\n\n\n\n\n","category":"method"},{"location":"internal/device/#QuantumACES.estimate_stim_ensemble-Tuple{RandDesign, Integer}","page":"device.jl","title":"QuantumACES.estimate_stim_ensemble","text":"estimate_stim_ensemble(d_rand::RandDesign, experiment_shots::Integer; fail_jobs::Vector{Int} = Int[], simulation_seed::Union{UInt64, Nothing} = nothing, ls_type::Symbol = :fgls, split::Bool = false, min_eigenvalue::Real = 0.1)\n\nReturns estimated circuit eigenvalues and gate noise estimates from simulated Stim data for the randomised experimental design d_rand with experiment_shots shots per circuit produced by simulate_stim_ensemble. Avoids attempting to load failed jobs specified by fail_jobs. The simulated data is loaded according to the label implied by the supplied simulation_seed, and the estimation procedure uses the least squares estimator ls_type, splitting the gate eigenvalue estimator projection across the gates if split is true, and includes only circuit eigenvalues which are at least min_eigenvalue.\n\n\n\n\n\n","category":"method"},{"location":"internal/device/#QuantumACES.process_qiskit_ensemble-Tuple{RandDesign, Integer, Vector{Int64}, Integer}","page":"device.jl","title":"QuantumACES.process_qiskit_ensemble","text":"process_qiskit_ensemble(d_rand::RandDesign, qiskit_qubit_num::Integer, qiskit_qubit_map::Vector{Int}, experiment_shots::Integer; backend::String = \"qiskit\", prefix::String = \"result\")\n\nSaves a processed version of saved Qiskit data for the randomised experimental design d_rand, produced for example by simulate_qiskit_ensemble, whose associated ensemble of Qiskit circuits act on qiskit_qubit_num qubits and are indexed by the mapping qiskit_qubit_map, and which were run with experiment_shots shots for each circuit. The saved data is loaded according to the labelling implied by the supplied backend and prefix.\n\n\n\n\n\n","category":"method"},{"location":"internal/device/#QuantumACES.simulate_qiskit_ensemble-Tuple{RandDesign, PythonCall.Core.Py, Integer}","page":"device.jl","title":"QuantumACES.simulate_qiskit_ensemble","text":"simulate_qiskit_ensemble(d_rand::RandDesign, qiskit_ensemble::Py, experiment_shots::Integer; backend::String = \"qiskit\", prefix::String = \"result\", simulator::Py = aer.AerSimulator(; method = \"stabilizer\"), diagnostics::Bool = true)\n\nSaves data simulated with Qiskit for the randomised experimental design d_rand with an associated ensemble of Qiskit circuits qiskit_ensemble produced by get_stim_qiskit_ensemble, with experiment_shots shots for each circuit. The saved data is labelled according to the supplied backend and prefix, and simulated using the supplied simulator, displaying diagnostics if diagnostics is `true.\n\n\n\n\n\n","category":"method"},{"location":"internal/device/#QuantumACES.simulate_stim_ensemble-Tuple{RandDesign, Vector{Vector{String}}, Integer}","page":"device.jl","title":"QuantumACES.simulate_stim_ensemble","text":"simulate_stim_ensemble(d_rand::RandDesign, stim_ensemble::Vector{Vector{String}}, experiment_shots::Integer; seed::Union{UInt64, Nothing} = nothing, diagnostics::Bool = true)\n\nSaves data simulated with Stim for the randomised experimental design d_rand with an associated ensemble of Stim circuits stim_ensemble produced by get_stim_qiskit_ensemble, with experiment_shots shots for each circuit. The simulation uses the random seed seed and displays diagnostics if diagnostics is true.\n\n\n\n\n\n","category":"method"},{"location":"internal/device/#Private-functions","page":"device.jl","title":"Private functions","text":"","category":"section"},{"location":"internal/device/","page":"device.jl","title":"device.jl","text":"Modules = [QuantumACES]\nPages = [\"src/device.jl\"]\nPublic = false","category":"page"},{"location":"internal/kwargs/","page":"kwargs.jl","title":"kwargs.jl","text":"CollapsedDocStrings = true","category":"page"},{"location":"internal/kwargs/#kwargs.jl","page":"kwargs.jl","title":"kwargs.jl","text":"","category":"section"},{"location":"internal/kwargs/#Public-functions","page":"kwargs.jl","title":"Public functions","text":"","category":"section"},{"location":"internal/kwargs/","page":"kwargs.jl","title":"kwargs.jl","text":"Modules = [QuantumACES]\nPages = [\"src/kwargs.jl\"]\nPrivate = false","category":"page"},{"location":"internal/kwargs/#QuantumACES.OptimOptions","page":"kwargs.jl","title":"QuantumACES.OptimOptions","text":"OptimOptions\n\nKeyword arguments for optimise_design, and specifically the optimisation functions within it, including for the gradient descent function optimise_weights, the repetition number optimisation function optimise_repetitions, and the tuple set optimisation function optimise_tuple_set.\n\nGeneral options\n\nls_type::Symbol = :gls: Type of least squares estimator for which we optimise the design, which can be :gls, :wls, or :ols.\nest_type::Symbol = :prod: Type of estimator for which we optimise the design, which can be :ordinary, :marginal, :relative, or :sum or :prod, which optimise for the arithmetic or geometric mean, respectively, of the :ordinary and :relative estimator figures of merit weighted by est_weight.\nest_weight::Real = 0.5: Weighting of the :ordinary estimator figure of merit in the arithmetic or geometric mean when est_type is :sum or :prod, respectively, such that :relative is weighted by 1 - est_weight.\nsave_data::Bool = false: Whether to automatically save the optimised design.\n\nGradient descent options\n\nlearning_rate::Real = (ls_type == :ols ? 1 : 10.0^(3/4)): Learning rate for the gradient descent algorithm.\nmomentum::Real = 0.99: Momentum for the gradient descent algorithm.\nlearning_rate_scale_factor::Real = 10.0^(1/4): Factor by which to reduce the learning rate if the gradient descent algorithm repeatedly steps in directions that reduce the figure of merit.\nmax_steps::Integer = 1000: Maximum number of gradient descent steps to take.\nconvergence_threshold::Real = 1e-5: Convergence threshold for the gradient descent algorithm.\nconvergence_steps::Integer = 5: Number of steps over which to check convergence.\ngrad_diagnostics::Bool = false: Whether to display gradient descent diagnostics.\n\nReptition number optimisation options\n\nrep_est_type::Symbol = :relative: Type of estimator for which we optimise the repetition number, which can be :ordinary, :marginal, :relative, or :sum or :prod, which optimise for the arithmetic or geometric mean, respectively, of the :ordinary and :relative estimator figures of merit weighted by rep_est_weight.\nrep_est_weight::Real = 0.5: Weighting of the :ordinary estimator figure of merit in the arithmetic or geometric mean when rep_est_type is :sum or :prod, respectively, such that :relative is weighted by 1 - rep_est_weight.\nerror_target::Real = 0.1: Controls initialisation of the repetition numbers, which heuristically roughly target this error rate; note that setting this to 0 initialises repetition numbers as 0, and all such repetition numbers are then set to 2 before optimisation.\nadd_circuit::Bool = true: Whether to add the circuit itself to the repeat tuple set.\ncycle_convergence_threshold::Real = 1e-5: Convergence threshold for the cyclic coordinate descent algorithm for optimising repetition numbers.\nconvergence_cycles::Integer = 5: Number of steps over which to check convergence for the cyclic coordinate descent algorithm for optimising repetition numbers.\nmin_depth::Integer = 0: Minimum depth of repeated tuples.\nmax_depth::Integer = 1000: Maximum depth of repeated tuples.\nmax_cycles::Integer = 100: Maximum number of cycles to use in the cyclic coordinate descent algorithm for optimising repetition numbers.\nrepeat_points::Integer = 1: Each repeat number is augmented to have repeat_points repeat numbers, logarithmically spaced with the smallest repeat number which is shrunk by a factor initial_shrink_factor.\ninitial_shrink_factor::Real = 2^(repeat_points - 1): Factor by which the smallest repeat number in an augmented tuple set is shrunk.\nrep_diagnostics::Bool = true: Whether to display repetition number optimisation diagnostics.\n\nTuple set optimisation options\n\ntuple_est_type::Symbol = :ordinary: Type of estimator for which we optimise the tuple set, which can be :ordinary, :marginal, :relative, :sum, or :prod, which optimise for the arithmetic or geometric mean, respectively, of the :ordinary and :relative estimator figures of merit weighted by tuple_est_weight.\ntuple_est_weight::Real = 0.5: Weighting of the :ordinary estimator figure of merit in the arithmetic or geometric mean when tuple_est_type is :sum or :prod, respectively, such that :relative is weighted by 1 - tuple_est_weight.\nmax_excursions::Integer = 100: Number of excurisons used to optimise the tuple set.\nexcursions_unchanged::Integer = 3: Number of excursions that must not change the tuple set before the optimisation routine terminates.\nexcursion_length::Integer = 5: Number of tuples added by each excursion.\nextra_tuple_number::Integer = 5: Number of tuples beyond the number in the basic tuple set added by the tuple set optimisation procedure.\nmax_tuple_length::Integer = 20: Maximum length of random tuples.\ntuple_length_zipf_power::Real = 1: Zipf power to use when Zipf-randomly choosing the length of random tuples.\nrepeat_zipf_powers::Vector{Float64} = [Inf; 2.0]: Zipf power to use, chosen uniformly at random from the vector, when Zipf-randomly choosing how many times to repeat entries that will be appended to the end of a random tuple during its generation.\nmirror_values::Vector{Bool} = [false; true]: Whether to mirror the tuple, chosen uniformly at random from the vector, when generating random tuples.\ntrial_factor::Integer = 20: Number of random tuples trialled for each tuple the excursion needs to add to the tuple set to grow it.\ngrow_greedy::Bool = true: Whether the excursions add tuples to the set greedily according to the figure of merit, or to add them even if this reduces the figure of merit.\nweight_experiments::Bool = false: Whether to weight the shot weights for a tuple by the number of experiments for that tuple; while usually true, false performs better for tuple set optimisation.\nseed::Union{UInt64, Nothing} = nothing: Seed used to randomly generate tuples.\ntuple_diagnostics::Bool = true: Whether to display tuple set optimisation diagnostics.\n\n\n\n\n\n","category":"type"},{"location":"internal/kwargs/#Private-functions","page":"kwargs.jl","title":"Private functions","text":"","category":"section"},{"location":"internal/kwargs/","page":"kwargs.jl","title":"kwargs.jl","text":"Modules = [QuantumACES]\nPages = [\"src/kwargs.jl\"]\nPublic = false","category":"page"},{"location":"performance/#Package-Performance","page":"Package Performance","title":"Package Performance","text":"","category":"section"},{"location":"performance/","page":"Package Performance","title":"Package Performance","text":"QuantumACES has several performance optimisations that are essential for its practical utility. We now examine some core optimisations that may be of particular interest through the lens of the functions optimise_design and simulate_aces. These functions optimise experimental designs and simulate ACES noise characterisation experiments, respectively.","category":"page"},{"location":"performance/","page":"Package Performance","title":"Package Performance","text":"First, we discuss the optimisation of experimental designs with optimise_design. Crucial to the tractability of this optimisation is the fact that we can perform the optimisation at small scales, such as the syndrome extraction circuits of distance-3 topological codes, and then transfer the optimised design to the syndrome extraction circuits of the same codes at larger distances, while retaining performance characteristics. As discussed in arXiv:2404.06545, an ACES experimental design (mathcalTGamma) is parameterised by the tuple set mathcalT and the shot weights Gamma. The tuple set mathcalT is discrete and cannot be optimised continuously, and so its optimisation relies on repeated calculation of the figure of merit mathcalF, which is given in \\cref{eq:aces-figure-of-merit}. However, the shot weights Gamma are continuous, allowing us to optimise them with gradient descent. This relies on the fast calculation of the gradient of the figure of merit with respect to the shot weights with analytic expressions for these gradients. Carefully optimised calculation of these analytic expressions is roughly one and a half orders of magnitude faster than forward-mode automatic differentiation, which is much faster than backward-mode automatic differentiation in this case.","category":"page"},{"location":"performance/","page":"Package Performance","title":"Package Performance","text":"We now remark on some considerations in the linear algebra calculations of the figure of merit and its gradient. The design matrix A is sparse, and the circuit (log-)eigenvalue estimator covariance matrix Omega (Omega^prime) is block diagonal with the blocks themselves being sparse. It is important to appropriately leverage this sparsity in calculations. Matrix multiplications quickly densify sparse matrices, at which point the matrices must be converted to dense form to avoid substantial performance degradation. In general, QuantumACES calculates matrix inverses for dense symmetric matrices, and so leverages the Cholesky or Bunch-Kaufman decompositions depending on whether the matrix is positive definite or not, respectively. It is often necessary to invert Omega or Omega^prime, and this leverages the sparse Cholesky decomposition for separate blocks of the matrix. Lastly, QuantumACES calculates the condition number and pseudoinverse norm of A with sparse methods for eigenvalue finding.","category":"page"},{"location":"performance/","page":"Package Performance","title":"Package Performance","text":"Next, we discuss the simulation of ACES noise characterisation experiments with simulate_aces. Experiments are simulated with Stim, a fast simulator for stabiliser circuits with Pauli noise, with the function simulate_stim_estimate. This function simulates experiments with Stim and immediately estimates the circuit eigenvalues measured by the experiment to avoid storing large numbers of measurement outcomes in memory. By default, Stim outputs measurement outcomes as bits, but can instead pack measurement outcomes into 8-bit unsigned integers, which in practice speeds up sampling of circuit outcomes by roughly a factor of 8. These bit-packed results can then be processed quickly with careful bit manipulation to estimate the circuit eigenvalues measured by the experiment. It is also important to automatically split up Stim simulations that attempt to sample too many shots at once to avoid memory issues. One step in this simulation process that can surprisingly become a bottleneck is the creation of the circuit string for Stim corresponding to each experiment. If the string manipulation is not optimised, this can become very slow for large circuits.","category":"page"},{"location":"performance/","page":"Package Performance","title":"Package Performance","text":"Once the Stim simulations have been performed to estimate the circuit eigenvalues, we then estimate the gate eigenvalues and Pauli error probabilities with the function estimate_gate_noise. We will discuss this process in the context of GLS, though at large scales it is essential to only construct the diagonal of the circuit eigenvalue estimator covariance matrix Omega and hence only perform WLS. First, we calculate the sparse block diagonal Cholesky factorisation of the circuit log-eigenvalue estimator covariance matrix Omega^prime=LL^intercal, and calculate the inverse of the Cholesky factor L^-1. Then we left-divide the scaled design matrix L^-1A by the scaled circuit log-eigenvalues L^-1bmb to obtain the estimated gate log-eigenvalues hatbmx. The left-division operator in Julia leverages the sparse structure of the inversion problem and is very fast. Once we have the gate log-eigenvalues, we can straightforwardly estimate the Pauli error probabilities for each gate in the circuit.","category":"page"},{"location":"performance/","page":"Package Performance","title":"Package Performance","text":"However, these estimates are not guaranteed to be valid probability distributions, so we must project the estimates into the probability simplex. As discussed in arXiv:2502.21044, we perform this projection in the Mahalanobis distance with the fast convex solver SCS.jl. We can optimise calculation of the precision matrix such that the only matrix inversion required is the highly-optimised inversion of the circuit log-eigenvalue estimator covariance matrix Omega^prime. This projection performs best, at least at small scales, when single-threaded by setting ENV[\"OMP_NUM_THREADS\"] = \"1\" in ~/.julia/config/startup.jl, but this causes large performance regressions in other linear algebra routines in the package, so the setting is only advised when benchmarking the time taken to perform ACES noise estimation.","category":"page"},{"location":"internal/simulate/","page":"simulate.jl","title":"simulate.jl","text":"CollapsedDocStrings = true","category":"page"},{"location":"internal/simulate/#simulate.jl","page":"simulate.jl","title":"simulate.jl","text":"","category":"section"},{"location":"internal/simulate/#Public-functions","page":"simulate.jl","title":"Public functions","text":"","category":"section"},{"location":"internal/simulate/","page":"simulate.jl","title":"simulate.jl","text":"Modules = [QuantumACES]\nPages = [\"src/simulate.jl\"]\nPrivate = false","category":"page"},{"location":"internal/simulate/#QuantumACES.ACESData","page":"simulate.jl","title":"QuantumACES.ACESData","text":"ACESData\n\nACES noise characterisation experiment simulation results.\n\nFields\n\nd::Design: Experimental design.\nnoise_est_coll::Matrix{NoiseEstimate}: Noise estimates for each repetition and measurement budget.\nnoise_error_coll::Matrix{NoiseError}: Noise errors for each repetition and measurement budget.\nbudget_set::Vector{Int}: Measurement budgets.\nshots_set::Vector{Int}: Measurement shots corresponding to the measurement budgets in budget_set.\nrepetitions::Int: Repetitions of simulating an ACES noise characterisation experiment.\nseed::UInt64: Seed used to generate the random seeds for each repetition.\nseeds::Vector{UInt64}: Seeds for each of the repetitions.\ncalculation_times::Matrix{Float64}: Time taken to simulate sampling, and to estimate the gate eigenvalues and project them into the probability simplex, for each repetition.\noverall_time::Float64: Overall time taken to simulate ACES across all repetitions.\n\n\n\n\n\n","category":"type"},{"location":"internal/simulate/#QuantumACES.get_model_violation-Tuple{ACESData}","page":"simulate.jl","title":"QuantumACES.get_model_violation","text":"get_model_violation(aces_data::ACESData; projected::Bool = false)\n\nReturns the noise model violation z-score for the generalised residual sum of squares corresponding to the noise estimates stored in aces_data, given the design also stored in aces_data, calculating with the projected gate eigenvalues if projected is true.\n\n\n\n\n\n","category":"method"},{"location":"internal/simulate/#QuantumACES.get_noise_score-Tuple{ACESData, Merit}","page":"simulate.jl","title":"QuantumACES.get_noise_score","text":"get_noise_score(aces_data::ACESData, merit::Merit)\n\nReturns the z-scores for the supplied normalised root-mean-square error (NRMSE) data in the noise errors stored in aces_data, given the merit merit.\n\n\n\n\n\n","category":"method"},{"location":"internal/simulate/#QuantumACES.simulate_aces-Tuple{Design, Vector{Int64}}","page":"simulate.jl","title":"QuantumACES.simulate_aces","text":"simulate_aces(d::Design, budget_set::Vector{Int}; kwargs...)\n\nReturns simulated ACES noise characterisation experiment results as an ACESData object for the experimental design d across each of the measurement budgets in budget_set.\n\nWARNING: Seeding has the same features as in Stim. The behaviour of the same random seed will differ across different versions of Stim. Also, when measurement shots are sampled in batches, which occurs when max_samples is exceeded, the results will differ from when all shots are sampled at once.\n\nArguments\n\nd::Design: Experimental design.\nbudget_set::Vector{Int}: Measurement budgets for which to simulate ACES.\n\nKeyword arguments\n\nrepetitions::Integer = 1: Number of simulation repetitions.\nseed::Union{UInt64, Nothing} = nothing: Seed to use for random number generation.\nN_warn::Integer = 10^5: Number of circuit eigenvalues above which to warn the user about certain keyword argument choices.\nmax_samples::Integer = 10^9: Maximum number of Stim samples collected in a single simulation.\nmin_eigenvalue::Real = 0.1: Circuit eigenvalues below this threshold are omitted from the estimation procedure.\nclip_warning::Bool = false: Whether to warn the user about clipped eigenvalues.\nN_warn_split::Integer = 5 * 10^3: Number of circuit eigenvalues above which to warn the user about if split is false.\nsplit::Bool = (d.c.gate_data.N < N_warn_split ? false : true): Whether to split the gate eigenvalue projection across gates or simultaneously project all gate eigenvalues.\nprecision::Real = 1e-8: Precision of the solver for projecting noise estimates into the probability simplex.\ndiagnostics::Bool = true: Whether to print diagnostics.\ndetailed_diagnostics::Bool = false: Whether to print detailed diagnostics for Stim simulations.\nsave_data::Bool = false: Whether to save the data.\nsave_interval::Integer = 50: Repetition interval at which to save the data.\nclear_design::Bool = false: Whether to clear the saved design data after saving the full simulation data.\n\n\n\n\n\n","category":"method"},{"location":"internal/simulate/#QuantumACES.simulate_stim_estimate-Tuple{Design, Vector{Int64}}","page":"simulate.jl","title":"QuantumACES.simulate_stim_estimate","text":"simulate_stim_estimate(d::Design, shots_set::Vector{Int}; kwargs...)\n\nReturns simulated estimated circuit eigenvalues, covariance circuit eigenvalues, and corresponding circuit eigenvalue pairs, for the experimental design d across each of the measurement shots in shots_set.\n\nKeyword arguments\n\nseed::Union{UInt64, Nothing} = nothing: Seed controlling the random seeds for Stim.\nmax_samples::Integer = 10^9: Maximum number of samples to take in a single Stim simulation.\ndetailed_diagnostics::Bool = false: Whether to print diagnostic information about the simulation.\n\n\n\n\n\n","category":"method"},{"location":"internal/simulate/#Private-functions","page":"simulate.jl","title":"Private functions","text":"","category":"section"},{"location":"internal/simulate/","page":"simulate.jl","title":"simulate.jl","text":"Modules = [QuantumACES]\nPages = [\"src/simulate.jl\"]\nPublic = false","category":"page"},{"location":"internal/simulate/#QuantumACES.stim_sample-Tuple{String, Integer}","page":"simulate.jl","title":"QuantumACES.stim_sample","text":"stim_sample(stim_circuit_string::String, shots::Integer; stim_seed::Union{UInt64, Nothing} = nothing)\n\nReturns bit-packaged measurement outcomes from simulating the circuit stim_circuit_string over shots measurement shots using the Python package Stim. While the seed stim_seed can be fixed, Stim guarantees inconsistency when using the same seed on different versions.\n\n\n\n\n\n","category":"method"},{"location":"internal/scaling/","page":"scaling.jl","title":"scaling.jl","text":"CollapsedDocStrings = true","category":"page"},{"location":"internal/scaling/#scaling.jl","page":"scaling.jl","title":"scaling.jl","text":"","category":"section"},{"location":"internal/scaling/#Public-functions","page":"scaling.jl","title":"Public functions","text":"","category":"section"},{"location":"internal/scaling/","page":"scaling.jl","title":"scaling.jl","text":"Modules = [QuantumACES]\nPages = [\"src/scaling.jl\"]\nPrivate = false","category":"page"},{"location":"internal/scaling/#QuantumACES.EnsembleFit","page":"scaling.jl","title":"QuantumACES.EnsembleFit","text":"EnsembleFit\n\nEnsemble scaling fit data for an experimental design for a circuit with vertical and horizontal distance parameters under a random noise model.\n\nAll pair fit parameters correspond to the trace and trace squared quadratic terms appearing in the expressions for the expectation and variance.\n\nFields\n\ngls_pair::Vector{Float64}: Ordinary GLS pair quadratic fit parameters.\ngls_expectation_model::Function: Model for the ordinary GLS expectation.\ngls_variance_model::Function: Model for the ordinary GLS variance.\ngls_marginal_pair::Vector{Float64}: Marginal GLS pair quadratic fit parameters.\ngls_marginal_expectation_model::Function: Model for the marginal GLS expectation.\ngls_marginal_variance_model::Function: Model for the marginal GLS variance.\ngls_relative_pair::Vector{Float64}: Relative GLS pair quadratic fit parameters.\ngls_relative_expectation_model::Function: Model for the relative GLS expectation.\ngls_relative_variance_model::Function: Model for the relative GLS variance.\nwls_pair::Vector{Float64}: Ordinary WLS pair quadratic fit parameters.\nwls_expectation_model::Function: Model for the ordinary WLS expectation.\nwls_variance_model::Function: Model for the ordinary WLS variance.\nwls_marginal_pair::Vector{Float64}: Marginal WLS pair quadratic fit parameters.\nwls_marginal_expectation_model::Function: Model for the marginal WLS expectation.\nwls_marginal_variance_model::Function: Model for the marginal WLS variance.\nwls_relative_pair::Vector{Float64}: Relative WLS pair quadratic fit parameters.\nwls_relative_expectation_model::Function: Model for the relative WLS expectation.\nwls_relative_variance_model::Function: Model for the relative WLS variance.\nols_pair::Vector{Float64}: Ordinary OLS pair quadratic fit parameters.\nols_expectation_model::Function: Model for the ordinary OLS expectation.\nols_variance_model::Function: Model for the ordinary OLS variance.\nols_marginal_pair::Vector{Float64}: Marginal OLS pair quadratic fit parameters.\nols_marginal_expectation_model::Function: Model for the marginal OLS expectation.\nols_marginal_variance_model::Function: Model for the marginal OLS variance.\nols_relative_pair::Vector{Float64}: Relative OLS pair quadratic fit parameters.\nols_relative_expectation_model::Function: Model for the relative OLS expectation.\nols_relative_variance_model::Function: Model for the relative OLS variance.\n\n\n\n\n\n","category":"type"},{"location":"internal/scaling/#QuantumACES.EnsembleScaling","page":"scaling.jl","title":"QuantumACES.EnsembleScaling","text":"EnsembleScaling\n\nEnsemble scaling data for an experimental design for a circuit with vertical and horizontal distance parameters under a random noise model.\n\nFields\n\nd::Design: Design for which the scaling data is calculated.\ndist_range::Vector{Int}: Circuit distances.\nmerits::Vector{Merit}: Merits of the design for each distance.\nmerit_ensemble::Vector{Vector{Merit}}: Merits of the design across random noise models for each distance.\nseeds::Vector{UInt64}: Seeds for the random noise parameters.\ncalculation_times::Matrix{Float64}: The time to generate the design, calculate the depolarising merit, and calculate the merit ensemble, for each distance.\noverall_time::Float64: The overall time taken to calculate the merit ensemble scaling data.\n\n\n\n\n\n","category":"type"},{"location":"internal/scaling/#QuantumACES.MeritScaling","page":"scaling.jl","title":"QuantumACES.MeritScaling","text":"MeritScaling\n\nScaling data for an experimental design for a circuit with vertical and horizontal distance parameters, conventionally under depolarising noise.\n\nFields\n\nd::Design: Design for which the scaling data is calculated.\ndist_range::Vector{Int}: Circuit distances.\nmerits::Vector{Merit}: Merits of the design for a range of distances.\ncalculation_times::Matrix{Float64}: Time taken to generate the design, and calculate the merit, for each distance.\noverall_time::Float64: The overall time taken to calculate the merit scaling data for depolarising noise.\n\n\n\n\n\n","category":"type"},{"location":"internal/scaling/#QuantumACES.ScalingFit","page":"scaling.jl","title":"QuantumACES.ScalingFit","text":"ScalingFit\n\nScaling fit data for an experimental design for a circuit with vertical and horizontal distance parameters, conventionally under depolarising noise.\n\nAll fit parameters describe a quadratic as p1 + p2 * dist + p3 * dist^2.\n\nFields\n\nN::Vector{Int}: Gate eigenvalues quadratic fit parameters.\nN_model::Function: Quadratic model for the gate eigenvalues.\nN_marginal::Vector{Int}: Marginal gate eigenvalues quadratic fit parameters.\nN_marginal_model::Function: Quadratic model for the marginal gate eigenvalues.\nN_relative::Vector{Int}: Relative gate eigenvalues quadratic fit parameters.\nN_relative_model::Function: Quadratic model for the relative gate eigenvalues.\nG::Vector{Int}: Gate number quadratic fit parameters.\nG_model::Function: Quadratic model for the gate number.\ngls_tr::Vector{Float64}: Ordinary GLS trace quadratic fit parameters.\ngls_tr_model::Function: Quadratic model for the ordinary GLS trace.\ngls_tr_sq::Vector{Float64}: Ordinary GLS trace squared quadratic fit parameters.\ngls_tr_sq_model::Function: Quadratic model for the ordinary GLS trace squared.\ngls_expectation_model::Function: Model for the ordinary GLS expectation.\ngls_variance_model::Function: Model for the ordinary GLS variance.\ngls_marginal_tr::Vector{Float64}: Marginal GLS trace quadratic fit parameters.\ngls_marginal_tr_model::Function: Quadratic model for the marginal GLS trace.\ngls_marginal_tr_sq::Vector{Float64}: Marginal GLS trace squared quadratic fit parameters.\ngls_marginal_tr_sq_model::Function: Quadratic model for the marginal GLS trace squared.\ngls_marginal_expectation_model::Function: Model for the marginal GLS expectation.\ngls_marginal_variance_model::Function: Model for the marginal GLS variance.\ngls_relative_tr::Vector{Float64}: Relative GLS trace quadratic fit parameters.\ngls_relative_tr_model::Function: Quadratic model for the relative GLS trace.\ngls_relative_tr_sq::Vector{Float64}: Relative GLS trace squared quadratic fit parameters.\ngls_relative_tr_sq_model::Function: Quadratic model for the relative GLS trace squared.\ngls_relative_expectation_model::Function: Model for the relative GLS expectation.\ngls_relative_variance_model::Function: Model for the relative GLS variance.\nwls_tr::Vector{Float64}: Ordinary WLS trace quadratic fit parameters.\nwls_tr_model::Function: Quadratic model for the ordinary WLS trace.\nwls_tr_sq::Vector{Float64}: Ordinary WLS trace squared quadratic fit parameters.\nwls_tr_sq_model::Function: Quadratic model for the ordinary WLS trace squared.\nwls_expectation_model::Function: Model for the ordinary WLS expectation.\nwls_variance_model::Function: Model for the ordinary WLS variance.\nwls_marginal_tr::Vector{Float64}: Marginal WLS trace quadratic fit parameters.\nwls_marginal_tr_model::Function: Quadratic model for the marginal WLS trace.\nwls_marginal_tr_sq::Vector{Float64}: Marginal WLS trace squared quadratic fit parameters.\nwls_marginal_tr_sq_model::Function: Quadratic model for the marginal WLS trace squared.\nwls_marginal_expectation_model::Function: Model for the marginal WLS expectation.\nwls_marginal_variance_model::Function: Model for the marginal WLS variance.\nwls_relative_tr::Vector{Float64}: Relative WLS trace quadratic fit parameters.\nwls_relative_tr_model::Function: Quadratic model for the relative WLS trace.\nwls_relative_tr_sq::Vector{Float64}: Relative WLS trace squared quadratic fit parameters.\nwls_relative_tr_sq_model::Function: Quadratic model for the relative WLS trace squared.\nwls_relative_expectation_model::Function: Model for the relative WLS expectation.\nwls_relative_variance_model::Function: Model for the relative WLS variance.\nols_tr::Vector{Float64}: Ordinary OLS trace quadratic fit parameters.\nols_tr_model::Function: Quadratic model for the ordinary OLS trace.\nols_tr_sq::Vector{Float64}: Ordinary OLS trace squared quadratic fit parameters.\nols_tr_sq_model::Function: Quadratic model for the ordinary OLS trace squared.\nols_expectation_model::Function: Model for the ordinary OLS expectation.\nols_variance_model::Function: Model for the ordinary OLS variance.\nols_marginal_tr::Vector{Float64}: Marginal OLS trace quadratic fit parameters.\nols_marginal_tr_model::Function: Quadratic model for the marginal OLS trace.\nols_marginal_tr_sq::Vector{Float64}: Marginal OLS trace squared quadratic fit parameters.\nols_marginal_tr_sq_model::Function: Quadratic model for the marginal OLS trace squared.\nols_marginal_expectation_model::Function: Model for the marginal OLS expectation.\nols_marginal_variance_model::Function: Model for the marginal OLS variance.\nols_relative_tr::Vector{Float64}: Relative OLS trace quadratic fit parameters.\nols_relative_tr_model::Function: Quadratic model for the relative OLS trace.\nols_relative_tr_sq::Vector{Float64}: Relative OLS trace squared quadratic fit parameters.\nols_relative_tr_sq_model::Function: Quadratic model for the relative OLS trace squared.\nols_relative_expectation_model::Function: Model for the relative OLS expectation.\nols_relative_variance_model::Function: Model for the relative OLS variance.\n\n\n\n\n\n","category":"type"},{"location":"internal/scaling/#QuantumACES.calc_ensemble_scaling-Tuple{Design, Vector{Int64}}","page":"scaling.jl","title":"QuantumACES.calc_ensemble_scaling","text":"calc_ensemble_scaling(d::Design, dist_max::Integer; kwargs...)\ncalc_ensemble_scaling(d::Design, dist_range::Vector{Int}; kwargs...)\n\nReturns ensemble scaling data as a EnsembleScaling object for the merit of the design d over random instances of noise models, for a circuit with vertical_dist and horizontal_dist parameters, as a function of these distances.\n\nArguments\n\nd::Design: Design for which the merit scaling is calculated.\ndist_max::Int: Maximum code distance for which the merit scaling is calculated.\ndist_range::Vector{Int}: Code distances for which the merit scaling is calculated.\n\nKeyword arguments\n\nprecision::Real = 2e-3: Precision to which the figure of merit is estimated, corresponding to the target standard error of the mean.\nmax_repetitions::Integer = 10000: Maximum number of random instances of log-normal Pauli noise over which the figure of merit is calculated.\nmin_repetitions::Integer = 50: Minimum number of random instances of log-normal Pauli noise over which the figure of merit is calculated.\nprint_repetitions::Integer = 50: Number of random instances of log-normal Pauli noise between printing diagnostics.\nseed::Union{UInt64, Nothing} = nothing: Seeds used to generate instances of log-normal Pauli noise.\ndiagnostics::Bool = true: Whether to print diagnostic information.\nsave_data::Bool = false: Whether to save the merit scaling data.\n\n\n\n\n\n","category":"method"},{"location":"internal/scaling/#QuantumACES.calc_merit_scaling-Tuple{Design, Vector{Int64}}","page":"scaling.jl","title":"QuantumACES.calc_merit_scaling","text":"calc_merit_scaling(d::Design, dist_max::Integer; kwargs...)\ncalc_merit_scaling(d::Design, dist_range::Vector{Int}; kwargs...)\n\nReturns the scaling data as a MeritScaling object for the merit of the design d, for a circuit with vertical_dist and horizontal_dist parameters, as a function of these distances.\n\nArguments\n\nd::Design: Design for which the merit scaling is calculated.\ndist_max::Int: Maximum distance for which the merit scaling is calculated.\ndist_range::Vector{Int}: Distances for which the merit scaling is calculated.\n\nKeyword arguments\n\nwarning::Bool = true: Whether to print a warning if the noise model is not depolarising.\ndiagnostics::Bool = true: Whether to print diagnostic information.\nsave_data::Bool = false: Whether to save the merit scaling data.\n\n\n\n\n\n","category":"method"},{"location":"internal/scaling/#QuantumACES.get_ensemble_fit-Tuple{EnsembleScaling}","page":"scaling.jl","title":"QuantumACES.get_ensemble_fit","text":"get_ensemble_fit(ensemble_scaling::EnsembleScaling; precision::Real = 1e-1)\n\nReturns ensemble scaling fit data as a EnsembleFit object for the ensemble scaling data ensemble_scaling, displaying a warning if data is not fit to relative precision precision.\n\n\n\n\n\n","category":"method"},{"location":"internal/scaling/#QuantumACES.get_scaling_fit-Tuple{Vector{Merit}, Vector{Int64}}","page":"scaling.jl","title":"QuantumACES.get_scaling_fit","text":"get_scaling_fit(merit_scaling::MeritScaling; precision::Real = 1e-2)\nget_scaling_fit(merits::Vector{Merit}, dist_range::Vector{Int}; precision::Real = 1e-2)\n\nReturns merit scaling fit data as a ScalingFit object for the merit scaling data merits fit against the distances dist_range, contained in the scaling data merit_scaling, displaying a warning if data is not fit to relative precision precision.\n\n\n\n\n\n","category":"method"},{"location":"internal/scaling/#Private-functions","page":"scaling.jl","title":"Private functions","text":"","category":"section"},{"location":"internal/scaling/","page":"scaling.jl","title":"scaling.jl","text":"Modules = [QuantumACES]\nPages = [\"src/scaling.jl\"]\nPublic = false","category":"page"},{"location":"internal/scaling/#QuantumACES.check_model-Tuple{Any, Any, Any}","page":"scaling.jl","title":"QuantumACES.check_model","text":"check_model(dist_range, model_range, model; precision::Real = 1e-2)\n\nDisplays a warning if the model predictions do not match the data to relative precision precision.\n\n\n\n\n\n","category":"method"},{"location":"internal/scaling/#QuantumACES.expectation_model-Tuple{Any, Any, Any}","page":"scaling.jl","title":"QuantumACES.expectation_model","text":"expectation_model(dist, tr_pair_params, N_params)\n\nModel of the expectation as a function of the distance dist with trace pair parameters tr_pair_params, consisting of trace and trace squared quadratic parameters, and gate eigenvalue quadratic parameters N_params.\n\n\n\n\n\n","category":"method"},{"location":"internal/scaling/#QuantumACES.fit_pair_model-Tuple{Function, Function, Vector{Int64}, Vector{Float64}, Vector{Float64}, Vector{Float64}}","page":"scaling.jl","title":"QuantumACES.fit_pair_model","text":"fit_pair_model(expectation_model::Function, variance_model::Function, dist_range::Vector{Int}, expectation_range::Vector{Float64}, variance_range::Vector{Float64}, param_init::Vector{Float64}; precision::Real = 1e-2)\n\nReturns the pair fit parameters for the expectation and variance models expectation_model and variance_model as functions of the distance dist_range, for the expectation and variance data expectation_range and variance_range, respectively, and initial parameters param_init, displaying a warning if the model predictions do not match the data to relative precision precision.\n\n\n\n\n\n","category":"method"},{"location":"internal/scaling/#QuantumACES.fit_quadratic_model-Tuple{Vector{Int64}, Vector{Float64}}","page":"scaling.jl","title":"QuantumACES.fit_quadratic_model","text":"fit_quadratic_model(dist_range::Vector{Int}, quadratic_range::Vector{Float64}; precision::Real = 1e-2)\nfit_quadratic_model(dist_range::Vector{Int}, quadratic_range::Vector{Int})\n\nReturns the quadratic fit parameters for the data quadratic_range as a function of the distance dist_range, requiring exact fit for integer data, and displaying a warning if non-integer data is not fit to relative precision precision.\n\n\n\n\n\n","category":"method"},{"location":"internal/scaling/#QuantumACES.quadratic_model-Tuple{Any, Any}","page":"scaling.jl","title":"QuantumACES.quadratic_model","text":"quadratic_model(dist, params)\n\nQuadratic model as a function of the distance dist with parameters params.\n\n\n\n\n\n","category":"method"},{"location":"internal/scaling/#QuantumACES.variance_model-Tuple{Any, Any, Any}","page":"scaling.jl","title":"QuantumACES.variance_model","text":"variance_model(dist, tr_pair_params, N_params)\n\nModel of the variance as a function of the distance dist with trace pair parameters tr_pair_params, consisting of trace and trace squared quadratic parameters, and gate eigenvalue quadratic parameters N_params.\n\n\n\n\n\n","category":"method"},{"location":"internal/stim/","page":"stim.jl","title":"stim.jl","text":"CollapsedDocStrings = true","category":"page"},{"location":"internal/stim/#stim.jl","page":"stim.jl","title":"stim.jl","text":"","category":"section"},{"location":"internal/stim/#Public-functions","page":"stim.jl","title":"Public functions","text":"","category":"section"},{"location":"internal/stim/","page":"stim.jl","title":"stim.jl","text":"Modules = [QuantumACES]\nPages = [\"src/stim.jl\"]\nPrivate = false","category":"page"},{"location":"internal/stim/#QuantumACES.MemoryData","page":"stim.jl","title":"QuantumACES.MemoryData","text":"MemoryData\n\nStim memory simulation results.\n\nFields\n\ncircuit_param::AbstractCircuitParameters: Circuit parameters.\nnoise_param::AbstractNoiseParameters: Noise parameters.\nrounds::Int: Number of memory circuit rounds.\nshots::Int: Number of sampled shots.\nseed::UInt64: Seed for Stim simulation.\nreset_type::Symbol: Reset type, which is :meas_reset by default but can be set to :meas.\ndecoder_type::Symbol: Decoder type, which is :pymatching by default but can be set to :beliefmatching.\ndecoder_gate_probabilities::Vector{Dict{Gate, Vector{Float64}}}: Vector of gate probabilities used to inform the decoder.\ndecoder_labels::Vector{String}: Labels for the gate probabilities in decoder_gate_probabilities.\nmemory_x_observable::Vector{Bool}: X memory experiment observable across each of the shots.\nmemory_z_observable::Vector{Bool}: Z memory experiment observable across each of the shots.\ndecoder_x_predictions::Matrix{Bool}: X memory experiment decoder predictions across each of the shots and decoders in decoder_gate_probabilities.\ndecoder_z_predictions::Matrix{Bool}: Z memory experiment decoder predictions across each of the shots and decoders in decoder_gate_probabilities.\n\n\n\n\n\n","category":"type"},{"location":"internal/stim/#QuantumACES.MemorySummary","page":"stim.jl","title":"QuantumACES.MemorySummary","text":"MemorySummary\n\nStim memory simulation summary results.\n\nFields\n\ncircuit_param::AbstractCircuitParameters: Circuit parameters.\nnoise_param::AbstractNoiseParameters: Noise parameters.\nrounds::Int: Number of memory circuit rounds.\nshots::Int: Number of sampled shots.\nseed::UInt64: Seed for Stim simulation.\nreset_type::Symbol: Reset type, which is :meas_reset by default but can be set to :meas.\ndecoder_type::Symbol: Decoder type, which is :pymatching by default but can be set to :beliefmatching.\ndecoder_labels::Vector{String}: Labels for the decoder gate probabilities.\nmemory_x_errors::Vector{Float64}: X memory experiment error rate.\nmemory_z_errors::Vector{Float64}: Z memory experiment error rate.\nmemory_x_errors_cov::Matrix{Float64}: X memory experiment error rate covariance.\nmemory_z_errors_cov::Matrix{Float64}: Z memory experiment error rate covariance.\nchange_x_errors::Matrix{Float64}: X memory experiment change in error rate across different gate probabilities.\nchange_z_errors::Matrix{Float64}: Z memory experiment change in error rate across different gate probabilities.\nchange_x_errors_sem::Matrix{Float64}: X memory experiment change in error rate across different gate probabilities standard error of the mean.\nchange_z_errors_sem::Matrix{Float64}: Z memory experiment change in error rate across different gate probabilities standard error of the mean.\ndecoder_x_confusion::Matrix{Int}: X memory experiment decoder confusion matrix.\ndecoder_z_confusion::Matrix{Int}: Z memory experiment decoder confusion matrix.\n\n\n\n\n\n","category":"type"},{"location":"internal/stim/#QuantumACES.calc_memory_distances-Tuple{T} where T<:AbstractCircuit","page":"stim.jl","title":"QuantumACES.calc_memory_distances","text":"calc_memory_distances(c::AbstractCircuit; reset_type::Symbol = :meas_reset, max_event_set_size::Integer = 4, max_edge_degree::Integer = 2, explore_increasing_degree::Bool = false)\n\nCalculates the logical Z and X error distances corresponding to the X and Z memory circuits corresponding to the syndrome extraction circuit c, which are conventionally the vertical and horizontal distances, respectively. Reset types are specified by reset_type and can be :meas_reset or :meas. Search parameters used by Stim are max_event_set_size, max_edge_degree, and explore_increasing_degree.\n\n\n\n\n\n","category":"method"},{"location":"internal/stim/#QuantumACES.dist_linear_model-Tuple{Any, Any}","page":"stim.jl","title":"QuantumACES.dist_linear_model","text":"dist_linear_model(dist, params)\n\nLinear model as a function of the distance dist with parameters params.\n\n\n\n\n\n","category":"method"},{"location":"internal/stim/#QuantumACES.fit_dist_error-Tuple{Vector{Int64}, Vector{Float64}, Vector{Float64}}","page":"stim.jl","title":"QuantumACES.fit_dist_error","text":"fit_dist_error(dist_set::Vector{Int}, dist_memory_errors::Vector{Float64}, dist_memory_errors_sem::Vector{Float64}; return_cov::Bool = false)\n\nReturns parameters for dist_linear_model fitted with weighted least squares from the memory errors dist_memory_errors and their standard errors of the mean dist_memory_errors_sem across the distances in dist_set. Note that the fitting is performed in log space: to fit the original parameters, exponentiate the output of dist_linear_model.\n\n\n\n\n\n","category":"method"},{"location":"internal/stim/#QuantumACES.fit_round_error-Tuple{Vector{Int64}, Vector{Float64}, Vector{Float64}}","page":"stim.jl","title":"QuantumACES.fit_round_error","text":"fit_round_error(rounds_set::Vector{Int}, rounds_memory_errors::Vector{Float64}, rounds_memory_errors_sem::Vector{Float64}; return_cov::Bool = false)\n\nReturns parameters for round_exponential_model fitted with weighted least squares from the memory errors rounds_memory_errors and their standard errors of the mean rounds_memory_errors_sem across the rounds in rounds_set.\n\n\n\n\n\n","category":"method"},{"location":"internal/stim/#QuantumACES.get_dist_error-Tuple{Vector{Float64}}","page":"stim.jl","title":"QuantumACES.get_dist_error","text":"get_dist_error(dist_params::Vector{Float64})\nget_dist_error(dist_params::Vector{Float64}, dist_params_cov::Matrix{Float64})\n\nReturns the error suppression factor, the change in error rate in a code as the distance is increased by 2, determined from dist_params, and its standard error if its covariance matrix dist_params_cov is supplied.\n\n\n\n\n\n","category":"method"},{"location":"internal/stim/#QuantumACES.get_memory_summary-Tuple{MemoryData}","page":"stim.jl","title":"QuantumACES.get_memory_summary","text":"get_memory_summary(memory_data::MemoryData)\n\nReturns memory summary data as a MemorySummary object from the memory data memory_data.\n\n\n\n\n\n","category":"method"},{"location":"internal/stim/#QuantumACES.get_round_error-Tuple{Vector{Float64}}","page":"stim.jl","title":"QuantumACES.get_round_error","text":"get_round_error(round_params::Vector{Float64})\nget_round_error(round_params::Vector{Float64}, round_params_cov::Matrix{Float64})\n\nReturns the error per round determined from round_params, and its standard error if its covariance matrix round_params_cov is supplied.\n\n\n\n\n\n","category":"method"},{"location":"internal/stim/#QuantumACES.get_stim_circuit-Tuple{Vector{Layer}, Dict{Gate, Vector{Float64}}, Bool, Bool}","page":"stim.jl","title":"QuantumACES.get_stim_circuit","text":"get_stim_circuit(circuit::Vector{Layer}, gate_probabilities::Dict{Gate, Vector{Float64}}, noisy_prep::Bool, noisy_meas::Bool; extra_fields::Dict{Symbol, Any} = Dict{Symbol, Any}(), meas_and_reset::Bool = false)\n\nReturns a Stim string representation of the circuit circuit alongside error probabilities specified by gate_probabilities, as well as noisy preparations if noisy_prep is true and noisy measurements if noisy_meas is true. Qubit coordinates are specified by extra_fields if it contains a CodeParameters object. Reset types are specified by reset_type and can be :reset, :meas, or :meas_reset.\n\nStim orders one-qubit Paulis as: X, Y, Z. We order one-qubit Paulis as: X, Z, Y. The indexing to transform between these orderings is: 1, 3, 2.\n\nStim orders two-qubit Paulis as: IX, IY, IZ, XI, XX, XY, XZ, YI, YX, YY, YZ, ZI, ZX, ZY, ZZ. We order two-qubit Paulis as: XI, IX, XX, ZI, YI, ZX, YX, IZ, XZ, IY, XY, ZZ, YZ, ZY, YY. The indexing to transform from the Stim ordering to ours is: 4, 1, 5, 12, 8, 13, 9, 3, 7, 2, 6, 15, 11, 14, 10. The indexing to transform from our ordering to the Stim ordering is: 2, 10, 8, 1, 3, 11, 9, 5, 7, 15, 13, 4, 6, 14, 12.\n\n\n\n\n\n","category":"method"},{"location":"internal/stim/#QuantumACES.get_stim_memory_circuit-Union{Tuple{T}, Tuple{T, Dict{Gate, Vector{Float64}}, Symbol, Integer}} where T<:AbstractCircuit","page":"stim.jl","title":"QuantumACES.get_stim_memory_circuit","text":"get_stim_memory_circuit(c::AbstractCircuit, gate_probabilities::Dict{Gate, Vector{Float64}}, memory_type::Symbol, rounds::Integer; reset_type::Symbol = :meas_reset)\nget_stim_memory_circuit(c::AbstractCircuit, memory_type::Symbol, rounds::Integer; reset_type::Symbol = :meas_reset)\n\nReturns a Stim string representation of the memory circuit corresponding to the syndrome extraction circuit c, optionally using the gate error probabilities gate_probabilities, memory type memory_type, which can be either :x or :z, number of rounds rounds, and reset type reset_type, which can be either :meas_reset or :meas.\n\nIf you want to add support for custom syndrome extraction circuits c which do not store their code parameters in the CodeParameters object, you will need to define new methods for get_stim_qubits, get_stim_initialise, get_stim_detectors, and get_stim_measure_detectors to make this function work.\n\n\n\n\n\n","category":"method"},{"location":"internal/stim/#QuantumACES.round_exponential_model-Tuple{Any, Any}","page":"stim.jl","title":"QuantumACES.round_exponential_model","text":"round_exponential_model(rounds, params)\n\nExponential decay model as a function of the number of rounds rounds with parameters params.\n\n\n\n\n\n","category":"method"},{"location":"internal/stim/#QuantumACES.simulate_memory-Union{Tuple{T}, Tuple{T, Integer, Integer}} where T<:AbstractCircuit","page":"stim.jl","title":"QuantumACES.simulate_memory","text":"simulate_memory(c::AbstractCircuit, rounds::Integer, shots::Integer; kwargs...)\n\nReturns the memory and decoding simulation results for a memory experiment conducted with the given syndrome extraction circuit.\n\nWARNING: Seeding has the same features as in Stim. The behaviour of the same random seed will differ across different versions of Stim. Also, when measurement shots are sampled in batches, which occurs when max_samples is exceeded, the results will differ from when all shots are sampled at once.\n\nArguments\n\nc::AbstractCircuit: Syndrome extraction circuit.\nrounds::Integer: Number of memory circuit rounds, which must be at least 0.\nshots::Integer: Number of shots, which must be at least 1.\n\nKeyword arguments\n\nseed::Union{UInt64, Nothing} = nothing: Seed to use for random number generation.\nreset_type::Symbol = :meas_reset: Reset type, which can be either :meas_reset or :meas.\ndecoder_type::Symbol = :pymatching: Decoder type, which can be either :pymatching or :beliefmatching.\ndecoder_gate_probabilities::Vector{Dict{Gate, Vector{Float64}}} = [c.gate_probabilities]: Gate probabilities used for decoding, the first of which must be the gate probabilities of the supplied circuit c.\ndecoder_labels::Vector{String} = [string(idx) for idx in 1:length(decoder_gate_probabilities)]: Labels for the decoder gate probabilities.\nmax_samples::Integer = 10^9: Maximum number of Stim detector samples collected in a single simulation.\ndiagnostics::Bool = false: Whether to print diagnostics.\n\n\n\n\n\n","category":"method"},{"location":"internal/stim/#Private-functions","page":"stim.jl","title":"Private functions","text":"","category":"section"},{"location":"internal/stim/","page":"stim.jl","title":"stim.jl","text":"Modules = [QuantumACES]\nPages = [\"src/stim.jl\"]\nPublic = false","category":"page"},{"location":"internal/stim/#QuantumACES.batch_simulate_memory-Union{Tuple{T}, Tuple{T, Symbol, Integer, Integer}} where T<:AbstractCircuit","page":"stim.jl","title":"QuantumACES.batch_simulate_memory","text":"batch_simulate_memory(c::AbstractCircuit, memory_type::Symbol, rounds::Integer, shots::Integer; kwargs...)\n\nReturns the memory and decoding simulation results for a memory experiment conducted with the given syndrome extraction circuit.\n\nWARNING: Seeding has the same features as in Stim. The behaviour of the same random seed will differ across different versions of Stim. Also, when measurement shots are sampled in batches, which occurs when max_samples is exceeded, the results will differ from when all shots are sampled at once.\n\nArguments\n\nc::AbstractCircuit: Syndrome extraction circuit.\nmemory_type::Symbol: Memory type, which can be either :x or :z.\nrounds::Integer: Number of memory circuit rounds, which must be at least 0.\nshots::Integer: Number of shots, which must be at least 1.\n\nKeyword arguments\n\nseed::Union{UInt64, Nothing} = nothing: Seed to use for random number generation.\nreset_type::Symbol = :meas_reset: Reset type, which can be either :meas_reset or :meas.\ndecoder_type::Symbol = :pymatching: Decoder type, which can be either :pymatching or :beliefmatching.\ndecoder_gate_probabilities::Vector{Dict{Gate, Vector{Float64}}} = [c.gate_probabilities]: Gate probabilities used for decoding, the first of which must be the gate probabilities of the supplied circuit c.\nmax_samples::Integer = 10^9: Maximum number of Stim detector samples collected in a single simulation.\ndiagnostics::Bool = false: Whether to print diagnostics.\n\n\n\n\n\n","category":"method"},{"location":"internal/stim/#QuantumACES.get_stim_detectors-Tuple{CodeParameters, Symbol}","page":"stim.jl","title":"QuantumACES.get_stim_detectors","text":"get_stim_detectors(code_param::CodeParameters, memory_type::Symbol; previous_compare::Integer = 0, include_data::Bool = false)\nget_stim_detectors(code_param::CodeParameters, previous_compare::Integer)\n\nReturns a Stim string representation of the detectors for the code parameters code_param corresponding to the Pauli type specified by memory_type, which can be either :x or :z, comparing the detectors against those from previous_compare rounds ago. If include_data is true, the detector checks the relevant data qubits and is included only if it checks a nonzero number of data qubits.\n\nIf no memory type is specified, this generates detectors for both X and Z memory types but requires previous_compare to be specified.\n\n\n\n\n\n","category":"method"},{"location":"internal/stim/#QuantumACES.get_stim_initialise-Tuple{CodeParameters, Symbol, Dict{Gate, Vector{Float64}}, Bool}","page":"stim.jl","title":"QuantumACES.get_stim_initialise","text":"get_stim_initialise(code_param::CodeParameters, memory_type::Symbol, gate_probabilities::Dict{Gate, Vector{Float64}}, noisy_prep::Bool)\n\nReturns a Stim string representation of the initialisation for the code parameters code_param corresponding to the Pauli type specified by memory_type, which can be either :x or :z, using the gate error probabilities gate_probabilities if noisy_prep is true.\n\n\n\n\n\n","category":"method"},{"location":"internal/stim/#QuantumACES.get_stim_measure_detectors-Tuple{CodeParameters, Symbol, Dict{Gate, Vector{Float64}}, Bool}","page":"stim.jl","title":"QuantumACES.get_stim_measure_detectors","text":"get_stim_measure_detectors(code_param::CodeParameters, gate_probabilities::Dict{Gate, Vector{Float64}}, noisy_meas::Bool; reset_type::Symbol = :meas_reset, do_rounds::Bool = true)\n\nReturns a Stim string representation of the measurement and detectors for the code parameters code_param corresponding to the Pauli type specified by memory_type, which can be either :x or :z, using the gate error probabilities gate_probabilities if noisy_meas is true, for the reset type reset_type, which can be either :meas_reset or :meas. Set do_rounds to false when no rounds of the memory circuit are performed and reset_type is :meas to avoid breaking the measurement detectors.\n\n\n\n\n\n","category":"method"},{"location":"internal/stim/#QuantumACES.get_stim_qubits-Tuple{Vector{Tuple{Int64, Int64}}}","page":"stim.jl","title":"QuantumACES.get_stim_qubits","text":"get_stim_qubits(qubits::Vector{Tuple{Int, Int}})\nget_stim_qubits(code_param::CodeParameters)\nget_stim_qubits(empty_code_param::EmptyCodeParameters)\n\nReturns a Stim string representation of the qubit coordinates described by qubits, which may be a field of code_param.\n\n\n\n\n\n","category":"method"},{"location":"internal/stim/#QuantumACES.process_memory_data-Tuple{Vector{Bool}, Matrix{Bool}}","page":"stim.jl","title":"QuantumACES.process_memory_data","text":"process_memory_data(memory_observable::Vector{Bool}, decoder_predictions::Matrix{Bool})\n\nReturns summary data for the memory observables memory_observable and decoder predictions decoder_predictions.\n\n\n\n\n\n","category":"method"},{"location":"internal/noises/depolarising/","page":"noises/depolarising.jl","title":"noises/depolarising.jl","text":"CollapsedDocStrings = true","category":"page"},{"location":"internal/noises/depolarising/#depolarising.jl","page":"noises/depolarising.jl","title":"depolarising.jl","text":"","category":"section"},{"location":"internal/noises/depolarising/#Public-functions","page":"noises/depolarising.jl","title":"Public functions","text":"","category":"section"},{"location":"internal/noises/depolarising/","page":"noises/depolarising.jl","title":"noises/depolarising.jl","text":"Modules = [QuantumACES]\nPages = [\"src/noises/depolarising.jl\"]\nPrivate = false","category":"page"},{"location":"internal/noises/depolarising/#QuantumACES.DepolarisingParameters","page":"noises/depolarising.jl","title":"QuantumACES.DepolarisingParameters","text":"DepolarisingParameters\n\nParameterises a depolarising Pauli noise model.\n\nFields\n\nparams::Dict{Symbol, Any}: Dictionary of the noise parameters described below.\nnoise_name::String: Noise parameter name for saving data.\n\nParameters\n\nr_1::Real: Single-qubit gate entanglement infidelity, the sum of all 3 non-identity Pauli error probabilities.\nr_2::Real: Two-qubit gate entanglement infidelity, the sum of all 15 non-identity Pauli error probabilities.\nr_m::Real: Measurement error probability.\nr_im::Real: Mid-circuit measurement idle entanglement infidelity.\nr_r::Real: Mid-circuit reset error probability.\ncombined::Bool: Whether to treat Pauli X, Y, and Z basis SPAM noise as the same.\n\n\n\n\n\n","category":"type"},{"location":"internal/noises/depolarising/#QuantumACES.get_dep_param-Tuple{}","page":"noises/depolarising.jl","title":"QuantumACES.get_dep_param","text":"get_dep_param(r_1::Real, r_2::Real, r_m::Real)\nget_dep_param(; r_1::Real, r_2::Real, r_m::Real, r_im::Real = r_m, r_r::Real = r_m)\n\nReturn a DepolarisingParameters object that parameterises a depolarising Pauli noise model.\n\nArguments\n\nr_1::Real: Single-qubit gate entanglement infidelity, the sum of all 3 non-identity Pauli error probabilities.\nr_2::Real: Two-qubit gate entanglement infidelity, the sum of all 15 non-identity Pauli error probabilities.\nr_m::Real: Measurement error probability.\nr_im::Real: Mid-circuit measurement idle entanglement infidelity.\nr_r::Real: Mid-circuit reset error probability.\ncombined::Bool: Whether to treat Pauli X, Y, and Z basis SPAM noise as the same.\n\n\n\n\n\n","category":"method"},{"location":"internal/noises/depolarising/#QuantumACES.init_gate_probabilities-Tuple{Vector{Gate}, DepolarisingParameters}","page":"noises/depolarising.jl","title":"QuantumACES.init_gate_probabilities","text":"init_gate_probabilities(total_gates::Vector{Gate}, dep_param::DepolarisingParameters)\n\nReturns a dictionary of the Pauli error probabilities for each gate in total_gates generated according to the noise parameters dep_param, ordered lexicographically following get_paulis.\n\n\n\n\n\n","category":"method"},{"location":"internal/noises/depolarising/#Private-functions","page":"noises/depolarising.jl","title":"Private functions","text":"","category":"section"},{"location":"internal/noises/depolarising/","page":"noises/depolarising.jl","title":"noises/depolarising.jl","text":"Modules = [QuantumACES]\nPages = [\"src/noises/depolarising.jl\"]\nPublic = false","category":"page"},{"location":"internal/io/","page":"io.jl","title":"io.jl","text":"CollapsedDocStrings = true","category":"page"},{"location":"internal/io/#io.jl","page":"io.jl","title":"io.jl","text":"","category":"section"},{"location":"internal/io/#Public-functions","page":"io.jl","title":"Public functions","text":"","category":"section"},{"location":"internal/io/","page":"io.jl","title":"io.jl","text":"Modules = [QuantumACES]\nPages = [\"src/io.jl\"]\nPrivate = false","category":"page"},{"location":"internal/io/#QuantumACES.aces_data_filename-Union{Tuple{U}, Tuple{T}, Tuple{T, U, Integer, Vector{Int64}, Bool, Symbol, Vector{Int64}, UInt64}} where {T<:AbstractCircuitParameters, U<:AbstractNoiseParameters}","page":"io.jl","title":"QuantumACES.aces_data_filename","text":"aces_data_filename(aces_data::ACESData)\naces_data_filename(d::Design, budget_set::Vector{Int})\naces_data_filename(circuit_param::AbstractCircuitParameters, noise_param::AbstractNoiseParameters, tuple_number::Integer, repeat_numbers::Vector{Int}, full_covariance::Bool, ls_type::Symbol, budget_set::Vector{Int})\n\nReturns a string describing the filename corresponding to the ACES data.\n\n\n\n\n\n","category":"method"},{"location":"internal/io/#QuantumACES.delete_aces-Tuple{ACESData}","page":"io.jl","title":"QuantumACES.delete_aces","text":"delete_aces(aces_data::ACESData)\n\nDeletes the file corresponding to the ACES data aces_data.\n\n\n\n\n\n","category":"method"},{"location":"internal/io/#QuantumACES.delete_design-Tuple{Design}","page":"io.jl","title":"QuantumACES.delete_design","text":"delete_design(d::Design)\n\nDeletes the file corresponding to the design d.\n\n\n\n\n\n","category":"method"},{"location":"internal/io/#QuantumACES.delete_qiskit_ensemble-Tuple{RandDesign}","page":"io.jl","title":"QuantumACES.delete_qiskit_ensemble","text":"delete_qiskit_ensemble(d_rand::RandDesign)\n\nDeletes the Qiskit ensemble whose filename is specified by the supplied randomised experimental design.\n\n\n\n\n\n","category":"method"},{"location":"internal/io/#QuantumACES.delete_rand_design-Tuple{RandDesign}","page":"io.jl","title":"QuantumACES.delete_rand_design","text":"delete_rand_design(d_rand::RandDesign)\n\nDeletes the file corresponding to the randomised experimental design d_rand.\n\n\n\n\n\n","category":"method"},{"location":"internal/io/#QuantumACES.delete_rand_design_job-Tuple{RandDesign, String, Integer}","page":"io.jl","title":"QuantumACES.delete_rand_design_job","text":"delete_rand_design_job(d_rand::RandDesign, backend::String, job_idx::Integer)\n\nDeletes the job counts data for the randomised experimental design d_rand whose filename is specified by the supplied variables.\n\n\n\n\n\n","category":"method"},{"location":"internal/io/#QuantumACES.delete_scaling-Tuple{T} where T<:AbstractScalingData","page":"io.jl","title":"QuantumACES.delete_scaling","text":"delete_scaling(scaling_data::AbstractScalingData)\n\nDeletes the file corresponding to the scaling data scaling_data.\n\n\n\n\n\n","category":"method"},{"location":"internal/io/#QuantumACES.design_filename-Union{Tuple{U}, Tuple{T}, Tuple{T, U, Integer, Vector{Int64}, Bool, Symbol}} where {T<:AbstractCircuitParameters, U<:AbstractNoiseParameters}","page":"io.jl","title":"QuantumACES.design_filename","text":"design_filename(d::Design)\ndesign_filename(circuit_param::AbstractCircuitParameters, noise_param::AbstractNoiseParameters, tuple_number::Integer, repeat_numbers::Vector{Int}, full_covariance::Bool, ls_type::Symbol)\n\nReturns a string describing the filename corresponding to the supplied design data.\n\n\n\n\n\n","category":"method"},{"location":"internal/io/#QuantumACES.enter_folder-Tuple{String}","page":"io.jl","title":"QuantumACES.enter_folder","text":"enter_folder(folder::String)\n\nIf not currently in the folder folder, enter it.\n\n\n\n\n\n","category":"method"},{"location":"internal/io/#QuantumACES.exit_folder-Tuple{String}","page":"io.jl","title":"QuantumACES.exit_folder","text":"exit_folder(folder::String)\n\nIf currently in the folder folder, exit it.\n\n\n\n\n\n","category":"method"},{"location":"internal/io/#QuantumACES.load_aces-Union{Tuple{U}, Tuple{T}, Tuple{T, U, Integer, Vector{Int64}, Bool, Symbol, Vector{Int64}, UInt64}} where {T<:AbstractCircuitParameters, U<:AbstractNoiseParameters}","page":"io.jl","title":"QuantumACES.load_aces","text":"load_aces(d::Design, budget_set::Vector{Int})\nload_aces(circuit_param::AbstractCircuitParameters, noise_param::AbstractNoiseParameters, tuple_number::Integer, repeat_numbers::Vector{Int}, full_covariance::Bool, ls_type::Symbol, budget_set::Vector{Int})\n\nLoads the ACES data whose filename is specified by the supplied variables.\n\n\n\n\n\n","category":"method"},{"location":"internal/io/#QuantumACES.load_design-Union{Tuple{U}, Tuple{T}, Tuple{T, U, Integer, Vector{Int64}, Bool, Symbol}} where {T<:AbstractCircuitParameters, U<:AbstractNoiseParameters}","page":"io.jl","title":"QuantumACES.load_design","text":"load_design(circuit_param::AbstractCircuitParameters, noise_param::AbstractNoiseParameters, tuple_number::Integer, repeat_numbers::Vector{Int}, full_covariance::Bool, ls_type::Symbol)\n\nLoads the design whose filename is specified by the supplied variables.\n\n\n\n\n\n","category":"method"},{"location":"internal/io/#QuantumACES.load_qiskit_ensemble-Tuple{RandDesign}","page":"io.jl","title":"QuantumACES.load_qiskit_ensemble","text":"load_qiskit_ensemble(d_rand::RandDesign)\n\nLoads the Qiskit ensemble whose filename is specified by the supplied randomised experimental design.\n\n\n\n\n\n","category":"method"},{"location":"internal/io/#QuantumACES.load_rand_design-Union{Tuple{U}, Tuple{T}, Tuple{T, U, Integer, Vector{Int64}, Bool, Symbol, Integer, UInt64}} where {T<:AbstractCircuitParameters, U<:AbstractNoiseParameters}","page":"io.jl","title":"QuantumACES.load_rand_design","text":"load_rand_design(d::Design, total_randomisations::Integer, seed::UInt64)\nload_rand_design(circuit_param::AbstractCircuitParameters, noise_param::AbstractNoiseParameters, tuple_number::Integer, repeat_numbers::Vector{Int}, full_covariance::Bool, ls_type::Symbol, total_randomisations::Integer, seed::UInt64)\n\nLoads the randomised experimental design whose filename is specified by the supplied variables.\n\n\n\n\n\n","category":"method"},{"location":"internal/io/#QuantumACES.load_rand_design_job-Tuple{RandDesign, String, Integer}","page":"io.jl","title":"QuantumACES.load_rand_design_job","text":"load_rand_design_job(d_rand::RandDesign, backend::String, job_idx::Integer)\n\nLoads the job counts data for the randomised experimental design d_rand whose filename is specified by the supplied variables.\n\n\n\n\n\n","category":"method"},{"location":"internal/io/#QuantumACES.load_scaling-Union{Tuple{U}, Tuple{T}, Tuple{T, U, Integer, Vector{Int64}, Symbol}} where {T<:AbstractCircuitParameters, U<:AbstractNoiseParameters}","page":"io.jl","title":"QuantumACES.load_scaling","text":"load_scaling(d::Design, ls_type::Symbol)\nload_scaling(circuit_param::AbstractCircuitParameters, noise_param::AbstractNoiseParameters, tuple_number::Integer, repeat_numbers::Vector{Int}, ls_type::Symbol)\n\nLoads the scaling data whose filename is specified by the supplied variables.\n\n\n\n\n\n","category":"method"},{"location":"internal/io/#QuantumACES.rand_design_filename-Union{Tuple{U}, Tuple{T}, Tuple{T, U, Integer, Vector{Int64}, Bool, Symbol, Integer, UInt64}} where {T<:AbstractCircuitParameters, U<:AbstractNoiseParameters}","page":"io.jl","title":"QuantumACES.rand_design_filename","text":"rand_design_filename(d_rand::RandDesign)\nrand_design_filename(d::Design, total_randomisations::Integer, seed::UInt64)\nrand_design_filename(circuit_param::AbstractCircuitParameters, noise_param::AbstractNoiseParameters, tuple_number::Integer, repeat_numbers::Vector{Int}, full_covariance::Bool, ls_type::Symbol, total_randomisations::Integer, seed::UInt64)\n\nReturns a string describing the filename corresponding to the randomised design data.\n\n\n\n\n\n","category":"method"},{"location":"internal/io/#QuantumACES.save_aces-Tuple{ACESData}","page":"io.jl","title":"QuantumACES.save_aces","text":"save_aces(aces_data::ACESData; clear_design::Bool = false)\n\nSaves the ACES data aces_data with the appropriate filename, and deletes the design file if it exists and clear_design is true.\n\n\n\n\n\n","category":"method"},{"location":"internal/io/#QuantumACES.save_design-Tuple{Design}","page":"io.jl","title":"QuantumACES.save_design","text":"save_design(d::Design)\n\nSaves the design d with the appropriate filename.\n\n\n\n\n\n","category":"method"},{"location":"internal/io/#QuantumACES.save_qiskit_ensemble-Tuple{RandDesign, PythonCall.Core.Py}","page":"io.jl","title":"QuantumACES.save_qiskit_ensemble","text":"save_qiskit_ensemble(d_rand::RandDesign, qiskit_ensemble::Py)\n\nSaves the Qiskit ensemble qiskit_ensemble with the appropriate filename.\n\n\n\n\n\n","category":"method"},{"location":"internal/io/#QuantumACES.save_rand_design-Tuple{RandDesign}","page":"io.jl","title":"QuantumACES.save_rand_design","text":"save_rand_design(d_rand::RandDesign)\n\nSaves the randomised experimental design d_rand with the appropriate filename.\n\n\n\n\n\n","category":"method"},{"location":"internal/io/#QuantumACES.save_rand_design_job-Tuple{RandDesign, String, Union{Vector{Dict{String, Int64}}, Vector{Matrix{UInt8}}}, Integer}","page":"io.jl","title":"QuantumACES.save_rand_design_job","text":"save_rand_design_job(d_rand::RandDesign, backend::String, job_counts::Union{Vector{Matrix{UInt8}}, Vector{Dict{String, Int}}}, job_idx::Integer)\n\nSaves the job counts data job_counts with index job_idx for the randomised experimental design d_rand with the filename determined by the supplied backend.\n\n\n\n\n\n","category":"method"},{"location":"internal/io/#QuantumACES.save_scaling-Tuple{T} where T<:AbstractScalingData","page":"io.jl","title":"QuantumACES.save_scaling","text":"save_scaling(scaling_data::AbstractScalingData)\n\nSaves the scaling data scaling_data with the appropriate filename.\n\n\n\n\n\n","category":"method"},{"location":"internal/io/#QuantumACES.scaling_filename-Union{Tuple{U}, Tuple{T}, Tuple{T, U, Integer, Vector{Int64}, Symbol}} where {T<:AbstractCircuitParameters, U<:AbstractNoiseParameters}","page":"io.jl","title":"QuantumACES.scaling_filename","text":"scaling_filename(scaling_data::AbstractScalingData)\nscaling_filename(d::Design, ls_type::Symbol)\nscaling_filename(circuit_param::AbstractCircuitParameters, noise_param::AbstractNoiseParameters, tuple_number::Integer, repeat_numbers::Vector{Int}, ls_type::Symbol)\n\nReturns a string describing the filename for the scaling data corresponding to the supplied design data.\n\n\n\n\n\n","category":"method"},{"location":"internal/io/#Private-functions","page":"io.jl","title":"Private functions","text":"","category":"section"},{"location":"internal/io/","page":"io.jl","title":"io.jl","text":"Modules = [QuantumACES]\nPages = [\"src/io.jl\"]\nPublic = false","category":"page"},{"location":"internal/io/#QuantumACES.tuples_filename-Tuple{Integer, Vector{Int64}}","page":"io.jl","title":"QuantumACES.tuples_filename","text":"tuples_filename(tuple_number::Integer, repeat_numbers::Vector{Int})\n\nReturns a string describing the filename for the supplied tuple set data.\n\n\n\n\n\n","category":"method"},{"location":"guide/#Package-Guide","page":"Package Guide","title":"Package Guide","text":"","category":"section"},{"location":"guide/","page":"Package Guide","title":"Package Guide","text":"QuantumACES is a package for designing and simulating scalable and performant Pauli noise characterisation experiments for stabiliser circuits with averaged circuit eigenvalue sampling (ACES). It focuses on the context of quantum error correction and fault-tolerant circuits and, in particular, on the syndrome extraction circuits of topological quantum error correcting codes. It interfaces with Stim for stabiliser circuit simulation, PyMatching and BeliefMatching for decoding, and Qiskit for implementation on quantum devices.","category":"page"},{"location":"guide/","page":"Package Guide","title":"Package Guide","text":"Typical usage of QuantumACES involves first doing the following:","category":"page"},{"location":"guide/","page":"Package Guide","title":"Package Guide","text":"Construct the circuit and the noise model that you aim to characterise, either using existing functions or your own.\nOptimise an ACES experimental design for noise characterisation of a small-scale instance of the circuit, typically according to a deterministic noise model, such as depolarising noise, with roughly the same average error rates as the noise you aim to characterise.","category":"page"},{"location":"guide/","page":"Package Guide","title":"Package Guide","text":"This subsequently enables:","category":"page"},{"location":"guide/","page":"Package Guide","title":"Package Guide","text":"Transferring the optimised experimental design to larger-scale instances of the circuit, including with different noise models.\nSimulate noise characterisation experiments with ACES experimental designs, including at large scales, using Stim.\nCalculating performance predictions for experimental designs at small scales and fitting the performance predictions, in particular for syndrome extraction circuits as a function of the distance of the underlying code, to predict performance at large scales.\nSimulating memory experiments for syndrome extraction circuits using Stim, and then decoding with PyMatching or BeliefMatching with decoder priors informed by a range of noise models, including ACES noise estimates.\nCreating Pauli frame randomised ACES experimental designs, exporting them to Qiskit circuits, and processing the results, enabling implementation on quantum devices.","category":"page"},{"location":"guide/","page":"Package Guide","title":"Package Guide","text":"The methods used in this package are based on arXiv:2404.06545 and arXiv:2502.21044, and they build on the original ACES protocol introduced in arXiv:2108.05803.","category":"page"},{"location":"guide/","page":"Package Guide","title":"Package Guide","text":"The code for arXiv:2404.06545 can be found in the scalable_aces folder on the scalable_aces branch.","category":"page"},{"location":"guide/","page":"Package Guide","title":"Package Guide","text":"The code for arXiv:2502.21044 can be found in the aces_decoding folder on the aces_decoding branch.","category":"page"},{"location":"guide/","page":"Package Guide","title":"Package Guide","text":"If you find this package helpful for your research, please cite it using the supplied CITATION.cff file, and consider citing the associated papers if appropriate. If you wish to contribute to this package, please refer to the CONTRIBUTING.md file.","category":"page"},{"location":"guide/#Installation-and-setup","page":"Package Guide","title":"Installation and setup","text":"","category":"section"},{"location":"guide/","page":"Package Guide","title":"Package Guide","text":"To install this package, run the following command in the Julia REPL.","category":"page"},{"location":"guide/","page":"Package Guide","title":"Package Guide","text":"] add QuantumACES","category":"page"},{"location":"guide/","page":"Package Guide","title":"Package Guide","text":"BEWARE: This package uses PythonCall to call a number of Python packages. If PythonCall and these packages are not configured correctly, associated functions will not work. The packages attempts to load the following Python packages:","category":"page"},{"location":"guide/","page":"Package Guide","title":"Package Guide","text":"Stim, installed with pip install stim.\nPyMatching, installed with pip install pymatching.\nBeliefMatching, installed with pip install beliefmatching.\nQiskit, installed with pip install qiskit.\nAer, installed with pip install qiskit-aer.","category":"page"},{"location":"guide/","page":"Package Guide","title":"Package Guide","text":"By default, PythonCall creates its own Python environment, but you may wish to use an existing Python installation.","category":"page"},{"location":"guide/","page":"Package Guide","title":"Package Guide","text":"One helpful method for managing Python versions is pyenv, or for Windows, pyenv-win; these are analogous to Juliaup for Julia. The following assumes you are using pyenv or pyenv-win.","category":"page"},{"location":"guide/","page":"Package Guide","title":"Package Guide","text":"On Windows, to instruct PythonCall to use the Python version set by pyenv, configure PythonCall's environment variables by adding the following to your ~/.julia/config/startup.jl file","category":"page"},{"location":"guide/","page":"Package Guide","title":"Package Guide","text":"ENV[\"JULIA_CONDAPKG_BACKEND\"] = \"Null\"\npython_exe = readchomp(`cmd /C pyenv which python`)\nENV[\"JULIA_PYTHONCALL_EXE\"] = python_exe","category":"page"},{"location":"guide/","page":"Package Guide","title":"Package Guide","text":"On Unix systems, shell commands are parsed directly by Julia and appear to be unaware of your PATH variable, and I am not sure how to work around this. Therefore, you may need to manually supply python_exe for the Python version <version> as","category":"page"},{"location":"guide/","page":"Package Guide","title":"Package Guide","text":"python_exe = homedir() * \"/.pyenv/versions/<version>/bin/python\"","category":"page"},{"location":"guide/#Example-usage","page":"Package Guide","title":"Example usage","text":"","category":"section"},{"location":"guide/","page":"Package Guide","title":"Package Guide","text":"Beware that the examples shown below can take a long time to run. Ensure that Julia is set up to use as many threads as your CPU can handle. For example usage that is faster to run, see Creating Circuits and Noise Models.","category":"page"},{"location":"guide/","page":"Package Guide","title":"Package Guide","text":"First parameterise a depolarising noise model with single-qubit gate infidelity r_1, two-qubit gate infidelity r_2, and measurement infidelity r_m, and a log-normal random Pauli noise model with the same gate infidelities and a standard deviation of the underlying normal distributions total_std_log, specifying the seed seed for reproducibility.","category":"page"},{"location":"guide/","page":"Package Guide","title":"Package Guide","text":"using QuantumACES\nr_1 = 0.05 / 100\nr_2 = 0.4 / 100\nr_m = 0.8 / 100\ntotal_std_log = 0.5\nseed = UInt(0)\ndep_param = get_dep_param(r_1, r_2, r_m)\nlog_param = get_log_param(r_1, r_2, r_m, total_std_log; seed = seed)","category":"page"},{"location":"guide/","page":"Package Guide","title":"Package Guide","text":"Similarly, we create circuit parameters for the syndrome extraction circuit of a distance dist (rotated) surface code.","category":"page"},{"location":"guide/","page":"Package Guide","title":"Package Guide","text":"dist = 3\nrotated_param = get_rotated_param(dist)","category":"page"},{"location":"guide/","page":"Package Guide","title":"Package Guide","text":"Next, we create versions of this circuit with both noise models.","category":"page"},{"location":"guide/","page":"Package Guide","title":"Package Guide","text":"circuit_dep = get_circuit(rotated_param, dep_param)\ncircuit_log = get_circuit(rotated_param, log_param)","category":"page"},{"location":"guide/","page":"Package Guide","title":"Package Guide","text":"Now we can generate an experimental design for this circuit.","category":"page"},{"location":"guide/","page":"Package Guide","title":"Package Guide","text":"d = generate_design(circuit_dep)","category":"page"},{"location":"guide/","page":"Package Guide","title":"Package Guide","text":"Alternatively, we can optimise an experimental design to improve its sample efficiency, configuring the optimisation with the parameters associated with OptimOptions.","category":"page"},{"location":"guide/","page":"Package Guide","title":"Package Guide","text":"d = optimise_design(circuit_dep; options = OptimOptions(; seed = seed))","category":"page"},{"location":"guide/","page":"Package Guide","title":"Package Guide","text":"There are a number of options that allow you to reduce the optimisation time. For example, we can disable cyclic coordinate descent optimisation of the circuit depth of repeated tuples in the design by setting max_cycles = 0. We can also allow the greedy search over ordinary tuples to terminate once they are left unchanged by single excursion in the search by setting excursions_unchanged = 1.","category":"page"},{"location":"guide/","page":"Package Guide","title":"Package Guide","text":"d = optimise_design(\n    circuit_dep;\n    options = OptimOptions(; max_cycles = 0, excursions_unchanged = 1, seed = seed),\n)","category":"page"},{"location":"guide/","page":"Package Guide","title":"Package Guide","text":"This experimental design can be transferred to the circuit with the log-normal Pauli noise model.","category":"page"},{"location":"guide/","page":"Package Guide","title":"Package Guide","text":"d_log = generate_design(circuit_log, d)","category":"page"},{"location":"guide/","page":"Package Guide","title":"Package Guide","text":"If we only wish to update the noise model, however, we can do this more efficiently.","category":"page"},{"location":"guide/","page":"Package Guide","title":"Package Guide","text":"d_log = update_noise(d, circuit_log)","category":"page"},{"location":"guide/","page":"Package Guide","title":"Package Guide","text":"Now we can simulate repetitions instances of ACES noise characterisation across a range of measurement budgets budget_set, which are measurement shots normalised by the time taken to perform the experiment.","category":"page"},{"location":"guide/","page":"Package Guide","title":"Package Guide","text":"budget_set = [10^6; 10^7; 10^8]\nrepetitions = 20\naces_data = simulate_aces(d_log, budget_set; repetitions = repetitions, seed = seed)","category":"page"},{"location":"guide/","page":"Package Guide","title":"Package Guide","text":"We can compare the performance to predictions, although we note that the z-scores will not quite be normally distributed as the underlying distribution is not quite normal.","category":"page"},{"location":"guide/","page":"Package Guide","title":"Package Guide","text":"merit_log = calc_merit(d_log)\npretty_print(aces_data, merit_log)","category":"page"},{"location":"guide/","page":"Package Guide","title":"Package Guide","text":"We can also simulate ACES noise characterisation at scale. First create a new design at a large code distance dist_big. Setting full_covariance to be false means only the diagonal circuit eigenvalue estimator covariance matrix is generated, which saves a substantial amount of time. It also prevents the design from attempting to perform generalised least squares (GLS) with the full covariance matrix, which can consume large amounts of memory at large scales, restricting the design to weighted least squares (WLS).","category":"page"},{"location":"guide/","page":"Package Guide","title":"Package Guide","text":"dist_big = 13\nrotated_param_big = get_rotated_param(dist_big)\ncircuit_big = get_circuit(rotated_param_big, dep_param)\ncircuit_big_log = get_circuit(rotated_param_big, log_param)\nd_big = generate_design(circuit_big_log, d; full_covariance = false, diagnostics = true)","category":"page"},{"location":"guide/","page":"Package Guide","title":"Package Guide","text":"Now simulate this new design, setting split to be true to avoid memory issues by splitting projection of the gate error probabilities into the simplex across each of the gates, rather than doing all gates collectively.","category":"page"},{"location":"guide/","page":"Package Guide","title":"Package Guide","text":"aces_data_big = simulate_aces(d_big, budget_set; seed = seed, split = true)","category":"page"},{"location":"guide/","page":"Package Guide","title":"Package Guide","text":"It is expensive to directly calculate the performance of the experimental design at this scale. Instead, we calculate the performance scaling of the experimental design at small code distances and then extrapolate. We can do this for depolarising noise, and for an average over instances of log-normal Pauli noise, calculating up to dist_max, and then extracting fits.","category":"page"},{"location":"guide/","page":"Package Guide","title":"Package Guide","text":"dist_max = 7\nmerit_scaling = calc_merit_scaling(d, dist_max)\nscaling_fit = get_scaling_fit(merit_scaling)\nensemble_scaling = calc_ensemble_scaling(d_log, dist_max; seed = seed)\nensemble_fit = get_ensemble_fit(ensemble_scaling)","category":"page"},{"location":"guide/","page":"Package Guide","title":"Package Guide","text":"This allows us to predict expectations and variances, and compare them to the true values, for both the ordinary figure of merit and the relative precision figure of merit. These are not exactly z-scores in particular because the simulation was for a single instance of log-normal Pauli noise, whereas the predictions are averaged over instances. In practice, performance appears to be self-averaging so prediction works well at scale.","category":"page"},{"location":"guide/","page":"Package Guide","title":"Package Guide","text":"wls_pred_expectation = ensemble_fit.wls_expectation_model(dist_big)\nwls_pred_variance = ensemble_fit.wls_variance_model(dist_big)\nwls_scores_big = [\n    (noise_error.wls_nrmse .- wls_pred_expectation) / sqrt(wls_pred_variance) for\n    noise_error in aces_data_big.noise_error_coll[1, :]\n]\nwls_pred_relative_expectation = ensemble_fit.wls_relative_expectation_model(dist_big)\nwls_pred_relative_variance = ensemble_fit.wls_relative_variance_model(dist_big)\nwls_relative_scores_big = [\n    (noise_error.wls_relative_nrmse .- wls_pred_relative_expectation) /\n    sqrt(wls_pred_relative_variance) for\n    noise_error in aces_data_big.noise_error_coll[1, :]\n]","category":"page"},{"location":"guide/","page":"Package Guide","title":"Package Guide","text":"We can now use Stim to simulate a memory experiment with big_rounds rounds, sampling big_shots shots. We inform the decoder, PyMatching by default, with a range of noise models including our noise estimates.","category":"page"},{"location":"guide/","page":"Package Guide","title":"Package Guide","text":"big_rounds = dist_big\nbig_shots = 5 * 10^6\ndecoder_gate_probabilities = [\n    circuit_big_log.gate_probabilities\n    circuit_big.gate_probabilities\n    [noise_est.wls_gate_probabilities \n    for noise_est in aces_data_big.noise_est_coll[1, :]\n    ]\n]\ndecoder_labels = [\n    \"True\"\n    \"Depolarising\"\n    [\"ACES S=$(budget)\" for budget in budget_set]\n]\nbig_memory_data = simulate_memory(circuit_big_log, big_rounds, big_shots;\n    seed = seed,\n    decoder_gate_probabilities = decoder_gate_probabilities,\n    decoder_labels = decoder_labels,\n    diagnostics = true,\n)\nbig_memory_summary = get_memory_summary(big_memory_data)","category":"page"},{"location":"guide/","page":"Package Guide","title":"Package Guide","text":"To implement this experimental design on an actual quantum device, we need to first construct a Pauli frame randomised version of the experimental design and generate corresponding Qiskit circuits. We specify a minimum number of randomisations min_randomisations and a target shot budget target_shot_budget, and experiment_shots shots per randomised experiment.","category":"page"},{"location":"guide/","page":"Package Guide","title":"Package Guide","text":"min_randomisations = 64\ntarget_shot_budget = 5 * 10^6\nexperiment_shots = 64\nd_rand = generate_rand_design(\n    d_log,\n    min_randomisations,\n    target_shot_budget,\n    experiment_shots;\n    seed = seed,\n)","category":"page"},{"location":"guide/","page":"Package Guide","title":"Package Guide","text":"This modifies the shot weights, so we can calculate the merit of this new design.","category":"page"},{"location":"guide/","page":"Package Guide","title":"Package Guide","text":"d_shot = get_design(d_rand)\nmerit_shot = calc_merit(d_shot)","category":"page"},{"location":"guide/","page":"Package Guide","title":"Package Guide","text":"Now we simultaneously generate ensembles of Stim and Qiskit circuits that implement this experimental design. The Qiskit circuits act on qiskit_qubit_num qubits and qiskit_qubit_map maps QuantumACES qubit indices to Qiskit qubit indices, noting that Julia indexes from 1 whereas Python indexes from 0.","category":"page"},{"location":"guide/","page":"Package Guide","title":"Package Guide","text":"qiskit_qubit_num = 17\nqiskit_qubit_map = collect(0:(qiskit_qubit_num - 1))\n(stim_ensemble, qiskit_ensemble) =\n    get_stim_qiskit_ensemble(d_rand, qiskit_qubit_num, qiskit_qubit_map)","category":"page"},{"location":"guide/","page":"Package Guide","title":"Package Guide","text":"We only simulate in Stim as the Qiskit stabiliser circuit simulator is much slower.","category":"page"},{"location":"guide/","page":"Package Guide","title":"Package Guide","text":"simulate_stim_ensemble(d_rand, stim_ensemble, experiment_shots; seed = seed)\nrand_noise_est = estimate_stim_ensemble(d_rand, experiment_shots; simulation_seed = seed)\nrand_noise_error = get_noise_error(d_rand, rand_noise_est)\nrand_noise_score = get_noise_score(rand_noise_error, merit_shot)","category":"page"},{"location":"guide/","page":"Package Guide","title":"Package Guide","text":"Suppose we then run the Qiskit circuits on a quantum device. The results must be stored in an appropriate folder to be processed. Given a prefix backend, which typically describes the device on which the circuits are run, the results must be stored relative to the current directory in a folder whose name is given by qiskit_results_folder.","category":"page"},{"location":"guide/","page":"Package Guide","title":"Package Guide","text":"backend = \"backend\"\nd_rand_filename = rand_design_filename(d_rand)\n@assert d_rand_filename[(end - 4):end] == \".jld2\"\nqiskit_results_folder = \"data/$(backend)_$(d_rand_filename[1:(end - 5)])\"","category":"page"},{"location":"guide/","page":"Package Guide","title":"Package Guide","text":"The ensemble qiskit_ensemble is a vector containing vectors of Qiskit circuits, each of which comprise a job. Each job should be stored as a pickle in qiskit_results_folder with prefix prefix, followed by an underscore and the job index, starting from 1.","category":"page"},{"location":"guide/","page":"Package Guide","title":"Package Guide","text":"prefix = \"job\"\nexample_job_1_filename = \"$(qiskit_results_folder)/$(prefix)_1.pickle\"","category":"page"},{"location":"guide/","page":"Package Guide","title":"Package Guide","text":"Then it is simple to process the data and estimate the noise.","category":"page"},{"location":"guide/","page":"Package Guide","title":"Package Guide","text":"process_qiskit_ensemble(\n    d_rand,\n    qiskit_qubit_num,\n    qiskit_qubit_map,\n    experiment_shots;\n    backend = backend,\n    prefix = prefix,\n)\nnoise_est =\n    estimate_qiskit_ensemble(d_rand, qiskit_qubit_map, experiment_shots; backend = backend)","category":"page"},{"location":"guide/","page":"Package Guide","title":"Package Guide","text":"Finally, we can analyse the consistency of this noise estimate with our noise model.","category":"page"},{"location":"guide/","page":"Package Guide","title":"Package Guide","text":"model_violation = get_model_violation(d_shot, noise_est)","category":"page"},{"location":"guide/","page":"Package Guide","title":"Package Guide","text":"This quantity is a z-score which is approximately normally distributed if the circuit-level Pauli noise model is upheld, as it is in simulation. Note the model violation score is substantially larger when calculated for the projected noise estimates, that is, the noise estimates after projecting the Pauli error probabilities into the probability simplex even in simulation. By default, then, this function calculates the model violation for the unprojected noise estimates.","category":"page"},{"location":"guide/","page":"Package Guide","title":"Package Guide","text":"We can also create a version of the experimental design corresponding to a combined noise model for which Pauli X, Z, and Y basis SPAM noise are combined into a single parameter for each qubit, so that for n qubits we have n SPAM noise parameters. Previously, we considered 3n SPAM noise parameters for each Pauli basis, which we will call the ordinary noise model. Then we can estimate the noise with the combined noise model and calculate its model violation.","category":"page"},{"location":"guide/","page":"Package Guide","title":"Package Guide","text":"d_comb = get_combined_design(d_shot)\ncomb_noise_est = estimate_gate_noise(d_comb, noise_est)\ncomb_model_violation = get_model_violation(d_comb, comb_noise_est)","category":"page"},{"location":"guide/","page":"Package Guide","title":"Package Guide","text":"We might want to perform model selection with the Akaike information criterion (AIC) or the Bayesian information criterion (BIC), which are straightforward to calculate.","category":"page"},{"location":"guide/","page":"Package Guide","title":"Package Guide","text":"aic = get_aic(d_shot, noise_est)\nbic = get_bic(d_shot, noise_est)\ncomb_aic = get_aic(d_comb, comb_noise_est)\ncomb_bic = get_bic(d_comb, comb_noise_est)","category":"page"},{"location":"guide/","page":"Package Guide","title":"Package Guide","text":"The preferred model is the one that minimises the AIC or BIC, depending on the metric of choice. In practice, the combined noise model tends not to be formally preferred but is nevertheless more parsimonious as the SPAM noise estimates in the ordinary noise model differ across Pauli bases more than can reasonably be expected. Therefore we tend not to use this model selection procedure.","category":"page"},{"location":"internal/optimise_weights/","page":"optimise_weights.jl","title":"optimise_weights.jl","text":"CollapsedDocStrings = true","category":"page"},{"location":"internal/optimise_weights/#optimise_weights.jl","page":"optimise_weights.jl","title":"optimise_weights.jl","text":"","category":"section"},{"location":"internal/optimise_weights/#Public-functions","page":"optimise_weights.jl","title":"Public functions","text":"","category":"section"},{"location":"internal/optimise_weights/","page":"optimise_weights.jl","title":"optimise_weights.jl","text":"Modules = [QuantumACES]\nPages = [\"src/optimise_weights.jl\"]\nPrivate = false","category":"page"},{"location":"internal/optimise_weights/#QuantumACES.gls_optimise_weights-Tuple{Design, SparseArrays.SparseMatrixCSC{Float64, Int64}}","page":"optimise_weights.jl","title":"QuantumACES.gls_optimise_weights","text":"gls_optimise_weights(d::Design, covariance_log::SparseMatrixCSC{Float64, Int}; options::OptimOptions = OptimOptions())\n\nReturns versions of the design d and circuit log-eigenvalue estimator covariance matrix covariance_log after optimising the shot weights with respect to the generalised least squares (GLS) figure of merit, alongside the figure of merit values at each step. The optimisation is parameterised by the OptimOptions object options.\n\n\n\n\n\n","category":"method"},{"location":"internal/optimise_weights/#QuantumACES.ols_optimise_weights-Tuple{Design, SparseArrays.SparseMatrixCSC{Float64, Int64}}","page":"optimise_weights.jl","title":"QuantumACES.ols_optimise_weights","text":"ols_optimise_weights(d::Design, covariance_log::SparseMatrixCSC{Float64, Int}; options::OptimOptions = OptimOptions())\n\nReturns versions of the design d and circuit log-eigenvalue estimator covariance matrix covariance_log after optimising the shot weights with respect to the ordinary least squares (OLS) figure of merit, alongside the figure of merit values at each step. The optimisation is parameterised by the OptimOptions object options.\n\n\n\n\n\n","category":"method"},{"location":"internal/optimise_weights/#QuantumACES.optimise_weights-Tuple{Design, SparseArrays.SparseMatrixCSC{Float64, Int64}}","page":"optimise_weights.jl","title":"QuantumACES.optimise_weights","text":"optimise_weights(d::Design, covariance_log::SparseMatrixCSC{Float64, Int}; options::OptimOptions = OptimOptions())\n\nReturns versions of the design d and circuit log-eigenvalue estimator covariance matrix covariance_log after optimising the shot weights with respect to the figure of merit, alongside the figure of merit values at each step. The optimisation is parameterised by the OptimOptions object options, which in particular specifies the least squares estimator type for which the figure of merit is calculated.\n\n\n\n\n\n","category":"method"},{"location":"internal/optimise_weights/#QuantumACES.wls_optimise_weights-Tuple{Design, SparseArrays.SparseMatrixCSC{Float64, Int64}}","page":"optimise_weights.jl","title":"QuantumACES.wls_optimise_weights","text":"wls_optimise_weights(d::Design, covariance_log::SparseMatrixCSC{Float64, Int}; options::OptimOptions = OptimOptions())\n\nReturns versions of the design d and circuit log-eigenvalue estimator covariance matrix covariance_log after optimising the shot weights with respect to the weighted least squares (WLS) figure of merit, alongside the figure of merit values at each step. The optimisation is parameterised by the OptimOptions object options.\n\n\n\n\n\n","category":"method"},{"location":"internal/optimise_weights/#Private-functions","page":"optimise_weights.jl","title":"Private functions","text":"","category":"section"},{"location":"internal/optimise_weights/","page":"optimise_weights.jl","title":"optimise_weights.jl","text":"Modules = [QuantumACES]\nPages = [\"src/optimise_weights.jl\"]\nPublic = false","category":"page"},{"location":"internal/optimise_weights/#QuantumACES.calc_gls_merit_grad_log-Tuple{Design, Vector{Float64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}}","page":"optimise_weights.jl","title":"QuantumACES.calc_gls_merit_grad_log","text":"calc_gls_merit_grad_log(d::Design, shot_weights::Vector{Float64}, covariance_log_unweighted_inv::SparseMatrixCSC{Float64, Int}, gate_transform_matrix::SparseMatrixCSC{Float64, Int})\n\nReturns the gradient of the generalised least squares (GLS) figure of merit for the design d with respect to the logarithms of the shot weights shot_weights, using the inverse of the unweighted (by the shot weights factor) covariance matrix of the circuit log-eigenvalue estimator covariance_log_unweighted_inv, with the estimator type implicitly specified by the gate eigenvalue transform matrix gate_transform_matrix.\n\n\n\n\n\n","category":"method"},{"location":"internal/optimise_weights/#QuantumACES.calc_ols_merit_grad_log-Tuple{Design, Vector{Float64}, Matrix{Float64}, Matrix{Float64}, Matrix{Float64}}","page":"optimise_weights.jl","title":"QuantumACES.calc_ols_merit_grad_log","text":"calc_ols_merit_grad_log(d::Design, shot_weights::Vector{Float64}, ols_estimator::Matrix{Float64}, ols_estimator_covariance::Matrix{Float64}, ols_gram_covariance::Matrix{Float64})\n\nReturns the gradient of the ordinary least squares (OLS) figure of merit for the design d with respect to the logarithms of the shot weights shot_weights, using the OLS estimator matrix ols_estimator, scaled by the unweighted covariance matrix in ols_estimator_covariance, and the OLS Gram matrix also scaled by the unweighted covariance matrix in ols_gram_covariance.\n\n\n\n\n\n","category":"method"},{"location":"internal/optimise_weights/#QuantumACES.calc_wls_merit_grad_log-Tuple{Design, Vector{Float64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}}","page":"optimise_weights.jl","title":"QuantumACES.calc_wls_merit_grad_log","text":"calc_wls_merit_grad_log(d::Design, shot_weights::Vector{Float64}, covariance_log_unweighted::SparseMatrixCSC{Float64, Int}, gate_transform_matrix::SparseMatrixCSC{Float64, Int})\n\nReturns the gradient of the weighted least squares (WLS) figure of merit for the design d with respect to the logarithms of the shot weights shot_weights, using the unweighted (by the shot weights factor) covariance matrix of the circuit log-eigenvalue estimator covariance_log_unweighted, with the estimator type implicitly specified by the gate eigenvalue transform matrix gate_transform_matrix.\n\n\n\n\n\n","category":"method"},{"location":"internal/optimise_weights/#QuantumACES.get_merit_grad-Tuple{Float64, Vector{Float64}, Float64, Vector{Float64}, Integer}","page":"optimise_weights.jl","title":"QuantumACES.get_merit_grad","text":"get_merit_grad(sigma_tr::Float64, sigma_tr_grad::Vector{Float64}, sigma_sq_tr::Float64, sigma_sq_tr_grad::Vector{Float64}, N::Integer)\n\nReturns the gradient of the figure of merit with respect to the shot weights given the trace of the gate eigenvalue estimator covariance matrix sigma_tr and its square sigma_sq_tr, the gradient with respect to the shot weights sigma_tr_grad and the gradient of the square sigma_sq_tr_grad, and the number of gate eigenvalues N.\n\n\n\n\n\n","category":"method"},{"location":"internal/optimise_weights/#QuantumACES.get_shot_weights_factor-Tuple{Vector{Float64}, Vector{Float64}, Vector{Int64}}","page":"optimise_weights.jl","title":"QuantumACES.get_shot_weights_factor","text":"get_shot_weights_factor(shot_weights::Vector{Float64}, tuple_times::Vector{Float64}, mapping_lengths::Vector{Int})\n\nReturns the shot weights factor for the sparse block diagonal circuit (log-)eigenvalue estimator covariance matrix for the shot weights shot_weights and tuple times tuple_times, where the block sizes are specified by mapping_lengths.\n\n\n\n\n\n","category":"method"},{"location":"internal/optimise_weights/#QuantumACES.get_shot_weights_factor_inv-Tuple{Vector{Float64}, Vector{Float64}, Vector{Int64}}","page":"optimise_weights.jl","title":"QuantumACES.get_shot_weights_factor_inv","text":"get_shot_weights_factor_inv(shot_weights::Vector{Float64}, tuple_times::Vector{Float64}, mapping_lengths::Vector{Int})\n\nReturns the shot weights inverse factor for the sparse block diagonal circuit (log-)eigenvalue estimator covariance matrix for the shot weights shot_weights and tuple times tuple_times, where the block sizes are specified by mapping_lengths.\n\n\n\n\n\n","category":"method"},{"location":"internal/optimise_weights/#QuantumACES.get_shot_weights_local_grad-Tuple{Vector{Float64}, Vector{Float64}}","page":"optimise_weights.jl","title":"QuantumACES.get_shot_weights_local_grad","text":"get_shot_weights_local_grad(shot_weights::Vector{Float64}, tuple_times::Vector{Float64})\n\nReturns the local gradient factor corresponding to each tuple's block in the covariance matrix, at shot weights shot_weights and tuple times tuple_times.\n\n\n\n\n\n","category":"method"},{"location":"internal/optimise_weights/#QuantumACES.get_shot_weights_log_matrix-Tuple{Vector{Float64}}","page":"optimise_weights.jl","title":"QuantumACES.get_shot_weights_log_matrix","text":"get_shot_weights_log_matrix(shot_weights::Vector{Float64})\n\nReturns the matrix that transforms the gradient of the figure of merit with respect to the shot weights shot_weights into the gradient of the figure of merit with respect to the logarithms of the shot weights.\n\n\n\n\n\n","category":"method"},{"location":"internal/design/","page":"design.jl","title":"design.jl","text":"CollapsedDocStrings = true","category":"page"},{"location":"internal/design/#design.jl","page":"design.jl","title":"design.jl","text":"","category":"section"},{"location":"internal/design/#Public-functions","page":"design.jl","title":"Public functions","text":"","category":"section"},{"location":"internal/design/","page":"design.jl","title":"design.jl","text":"Modules = [QuantumACES]\nPages = [\"src/design.jl\"]\nPrivate = false","category":"page"},{"location":"internal/design/#QuantumACES.Design","page":"design.jl","title":"QuantumACES.Design","text":"Design\n\nExperimental design for a noise characterisation experiment for a circuit.\n\nFields\n\nc::AbstractCircuit: Circuit characterised by the design.\nfull_covariance::Bool: If true, generates parameters to construct the full covariance matrix in covariance_dict_ensemble, else if false, only generates parameters to construct the terms on the diagonal.\nmatrix::SparseMatrixCSC{Int32, Int32}: Sparse M x N design matrix, corresponding to M circuit eigenvalues and N gate eigenvalues.\ntuple_set::Vector{Vector{Int}}: Set of tuples which arrange the circuit layers.\ntuple_set_data::TupleSetData: TupleSetData object that generates the tuple set.\nmapping_ensemble::Vector{Vector{Mapping}}: Vector of the Mapping objects for each of the circuit eigenvalue for the Paulis corresponding to that tuple, for each tuple in the set.\nexperiment_ensemble::Vector{Vector{Vector{Int}}}: Vector of the experiments that index Mapping objects, which correspond to simultaneously preparable and measurable circuit eigenvalues, for each tuple in the set.\ncovariance_dict_ensemble::Vector{Dict{CartesianIndex{2}, Tuple{Mapping, Int}}}: Dictionary of Mapping objects describing the non-zero entries of the sparse circuit eigenvalue estimator covariance matrix, alongside the number of times the entry is estimated by the experiment set, for each tuple in the set.\nprep_ensemble::Vector{Vector{Layer}}: Vector of Layer objects that prepare qubits in Pauli eigenstates for each experiment in the set, for each tuple in the set.\nmeas_ensemble::Vector{Vector{Layer}}: Vector of Layer objects that measure qubits in Pauli bases for each experiment in the set, for each tuple in the set.\ntuple_times::Vector{Float64}: Time taken to implement the circuit arranged by each tuple in the set, normalised according to the time factor for the basic tuple set.\nshot_weights::Vector{Float64}: Shot weights for each tuple in the set, which add to 1.\nexperiment_numbers::Vector{Int}: Number of experiments for each tuple in the set.\nexperiment_number::Int: Total number of experiments.\ncalculation_times::Matrix{Float64}: Time taken to generate components of the design for each tuple, which correspond to generating: the mappings, the sets of tuple-consistent Pauli preparations, the experiment sets, and the covariance matrix dictionary.\noverall_time::Float64: Overall time taken to generate the design.\noptimisation_time::Float64: Time taken to optimise the design.\nls_type::Symbol: Type of least squares for which the shot weights were optimised.\n\n\n\n\n\n","category":"type"},{"location":"internal/design/#QuantumACES.Mapping","page":"design.jl","title":"QuantumACES.Mapping","text":"Mapping\n\nMapping of a Pauli operator by some circuit.\n\nFields\n\ninitial::Pauli: Initial Pauli operator before the action of the circuit.\nfinal::Pauli: Final Pauli operator after the action of the circuit.\ndesign_row::SparseVector{Int32, Int32}: Design matrix row for the circuit eigenvalue corresponding to the initial Pauli and the circuit used for the mapping.\nspread_track::Vector{Vector{Int16}}: Track of the support of the Pauli as it is acted upon by the layers of the circuit.\n\n\n\n\n\n","category":"type"},{"location":"internal/design/#QuantumACES.Pauli","page":"design.jl","title":"QuantumACES.Pauli","text":"Pauli\n\nBoolean representation of a Pauli operator.\n\nFields\n\npauli::Vector{Bool}: The Pauli operator stored as a Boolean vector. The first qubit_num elements represent Pauli X on each qubit, the next qubit_num elements represent Pauli Z on each qubit, and the final element represents the sign.\nqubit_num::Int16: The number of qubits on which the Pauli operator acts; the length of the vector is 2 * qubit_num + 1.\n\n\n\n\n\n","category":"type"},{"location":"internal/design/#QuantumACES.generate_design-Union{Tuple{T}, Tuple{T, Vector{Vector{Int64}}}} where T<:AbstractCircuit","page":"design.jl","title":"QuantumACES.generate_design","text":"generate_design(c::AbstractCircuit, tuple_set::Vector{Vector{Int}}; kwargs...)\ngenerate_design(c::AbstractCircuit, tuple_set_data::TupleSetData; kwargs...)\ngenerate_design(c::AbstractCircuit, d::Design; kwargs...)\ngenerate_design(c::AbstractCircuit; kwargs...)\n\nReturns a Design object containing all relevant information describing the experimental design, including the design matrix.\n\nArguments\n\nc::AbstractCircuit: Circuit for which the design matrix is to be generated.\ntuple_set::Vector{Vector{Int}}: Tuple set arranging the circuit layers that is used to generate the experimental design.\ntuple_set_data::TupleSetData: TupleSetData object that generates the tuple set.\nd::Design: Old design object whose parameters are used to generate the design for the circuit c.\n\nKeyword arguments\n\nshot_weights::Union{Vector{Float64}, Nothing} = nothing: Shot weights for each tuple in the set, which must add to 1. When nothing, automatically generates the default shot weights.\nN_warn::Integer = 10^5: Number of circuit eigenvalues above which to warn the user about certain keyword argument choices.\nfull_covariance::Bool = (c.gate_data.N < N_warn ? true : false): If true, generates parameters to construct the full covariance matrix, else if false, only generates parameters to construct the terms on the diagonal.\nadd_circuit::Bool = false: If tuple set data has not been supplied, the circuit itself is added to the repeat tuple set.\nrepeat_points::Integer = 1: If tuple set data has not been supplied, the each repeat number is augmented to have repeat_points repeat numbers.\nweight_experiments::Bool = true: Whether to weight the shot weights for a tuple by the number of experiments for that tuple.\ndiagnostics::Bool = false: Whether to print diagnostic information.\nsave_data::Bool = false: Whether to save the design data.\n\n\n\n\n\n","category":"method"},{"location":"internal/design/#QuantumACES.get_combined_design-Tuple{Design}","page":"design.jl","title":"QuantumACES.get_combined_design","text":"get_combined_design(d::Design; diagnostics::Bool = false)\n\nReturns a copy of the design d where the three parameters describing Pauli X, Y, and Z basis measurements have been combined into a single parameter for each qubit, printing diagnostics if diagnostics is true.\n\n\n\n\n\n","category":"method"},{"location":"internal/design/#QuantumACES.get_diag_design-Tuple{Design}","page":"design.jl","title":"QuantumACES.get_diag_design","text":"get_diag_design(d::Design; diagnostics::Bool = false)\n\nReturns a copy of the design d where the covariance matrix dictionary generates a diagonal covariance matrix, printing diagnostics if diagnostics is true.\n\n\n\n\n\n","category":"method"},{"location":"internal/design/#QuantumACES.get_eigenvalues-Tuple{Design, Vector{Float64}}","page":"design.jl","title":"QuantumACES.get_eigenvalues","text":"get_eigenvalues(d::Design)\nget_eigenvalues(d::Design, gate_eigenvalues::Vector{Float64})\n\nReturns the circuit eigenvalues of the design d, optionally using the gate eigenvalues gate_eigenvalues.\n\n\n\n\n\n","category":"method"},{"location":"internal/design/#QuantumACES.get_full_design-Tuple{Design}","page":"design.jl","title":"QuantumACES.get_full_design","text":"get_full_design(d::Design; diagnostics::Bool = false)\n\nReturns a copy of the design d where the covariance matrix dictionary generates the full covariance matrix, printing diagnostics if diagnostics is true.\n\n\n\n\n\n","category":"method"},{"location":"internal/design/#QuantumACES.get_gate_eigenvalues-Tuple{Design}","page":"design.jl","title":"QuantumACES.get_gate_eigenvalues","text":"get_gate_eigenvalues(d::Design)\n\nReturns the gate eigenvalues of the design d.\n\n\n\n\n\n","category":"method"},{"location":"internal/design/#QuantumACES.get_gate_probabilities-Tuple{Design}","page":"design.jl","title":"QuantumACES.get_gate_probabilities","text":"get_gate_probabilities(d::Design)\n\nReturns the gate error probabilities of the design d.\n\n\n\n\n\n","category":"method"},{"location":"internal/design/#QuantumACES.get_marginal_gate_eigenvalues-Tuple{Design}","page":"design.jl","title":"QuantumACES.get_marginal_gate_eigenvalues","text":"get_marginal_gate_eigenvalues(d::Design)\n\nReturns the gate eigenvalues of the design d marginalised over gate orbits.\n\n\n\n\n\n","category":"method"},{"location":"internal/design/#QuantumACES.get_marginal_gate_probabilities-Tuple{Design}","page":"design.jl","title":"QuantumACES.get_marginal_gate_probabilities","text":"get_marginal_gate_probabilities(d::Design)\n\nReturns the gate error probabilities of the design d marginalised over gate orbits.\n\n\n\n\n\n","category":"method"},{"location":"internal/design/#QuantumACES.get_relative_gate_eigenvalues-Tuple{Design}","page":"design.jl","title":"QuantumACES.get_relative_gate_eigenvalues","text":"get_relative_gate_eigenvalues(d::Design)\n\nReturns the gate eigenvalues of the design d marginalised over gate orbits which can be estimated to relative precision.\n\n\n\n\n\n","category":"method"},{"location":"internal/design/#QuantumACES.get_relative_gate_probabilities-Tuple{Design}","page":"design.jl","title":"QuantumACES.get_relative_gate_probabilities","text":"get_relative_gate_probabilities(d::Design)\n\nReturns the gate error probabilities of the design d marginalised over gate orbits which can be estimated to relative precision.\n\n\n\n\n\n","category":"method"},{"location":"internal/design/#QuantumACES.update_noise-Union{Tuple{T}, Tuple{Design, T}} where T<:AbstractNoiseParameters","page":"design.jl","title":"QuantumACES.update_noise","text":"update_noise(d::Design, noise_param::AbstractNoiseParameters)\nupdate_noise(d::Design, gate_probabilities::Dict{Gate, Vector{Float64}})\n\nReturns a copy of the design d where the circuit has been updated with noise generated according to noise_param, or the gate probabilities gate_probabilities.\n\n\n\n\n\n","category":"method"},{"location":"internal/design/#Private-functions","page":"design.jl","title":"Private functions","text":"","category":"section"},{"location":"internal/design/","page":"design.jl","title":"design.jl","text":"Modules = [QuantumACES]\nPages = [\"src/design.jl\"]\nPublic = false","category":"page"},{"location":"internal/design/#QuantumACES.calc_consistency_set-Tuple{Vector{Mapping}}","page":"design.jl","title":"QuantumACES.calc_consistency_set","text":"calc_consistency_set(mapping_set::Vector{Mapping})\n\nReturns a list for each mapping in mapping_set of all other mappings with which it is simultaneously preparable and measurable, and hence tuple-consistent.\n\n\n\n\n\n","category":"method"},{"location":"internal/design/#QuantumACES.calc_covariance_dict-Union{Tuple{T}, Tuple{T, Vector{Mapping}, Vector{Vector{Int64}}, Bool}} where T<:AbstractCircuit","page":"design.jl","title":"QuantumACES.calc_covariance_dict","text":"calc_covariance_dict(c::AbstractCircuit, mapping_set::Vector{Mapping}, experiment_set::Vector{Vector{Int}}, full_covariance::Bool)\n\nReturns a dictionary with the requisite information to calculate the sparse circuit eigenvalue estimator covariance matrix for the arranged circuit c, with mappings mapping_set, when estimated by the experiments in experiment_set. If full_covariance is true, then this constructs the full covariance matrix, whereas if full_covariance is false, then this constructs only the diagonal terms of the covariance matrix.\n\nBEWARE: This currently assumes that circuit eigenvalues for Paulis supported on n qubits require preparing exactly and only 2^n sign configurations. Errors will occur if this is not the case, and they are not guaranteed to be noisy. If creating a circuit where this is not the case, you will need to provide new methods for this function.\n\n\n\n\n\n","category":"method"},{"location":"internal/design/#QuantumACES.calc_experiment_set-Tuple{Vector{Mapping}, Vector{Vector{Int64}}}","page":"design.jl","title":"QuantumACES.calc_experiment_set","text":"calc_experiment_set(mapping_set::Vector{Mapping}, consistency_set::Vector{Vector{Int}})\n\nReturns a set of experiments which simultaneously estimate the circuit eigenvalues corresponding to the mappings in mapping_set, whose tuple-consistency relations are described by consistency_set.\n\n\n\n\n\n","category":"method"},{"location":"internal/design/#QuantumACES.calc_mapping-Union{Tuple{T}, Tuple{Pauli, Dict{Gate, Int64}, T}} where T<:AbstractCircuit","page":"design.jl","title":"QuantumACES.calc_mapping","text":"calc_mapping(initial::Pauli, gate_index_dict::Dict{Gate, Int}, c::AbstractCircuit)\n\nReturns a Mapping object for the Pauli initial when mapped by the circuit c with gate index dictionary gate_index_dict.\n\n\n\n\n\n","category":"method"},{"location":"internal/design/#QuantumACES.calc_mapping_set-Tuple{T} where T<:AbstractCircuit","page":"design.jl","title":"QuantumACES.calc_mapping_set","text":"calc_mapping_set(c::AbstractCircuit)\n\nReturns a vector of Mapping objects for each single-qubit Pauli on the qubits in the circuit c, and each two-qubit Pauli supported on some gate in the circuit c.\n\n\n\n\n\n","category":"method"},{"location":"internal/design/#QuantumACES.get_eigenvalues_ensemble-Tuple{Design, Vector{Float64}}","page":"design.jl","title":"QuantumACES.get_eigenvalues_ensemble","text":"get_eigenvalues_ensemble(d::Design)\nget_eigenvalues_ensemble(d::Design, gate_eigenvalues::Vector{Float64})\n\nReturns the circuit eigenvalue ensemble of the design d, optionally using the gate eigenvalues gate_eigenvalues.\n\n\n\n\n\n","category":"method"},{"location":"internal/design/#QuantumACES.get_experiment_layers-Union{Tuple{T}, Tuple{T, Vector{Mapping}, Vector{Vector{Int64}}}} where T<:AbstractCircuit","page":"design.jl","title":"QuantumACES.get_experiment_layers","text":"get_experiment_layers(c::AbstractCircuit, mapping_set::Vector{Mapping}, experiment_set::Vector{Vector{Int}})\n\nReturns circuit layers that prepare and measure the initial and final Paulis as given by the mappings in mapping_set, for each experiment in experiment set. If c has a partition field, this is used to generate all necessary sign configurations for the preparation layers.\n\n\n\n\n\n","category":"method"},{"location":"internal/design/#QuantumACES.get_meas_layer-Tuple{Pauli, Vector{Int64}}","page":"design.jl","title":"QuantumACES.get_meas_layer","text":"get_meas_layer(final::Pauli, final_support::Vector{Int})\n\nReturns a layer which measures the Pauli final, supported on the qubits in final_support.\n\n\n\n\n\n","category":"method"},{"location":"internal/design/#QuantumACES.get_pauli_prep_set-Tuple{Vector{Gate}, Integer}","page":"design.jl","title":"QuantumACES.get_pauli_prep_set","text":"get_pauli_prep_set(gates::Vector{Gate}, n::Integer)\n\nReturns all weight-1 Paulis on all n qubits, as well as the weight-2 Paulis supported on some gate in gates.\n\n\n\n\n\n","category":"method"},{"location":"internal/design/#QuantumACES.get_prep_layer-Tuple{Pauli, Vector{Int64}}","page":"design.jl","title":"QuantumACES.get_prep_layer","text":"get_prep_layer(initial::Pauli, initial_support::Vector{Int})\n\nReturns a layer which prepares the Pauli initial, supported on the qubits in initial_support.\n\n\n\n\n\n","category":"method"},{"location":"internal/design/#QuantumACES.update_design_row!-Tuple{Vector{Int64}, Pauli, Layer, Dict{Gate, Int64}}","page":"design.jl","title":"QuantumACES.update_design_row!","text":"update_design_row!(design_row::Vector{Int}, pauli::Pauli, l::Layer, gate_index_dict::Dict{Gate, Int})\n\nUpdates the design matrix row design_row according to the Pauli pauli for each gate in the layer l, using the gate index dictionary gate_index_dict.\n\n\n\n\n\n","category":"method"},{"location":"internal/circuits/unrotated_planar/","page":"circuits/unrotated_planar.jl","title":"circuits/unrotated_planar.jl","text":"CollapsedDocStrings = true","category":"page"},{"location":"internal/circuits/unrotated_planar/#unrotated_planar.jl","page":"circuits/unrotated_planar.jl","title":"unrotated_planar.jl","text":"","category":"section"},{"location":"internal/circuits/unrotated_planar/#Public-functions","page":"circuits/unrotated_planar.jl","title":"Public functions","text":"","category":"section"},{"location":"internal/circuits/unrotated_planar/","page":"circuits/unrotated_planar.jl","title":"circuits/unrotated_planar.jl","text":"Modules = [QuantumACES]\nPages = [\"src/circuits/unrotated_planar.jl\"]\nPrivate = false","category":"page"},{"location":"internal/circuits/unrotated_planar/#QuantumACES.UnrotatedPlanarParameters","page":"circuits/unrotated_planar.jl","title":"QuantumACES.UnrotatedPlanarParameters","text":"UnrotatedPlanarParameters\n\nParameters for the syndrome extraction circuit of an unrotated planar code.\n\nFields\n\nparams::Dict{Symbol, Any}: Dictionary of the circuit parameters described below.\ncircuit_name::String: Name of the circuit used for saving data.\n\nParameters\n\nvertical_dist::Int: Vertical (Z) distance of the code.\nhorizontal_dist::Int: Horizontal (X) distance of the code.\ngate_type::Symbol: Type of two-qubit gate used in the circuit, which must be :cx.\nancilla_measurement::Bool: Whether to include mid-circuit ancilla measurements.\npad_identity::Bool: Whether to pad layers with single-qubit identity gates.\nlayer_time_dict::Dict{Symbol, Float64}: Dictionary of layer times.\n\n\n\n\n\n","category":"type"},{"location":"internal/circuits/unrotated_planar/#QuantumACES.get_circuit-Union{Tuple{T}, Tuple{UnrotatedPlanarParameters, T}} where T<:AbstractNoiseParameters","page":"circuits/unrotated_planar.jl","title":"QuantumACES.get_circuit","text":"get_circuit(unrotated_param::UnrotatedPlanarParameters, noise_param::AbstractNoiseParameters; kwargs...)\n\nReturns an unrotated planar code syndrome extraction circuit in the form of a Circuit object parameterised by the supplied circuit and noise parameters.\n\nArguments\n\nunrotated_param::UnrotatedPlanarParameters: Parameters for an unrotated planar code.\nnoise_param::AbstractNoiseParameters: Noise parameters for the circuit.\n\nKeyword arguments\n\nnoisy_prep::Bool = false: Whether to treat preparations as noisy and characterise the associated noise, defaulting to false; a full-rank design cannot be produced if both noisy_prep and noisy_meas are true.\nnoisy_meas::Bool = true: Whether to treat measurements as noisy and characterise the associated noise, defaulting to true; a full-rank design cannot be produced if both noisy_prep and noisy_meas are true.\ncombined::Bool = haskey(noise_param.params, :combined) ? noise_param.params[:combined] : false,: Whether to treat Pauli X, Y, and Z basis SPAM noise as the same.\nstrict::Bool = false: Whether to be strict about which gates count as estimable to relative precision.\n\n\n\n\n\n","category":"method"},{"location":"internal/circuits/unrotated_planar/#QuantumACES.get_unrotated_param-Tuple{Integer, Integer}","page":"circuits/unrotated_planar.jl","title":"QuantumACES.get_unrotated_param","text":"get_unrotated_param(vertical_dist::Integer, horizontal_dist::Integer; kwargs...)\nget_unrotated_param(dist::Integer; kwargs...)\n\nReturns an UnrotatedPlanarParameters object that parameterises the syndrome extraction circuit of an unrotated planar code.\n\nDefault gate layer times are estimated from Suppressing quantum errors by scaling a surface code logical qubit by Google Quantum AI (2023).\n\nArguments\n\nvertical_dist::Int: Vertical (Z) distance of the code.\nhorizontal_dist::Int: Horizontal (X) distance of the code.\ndist::Int: Distance of the code; this is equivalent to setting vertical_dist = dist and horizontal_dist = dist.\n\nKeyword arguments\n\ngate_type::Symbol = :cx: Type of two-qubit gate used in the circuit, which must be :cx.\nancilla_measurement::Bool = true: Whether to include mid-circuit reset.\npad_identity::Bool = true: Whether to pad layers with single-qubit identity gates.\nsingle_qubit_time::Real = 29: Time taken to implement a single-qubit gate in nanoseconds.\ntwo_qubit_time::Real = 29: Time taken to implement a two-qubit gate in nanoseconds.\nmeas_reset_time::Real = 660: Time taken to perform measurement and reset at the end of the circuit in nanoseconds.\nmid_reset_time::Real = 660: Time taken to perform mid-circuit reset in nanoseconds.\n\n\n\n\n\n","category":"method"},{"location":"internal/circuits/unrotated_planar/#Private-functions","page":"circuits/unrotated_planar.jl","title":"Private functions","text":"","category":"section"},{"location":"internal/circuits/unrotated_planar/","page":"circuits/unrotated_planar.jl","title":"circuits/unrotated_planar.jl","text":"Modules = [QuantumACES]\nPages = [\"src/circuits/unrotated_planar.jl\"]\nPublic = false","category":"page"},{"location":"internal/circuits/unrotated_planar/#QuantumACES.unrotated_planar_circuit-Tuple{UnrotatedPlanarParameters}","page":"circuits/unrotated_planar.jl","title":"QuantumACES.unrotated_planar_circuit","text":"unrotated_planar_circuit(unrotated_param::UnrotatedPlanarParameters)\n\nReturns fields used to construct the syndrome extraction circuit of an unrotated planar code based on the supplied parameters unrotated_param.\n\n\n\n\n\n","category":"method"},{"location":"internal/optimise_tuples/","page":"optimise_tuples.jl","title":"optimise_tuples.jl","text":"CollapsedDocStrings = true","category":"page"},{"location":"internal/optimise_tuples/#optimise_tuples.jl","page":"optimise_tuples.jl","title":"optimise_tuples.jl","text":"","category":"section"},{"location":"internal/optimise_tuples/#Public-functions","page":"optimise_tuples.jl","title":"Public functions","text":"","category":"section"},{"location":"internal/optimise_tuples/","page":"optimise_tuples.jl","title":"optimise_tuples.jl","text":"Modules = [QuantumACES]\nPages = [\"src/optimise_tuples.jl\"]\nPrivate = false","category":"page"},{"location":"internal/optimise_tuples/#QuantumACES.optimise_design-Union{Tuple{T}, Tuple{T, TupleSetData}} where T<:AbstractCircuit","page":"optimise_tuples.jl","title":"QuantumACES.optimise_design","text":"optimise_design(c::AbstractCircuit; options::OptimOptions = OptimOptions())\noptimise_design(c::AbstractCircuit, tuple_set_data::TupleSetData; options::OptimOptions = OptimOptions())\n\nReturns an optimised experimental design for the circuit c initialised with the tuple set data tuple_set_data. The optimisation is parameterised by the OptimOptions object options.\n\n\n\n\n\n","category":"method"},{"location":"internal/optimise_tuples/#QuantumACES.optimise_repetitions-Union{Tuple{T}, Tuple{T, TupleSetData}} where T<:AbstractCircuit","page":"optimise_tuples.jl","title":"QuantumACES.optimise_repetitions","text":"optimise_repetitions(c::AbstractCircuit, tuple_set_data::TupleSetData; options::OptimOptions = OptimOptions())\n\nReturns the tuple set data after optimising the repetition numbers in the supplied tuple set data tuple_set_data for the circuit c. The optimisation is parameterised by the OptimOptions object options.\n\n\n\n\n\n","category":"method"},{"location":"internal/optimise_tuples/#QuantumACES.optimise_tuple_set-Tuple{Design, SparseArrays.SparseMatrixCSC{Float64, Int64}}","page":"optimise_tuples.jl","title":"QuantumACES.optimise_tuple_set","text":"optimise_tuple_set(d::Design, covariance_log::SparseMatrixCSC{Float64, Int}; options::OptimOptions = OptimOptions())\n\nReturns versions of the design d and circuit log-eigenvalue estimator covariance matrix covariance_log after optimising the tuple set of the design with repeated excursions that grow and prune the tuple set. The optimisation is parameterised by the OptimOptions object options.\n\n\n\n\n\n","category":"method"},{"location":"internal/optimise_tuples/#Private-functions","page":"optimise_tuples.jl","title":"Private functions","text":"","category":"section"},{"location":"internal/optimise_tuples/","page":"optimise_tuples.jl","title":"optimise_tuples.jl","text":"Modules = [QuantumACES]\nPages = [\"src/optimise_tuples.jl\"]\nPublic = false","category":"page"},{"location":"internal/optimise_tuples/#QuantumACES.cap_repetition-NTuple{4, Int64}","page":"optimise_tuples.jl","title":"QuantumACES.cap_repetition","text":"cap_repetition(repeat_number::Int, repeat_tuple_depth::Int, min_depth::Int, max_depth::Int; diagnostics::Bool = false)\n\nReturns a copy of the repeat number repeat_number capped according to the minimum and maximum depths min_depth and max_depth, respectively, given a repeat tuple depth repeat_tuple_depth, with the same parity as the original repeat number.\n\n\n\n\n\n","category":"method"},{"location":"internal/optimise_tuples/#QuantumACES.grow_design-Tuple{Design, Vector{Int64}}","page":"optimise_tuples.jl","title":"QuantumACES.grow_design","text":"grow_design(d::Design, circuit_tuple::Vector{Int}; weight_experiments::Bool = true)\ngrow_design(d::Design, covariance_log::SparseMatrixCSC{Float64, Int}, circuit_tuple::Vector{Int};, weight_experiments::Bool = true)\n\nReturns versions of the design d and optionally the circuit log-eigenvalue estimator covariance matrix covariance_log after adding the tuple circuit_tuple to the tuple set of the design, weighting the shot weights by the experiments if weight_experiments is true following get_tuple_set_params.\n\n\n\n\n\n","category":"method"},{"location":"internal/optimise_tuples/#QuantumACES.grow_design_excursion-Tuple{Design, SparseArrays.SparseMatrixCSC{Float64, Int64}}","page":"optimise_tuples.jl","title":"QuantumACES.grow_design_excursion","text":"grow_design_excursion(d::Design, covariance_log::SparseMatrixCSC{Float64, Int}; options::OptimOptions = OptimOptions())\n\nReturns versions of the design d and circuit log-eigenvalue estimator covariance matrix covariance_log after optimising the tuple set of the design with an excursion that grows the tuple set. The optimisation is parameterised by the OptimOptions object options.\n\n\n\n\n\n","category":"method"},{"location":"internal/optimise_tuples/#QuantumACES.optimal_expectation-Union{Tuple{T}, Tuple{TupleSetData, Dict{Vector{Int64}, Float64}, T}} where T<:AbstractCircuit","page":"optimise_tuples.jl","title":"QuantumACES.optimal_expectation","text":"optimal_expectation(tuple_set_data::TupleSetData, expectation_dict::Dict{Vector{Int}, Float64}, c::AbstractCircuit; options::OptimOptions = OptimOptions())\n\nReturns the optimised figure of merit, and a dictionary of stored values, for the circuit c with tuple set data tuple_set_data, with optimised shot weights. The optimisation is parameterised by the OptimOptions object options.\n\n\n\n\n\n","category":"method"},{"location":"internal/optimise_tuples/#QuantumACES.prune_design-Tuple{Design, Integer}","page":"optimise_tuples.jl","title":"QuantumACES.prune_design","text":"prune_design(d::Design, prune_idx::Integer)\nprune_design(d::Design, covariance_log::SparseMatrixCSC{Float64, Int}, prune_idx::Integer; update_weights::Bool = true)\n\nReturns versions of the design d and optionally the circuit log-eigenvalue estimator covariance matrix covariance_log after removing the tuple at index prune_idx from the tuple set of the design. If update_weights is false, do not update the shot weight factor for the covariance matrix.\n\n\n\n\n\n","category":"method"},{"location":"internal/optimise_tuples/#QuantumACES.prune_design_excursion-Tuple{Design, SparseArrays.SparseMatrixCSC{Float64, Int64}}","page":"optimise_tuples.jl","title":"QuantumACES.prune_design_excursion","text":"prune_design_excursion(d::Design, covariance_log::SparseMatrixCSC{Float64, Int}; options::OptimOptions = OptimOptions())\n\nReturns versions of the design d and circuit log-eigenvalue estimator covariance matrix covariance_log after optimising the tuple set of the design with an excursion that prunes the tuple set. The optimisation is parameterised by the OptimOptions object options.\n\n\n\n\n\n","category":"method"},{"location":"internal/optimise_tuples/#QuantumACES.random_tuple-Union{Tuple{T}, Tuple{T, Integer, Float64, Bool}} where T<:AbstractCircuit","page":"optimise_tuples.jl","title":"QuantumACES.random_tuple","text":"random_tuple(c::AbstractCircuit, tuple_length::Integer, s::Float64, mirror::Bool)\n\nReturns a random tuple for the circuit c with length tuple_length. The generation is parameterised by the Zipf power s and the tuple is mirrored if mirror is true. Adds random indices to the tuple, repeated a number of times following a generalised Zipf distribution. For dynamically decoupled circuits, this function ensures that two-qubit gate layers are always followed by some other layer in the tuple.\n\n\n\n\n\n","category":"method"},{"location":"internal/optimise_tuples/#QuantumACES.sample_zipf-Tuple{Integer, Float64}","page":"optimise_tuples.jl","title":"QuantumACES.sample_zipf","text":"sample_zipf(N::Integer, s::Float64)\n\nReturns a sample from a generalised Zipf distribution supported on 1 to N parameterised by the power s.\n\n\n\n\n\n","category":"method"},{"location":"internal/optimise_tuples/#QuantumACES.step_repetition-Union{Tuple{T}, Tuple{TupleSetData, Dict{Vector{Int64}, Float64}, Vector{Int64}, Integer, T}} where T<:AbstractCircuit","page":"optimise_tuples.jl","title":"QuantumACES.step_repetition","text":"step_repetition(tuple_set_data::TupleSetData, expectation_dict::Dict{Vector{Int}, Float64}, step_tracker::Vector{Int}, coordinate_idx::Integer, c::AbstractCircuit; options::OptimOptions = OptimOptions())\n\nReturns the tuple set data, a dictionary of stored figure of merit, and the step tracker after stepping the repetition number for the tuple set data tuple_set_data at the index coordinate_idx for the circuit c. The optimisation is parameterised by the OptimOptions object options.\n\n\n\n\n\n","category":"method"},{"location":"internal/optimise_tuples/#QuantumACES.tuple_append!-Tuple{Vector{Int64}, Integer, Float64, Vector{Int64}, Vector{Int64}, Vector{Int64}}","page":"optimise_tuples.jl","title":"QuantumACES.tuple_append!","text":"tuple_append!(circuit_tuple::Vector{Int}, tuple_length::Integer, s::Float64, unique_indices::Vector{Int}, two_qubit_indices::Vector{Int}, other_indices::Vector{Int})\n\nAppends a random index from unique_indices to the tuple circuit_tuple, repeated a number of times determined by a Zipf distribution on 1 to tuple_length with power s. Ensures that two-qubit layers, whose indices are given by two_qubit_indices, are always followed by other layers in the tuple, whose indices are given by other_indices.\n\n\n\n\n\n","category":"method"},{"location":"internal/optimise_tuples/#QuantumACES.tuple_append!-Tuple{Vector{Int64}, Integer, Float64, Vector{Int64}}","page":"optimise_tuples.jl","title":"QuantumACES.tuple_append!","text":"tuple_append!(circuit_tuple::Vector{Int}, tuple_length::Integer, s::Float64, unique_indices::Vector{Int})\n\nAppends a random index from unique_indices to the tuple circuit_tuple, repeated a number of times determined by a Zipf distribution on 1 to tuple_length with power s.\n\n\n\n\n\n","category":"method"},{"location":"internal/circuits/rotated_planar/","page":"circuits/rotated_planar.jl","title":"circuits/rotated_planar.jl","text":"CollapsedDocStrings = true","category":"page"},{"location":"internal/circuits/rotated_planar/#rotated_planar.jl","page":"circuits/rotated_planar.jl","title":"rotated_planar.jl","text":"","category":"section"},{"location":"internal/circuits/rotated_planar/#Public-functions","page":"circuits/rotated_planar.jl","title":"Public functions","text":"","category":"section"},{"location":"internal/circuits/rotated_planar/","page":"circuits/rotated_planar.jl","title":"circuits/rotated_planar.jl","text":"Modules = [QuantumACES]\nPages = [\"src/circuits/rotated_planar.jl\"]\nPrivate = false","category":"page"},{"location":"internal/circuits/rotated_planar/#QuantumACES.RotatedPlanarParameters","page":"circuits/rotated_planar.jl","title":"QuantumACES.RotatedPlanarParameters","text":"RotatedPlanarParameters\n\nParameters for the syndrome extraction circuit of a rotated planar code.\n\nFields\n\nparams::Dict{Symbol, Any}: Dictionary of the circuit parameters described below.\ncircuit_name::String: Name of the circuit used for saving data.\n\nParameters\n\nvertical_dist::Int: Vertical (Z) distance of the code.\nhorizontal_dist::Int: Horizontal (X) distance of the code.\ncheck_type::Symbol: Type of stabiliser used in the circuit, either :xzzx or :standard.\ngate_type::Symbol: Type of two-qubit gate used in the circuit, either :cx or :cz.\ndynamically_decouple::Bool: Whether to dynamically decouple the circuit; true is currently only supported for :xzzx and :cz.\nancilla_measurement::Bool: Whether to include mid-circuit ancilla measurements.\npad_identity::Bool: Whether to pad layers with single-qubit identity gates.\nlayer_time_dict::Dict{Symbol, Float64}: Dictionary of layer times.\n\n\n\n\n\n","category":"type"},{"location":"internal/circuits/rotated_planar/#QuantumACES.get_circuit-Union{Tuple{T}, Tuple{RotatedPlanarParameters, T}} where T<:AbstractNoiseParameters","page":"circuits/rotated_planar.jl","title":"QuantumACES.get_circuit","text":"get_circuit(rotated_param::RotatedPlanarParameters, noise_param::AbstractNoiseParameters; kwargs...)\n\nReturns a rotated planar code syndrome extraction circuit in the form of a Circuit object parameterised by the supplied circuit and noise parameters.\n\nArguments\n\nrotated_param::RotatedPlanarParameters: Parameters for a rotated planar code.\nnoise_param::AbstractNoiseParameters: Noise parameters for the circuit.\n\nKeyword arguments\n\nnoisy_prep::Bool = false: Whether to treat preparations as noisy and characterise the associated noise, defaulting to false; a full-rank design cannot be produced if both noisy_prep and noisy_meas are true.\nnoisy_meas::Bool = true: Whether to treat measurements as noisy and characterise the associated noise, defaulting to true; a full-rank design cannot be produced if both noisy_prep and noisy_meas are true.\ncombined::Bool = haskey(noise_param.params, :combined) ? noise_param.params[:combined] : false,: Whether to treat Pauli X, Y, and Z basis SPAM noise as the same.\nstrict::Bool = false: Whether to be strict about which gates count as estimable to relative precision.\n\n\n\n\n\n","category":"method"},{"location":"internal/circuits/rotated_planar/#QuantumACES.get_rotated_param-Tuple{Integer, Integer}","page":"circuits/rotated_planar.jl","title":"QuantumACES.get_rotated_param","text":"get_rotated_param(vertical_dist::Integer, horizontal_dist::Integer; kwargs...)\nget_rotated_param(dist::Integer; kwargs...)\n\nReturns a RotatedPlanarParameters object that parameterises the syndrome extraction circuit of a rotated planar code.\n\nDefault gate layer times are estimated from Suppressing quantum errors by scaling a surface code logical qubit by Google Quantum AI (2023).\n\nArguments\n\nvertical_dist::Int: Vertical (Z) distance of the code.\nhorizontal_dist::Int: Horizontal (X) distance of the code.\ndist::Int: Distance of the code; this is equivalent to setting vertical_dist = dist and horizontal_dist = dist.\n\nKeyword arguments\n\ncheck_type::Symbol = :xzzx: Type of stabiliser used in the circuit, either :xzzx or :standard.\ngate_type::Symbol = :cz: Type of two-qubit gate used in the circuit, either :cx or :cz.\ndynamically_decouple::Bool = true: Whether to dynamically decouple the circuit; true is currently only supported for :xzzx and :cz.\nancilla_measurement::Bool = true: Whether to include mid-circuit reset.\npad_identity::Bool = true: Whether to pad layers with single-qubit identity gates.\nsingle_qubit_time::Real = 29: Time taken to implement a single-qubit gate in nanoseconds.\ntwo_qubit_time::Real = 29: Time taken to implement a two-qubit gate in nanoseconds.\nmeas_reset_time::Real = 660: Time taken to perform measurement and reset at the end of the circuit in nanoseconds.\ndynamical_decoupling_time::Real = 29: Time taken to implement a dynamical decoupling layer in nanoseconds.\nmid_reset_time::Real = 660: Time taken to perform mid-circuit reset in nanoseconds.\n\n\n\n\n\n","category":"method"},{"location":"internal/circuits/rotated_planar/#Private-functions","page":"circuits/rotated_planar.jl","title":"Private functions","text":"","category":"section"},{"location":"internal/circuits/rotated_planar/","page":"circuits/rotated_planar.jl","title":"circuits/rotated_planar.jl","text":"Modules = [QuantumACES]\nPages = [\"src/circuits/rotated_planar.jl\"]\nPublic = false","category":"page"},{"location":"internal/circuits/rotated_planar/#QuantumACES.rotated_planar_circuit-Tuple{RotatedPlanarParameters}","page":"circuits/rotated_planar.jl","title":"QuantumACES.rotated_planar_circuit","text":"rotated_planar_circuit(rotated_param::RotatedPlanarParameters)\n\nReturns fields used to construct the syndrome extraction circuit of a rotated planar code based on the supplied parameters rotated_param.\n\n\n\n\n\n","category":"method"},{"location":"internal/noises/lognormal/","page":"noises/lognormal.jl","title":"noises/lognormal.jl","text":"CollapsedDocStrings = true","category":"page"},{"location":"internal/noises/lognormal/#lognormal.jl","page":"noises/lognormal.jl","title":"lognormal.jl","text":"","category":"section"},{"location":"internal/noises/lognormal/#Public-functions","page":"noises/lognormal.jl","title":"Public functions","text":"","category":"section"},{"location":"internal/noises/lognormal/","page":"noises/lognormal.jl","title":"noises/lognormal.jl","text":"Modules = [QuantumACES]\nPages = [\"src/noises/lognormal.jl\"]\nPrivate = false","category":"page"},{"location":"internal/noises/lognormal/#QuantumACES.LognormalParameters","page":"noises/lognormal.jl","title":"QuantumACES.LognormalParameters","text":"LognormalParameters\n\nParameterises a log-normally random Pauli noise model.\n\nFields\n\nparams::Dict{Symbol, Any}: Dictionary of the noise parameters described below.\nnoise_name::String: Noise parameter name for saving data.\n\nParameters\n\nr_1::Float64: Average single-qubit gate entanglement infidelity, the sum of all 3 non-identity Pauli error probabilities.\nr_2::Float64: Average two-qubit gate entanglement infidelity, the sum of all 15 non-identity Pauli error probabilities.\nr_m::Float64: Average measurement error probability.\nr_im::Float64: Average mid-circuit measurement idle entanglement infidelity.\nr_r::Float64: Average mid-circuit reset error probability.\nr_1_std_log::Float64: Approximate standard deviation of the logarithm of the single-qubit gate entanglement infidelity.\nr_2_std_log::Float64: Approximate standard deviation of the logarithm of the two-qubit gate entanglement infidelity.\nr_m_std_log::Float64: Approximate standard deviation of the logarithm of the measurement error probability.\nr_im_std_log::Float64: Approximate standard deviation of the logarithm of the mid-circuit measurement idle entanglement infidelity.\nr_r_std_log::Float64: Approximate standard deviation of the logarithm of the mid-circuit reset error probability.\nseed::UInt64: Random seed used to generate the noise.\ncombined::Bool: Whether to treat Pauli X, Y, and Z basis SPAM noise as the same.\n\n\n\n\n\n","category":"type"},{"location":"internal/noises/lognormal/#QuantumACES.get_log_param-Tuple{}","page":"noises/lognormal.jl","title":"QuantumACES.get_log_param","text":"get_log_param(r_1::Real, r_2::Real, r_m::Real, std_log::Real; seed::Union{UInt64, Nothing} = nothing, combined::Bool = false)\nget_log_param(; r_1::Real, r_2::Real, r_m::Real, r_im::Real = r_m, r_r::Real = r_m, r_1_std_log::Real, r_2_std_log::Real, r_m_std_log::Real, r_im_std_log::Real = r_m_std_log, r_r_std_log::Real = r_m_std_log, seed::Union{UInt64, Nothing} = nothing, combined::Bool = false)\n\nReturn a LognormalParameters object that parameterises a log-normally distributed random Pauli noise model.\n\nOptionally specify all standard deviations as std_log.\n\nArguments\n\nr_1::Float64: Average single-qubit gate entanglement infidelity, the sum of all 3 non-identity Pauli error probabilities.\nr_2::Float64: Average two-qubit gate entanglement infidelity, the sum of all 15 non-identity Pauli error probabilities.\nr_m::Float64: Average measurement error probability.\nr_im::Float64: Average mid-circuit measurement idle entanglement infidelity.\nr_r::Float64: Average mid-circuit reset error probability.\nr_1_std_log::Float64: Approximate standard deviation of the logarithm of the single-qubit gate entanglement infidelity.\nr_2_std_log::Float64: Approximate standard deviation of the logarithm of the two-qubit gate entanglement infidelity.\nr_m_std_log::Float64: Approximate standard deviation of the logarithm of the measurement error probability.\nr_im_std_log::Float64: Approximate standard deviation of the logarithm of the mid-circuit measurement idle entanglement infidelity.\nr_r_std_log::Float64: Approximate standard deviation of the logarithm of the mid-circuit reset error probability.\nseed::UInt64: Random seed used to generate the noise.\ncombined::Bool: Whether to treat Pauli X, Y, and Z basis SPAM noise as the same.\n\n\n\n\n\n","category":"method"},{"location":"internal/noises/lognormal/#QuantumACES.init_gate_probabilities-Tuple{Vector{Gate}, LognormalParameters}","page":"noises/lognormal.jl","title":"QuantumACES.init_gate_probabilities","text":"init_gate_probabilities(total_gates::Vector{Gate}, log_param::LognormalParameters)\n\nReturns a dictionary of the Pauli error probabilities for each gate in total_gates generated according to the noise parameters log_param, ordered lexicographically following get_paulis.\n\n\n\n\n\n","category":"method"},{"location":"internal/noises/lognormal/#Private-functions","page":"noises/lognormal.jl","title":"Private functions","text":"","category":"section"},{"location":"internal/noises/lognormal/","page":"noises/lognormal.jl","title":"noises/lognormal.jl","text":"Modules = [QuantumACES]\nPages = [\"src/noises/lognormal.jl\"]\nPublic = false","category":"page"},{"location":"internal/rand_design/","page":"rand_design.jl","title":"rand_design.jl","text":"CollapsedDocStrings = true","category":"page"},{"location":"internal/rand_design/#rand_design.jl","page":"rand_design.jl","title":"rand_design.jl","text":"","category":"section"},{"location":"internal/rand_design/#Public-functions","page":"rand_design.jl","title":"Public functions","text":"","category":"section"},{"location":"internal/rand_design/","page":"rand_design.jl","title":"rand_design.jl","text":"Modules = [QuantumACES]\nPages = [\"src/rand_design.jl\"]\nPrivate = false","category":"page"},{"location":"internal/rand_design/#QuantumACES.RandDesign","page":"rand_design.jl","title":"QuantumACES.RandDesign","text":"RandDesign\n\nPauli frame randomised experimental ensemble for an experimental design.\n\nFields\n\nd::Design: Experimental design.\npauli_randomisation_ensemble::Vector{Vector{Vector{Vector{String}}}}: For each tuple, experiment, and randomisation, a vector of Pauli frame randomisations between each layer in the randomised circuit.\npauli_sign_ensemble::Vector{Vector{Vector{Vector{Bool}}}}: For each tuple, experiment, and randomisation, a vector of signs for the Paulis estimated by the randomised experiment.\ncovariance_pauli_sign_ensemble::Vector{Vector{Vector{Vector{Bool}}}}: For each tuple, experiment, and randomisation, a vector of signs for the covariance Paulis estimated by the randomised experiment.\njob_indices::Vector{Vector{NTuple{3, Int}}}: For each job, a vector of indices (tuple, experiment, randomisation) for each circuit in the job.\nrandomisations::Vector{Int}: Number of randomisations for the experiment set corresponding to each tuple in the design.\nshot_budget::Int: Shot budget for the randomised experimental ensemble.\nexperiment_shots::Int: Number of shots for each experiment in the randomised experimental ensemble.\nseed::UInt64: Random seed used to generate the randomised experimental ensemble.\n\n\n\n\n\n","category":"type"},{"location":"internal/rand_design/#QuantumACES.generate_rand_design-Tuple{Design, Vector{Int64}, Integer, Integer}","page":"rand_design.jl","title":"QuantumACES.generate_rand_design","text":"generate_rand_design(d::Design, randomisations::Vector{Int}, shot_budget::Integer, experiment_shots::Integer; kwargs...)\ngenerate_rand_design(d::Design, min_randomisations::Integer, target_shot_budget::Integer, experiment_shots::Integer; kwargs...)\n\nReturns a RandDesign object describing a Pauli frame randomised experimental ensemble for the design d. Supply either the number of randomisations randomisations and shot budget shot_budget output by get_randomisations, as well as the number of shots for each experiment experiment_shots, or the arguments of that function, namely the minimum number of randomisations min_randomisations, target shot budget target_shot_budget, and number of shots for each experiment experiment_shots.\n\nArguments\n\nd::Design: Experimental design.\nrandomisations::Vector{Int}: Number of randomisations for each tuple in the design.\nshot_budget::Integer: Shot budget for the randomised experimental ensemble.\nmin_randomisations::Integer: Minimum number of randomisations for each tuple in the design.\ntarget_shot_budget::Integer: Target shot budget for the randomised experimental ensemble.\nexperiment_shots::Integer: Number of shots for each experiment in the randomised experimental ensemble.\n\nKeyword arguments\n\njob_circuit_number::Integer = 200: Number of circuits in each job.\nseed::Union{UInt64, Nothing} = nothing: Random seed for the randomisation.\ndiagnostics::Bool = false: Whether to print diagnostics.\nsave_data::Bool = false: Whether to save the randomised design.\n\n\n\n\n\n","category":"method"},{"location":"internal/rand_design/#QuantumACES.get_design-Tuple{RandDesign}","page":"rand_design.jl","title":"QuantumACES.get_design","text":"get_design(d_rand::RandDesign)\n\nReturns the design corresponding to the randomised design d_rand.\n\n\n\n\n\n","category":"method"},{"location":"internal/rand_design/#QuantumACES.get_meas_budget-Tuple{RandDesign}","page":"rand_design.jl","title":"QuantumACES.get_meas_budget","text":"get_meas_budget(d_rand::RandDesign)\n\nReturns the measurement budget corresponding to the randomised design d_rand.\n\n\n\n\n\n","category":"method"},{"location":"internal/rand_design/#QuantumACES.get_randomisations-Tuple{Design, Integer, Integer, Integer}","page":"rand_design.jl","title":"QuantumACES.get_randomisations","text":"get_randomisations(d::Design, min_randomisations::Integer, target_shot_budget::Integer, experiment_shots::Integer; p_norm::Real = 2)\n\nReturns the number of randomisations for each tuple in the experimental design d, given a target shot budget target_shot_budget, number of shots for each experiment experiment_shots, and minimum number of randomisations min_randomisations. The number of randomisations is greedily optimised to minimise the p_norm-norm to the shot weights associated with the experimental design.\n\nTypically, the 2-norm works better for smaller shot budgets, and the 1-norm works better for larger shot budgets. The number of randomisations corresponds to unnormalised shot weights randomisations .* d.experiment_numbers.\n\n\n\n\n\n","category":"method"},{"location":"internal/rand_design/#QuantumACES.get_stim_qiskit_ensemble-Tuple{RandDesign, Integer, Vector{Int64}}","page":"rand_design.jl","title":"QuantumACES.get_stim_qiskit_ensemble","text":"get_stim_qiskit_ensemble(d_rand::RandDesign, qiskit_qubit_num::Integer, qiskit_qubit_map::Vector{Int})\n\nReturns the Stim and Qiskit circuits for the randomised ensemble d_rand.\n\nThe Qiskit circuits act on qiskit_qubit_num qubits, which in general must be at least maximum(qiskit_qubit_map) + 1, and the mapping of the qubits upon which the circuits act to the qubits in the Qiskit circuits is controlled by qiskit_qubit_map, which is a vector whose length is the number of qubits upon which the circuits act.\n\n\n\n\n\n","category":"method"},{"location":"internal/rand_design/#Private-functions","page":"rand_design.jl","title":"Private functions","text":"","category":"section"},{"location":"internal/rand_design/","page":"rand_design.jl","title":"rand_design.jl","text":"Modules = [QuantumACES]\nPages = [\"src/rand_design.jl\"]\nPublic = false","category":"page"},{"location":"internal/rand_design/#QuantumACES.append_qiskit!-Tuple{PythonCall.Core.Py, Layer, Vector{Int64}}","page":"rand_design.jl","title":"QuantumACES.append_qiskit!","text":"append_qiskit!(qiskit_circuit::Py, l::Layer, qiskit_qubit_map::Vector{Int})\n\nAppends the gates in the layer l to the Qiskit circuit qiskit_circuit, using the mapping to Qiskit qubits given by qiskit_qubit_map.\n\n\n\n\n\n","category":"method"},{"location":"internal/rand_design/#QuantumACES.append_qiskit_gate!-Tuple{Any, String, Vector{Vector{Int64}}}","page":"rand_design.jl","title":"QuantumACES.append_qiskit_gate!","text":"append_qiskit_gate!(qiskit_circuit, gate_type::String, gate_targets::Vector{Vector{Int}})\n\nAppends the gates of the type gate_type to the Qiskit circuit qiskit_circuit with the targets specified by gate_targets.\n\n\n\n\n\n","category":"method"},{"location":"internal/rand_design/#QuantumACES.calc_mapping_signs-Tuple{Vector{Mapping}, Vector{Layer}}","page":"rand_design.jl","title":"QuantumACES.calc_mapping_signs","text":"calc_mapping_signs(experiment_mappings::Vector{Mapping}, randomised_circuit::Vector{Layer})\n\nReturns the signs of the Paulis corresponding to the mappings in experiment_mappings for the randomised circuit randomised_circuit.\n\n\n\n\n\n","category":"method"},{"location":"internal/rand_design/#QuantumACES.get_pauli_layer-Tuple{String, Int16}","page":"rand_design.jl","title":"QuantumACES.get_pauli_layer","text":"get_pauli_layer(pauli_string::String, n::Int16)\n\nReturns a layer of Pauli gates corresponding to the supplied Pauli string pauli_string on n qubits.`\n\n\n\n\n\n","category":"method"},{"location":"internal/rand_design/#QuantumACES.get_randomised_circuit-Tuple{Layer, Vector{Layer}, Layer, Vector{String}}","page":"rand_design.jl","title":"QuantumACES.get_randomised_circuit","text":"get_randomised_circuit(prep_layer::Layer, tuple_circuit::Vector{Layer}, meas_layer::Layer, pauli_randomisation::Vector{String})\n\nReturns the randomised circuit corresponding to the preparation layer prep_layer, tuple circuit tuple_circuit, measurement layer meas_layer, interspersed with the Pauli frame randomisation layers specified by pauli_randomisation.\n\n\n\n\n\n","category":"method"},{"location":"internal/rand_design/#QuantumACES.get_stim_qiskit_circuit-Tuple{Vector{Layer}, Dict{Gate, Vector{Float64}}, Integer, Vector{Int64}, Bool, Bool}","page":"rand_design.jl","title":"QuantumACES.get_stim_qiskit_circuit","text":"get_stim_qiskit_circuit(randomised_circuit::Vector{Layer}, gate_probabilities::Dict{Gate, Vector{Float64}}, qiskit_qubit_num::Integer, qiskit_qubit_map::Vector{Int}, noisy_prep::Bool, noisy_meas::Bool; extra_fields::Dict{Symbol, Any} = Dict{Symbol, Any}())\n\nGenerate the Stim circuit string and Qiskit circuit for a Pauli frame randomised circuit randomised_circuit.\n\nThe Stim circuit features noise on each of the non-randomisation gates specified by gate_probabilities, as well as noisy preparations if noisy_prep is true, and noisy measurements if noisy_meas is true. Qubit coordinates are specified by extra_fields if it contains a CodeParameters object.\n\nThe Qiskit circuit acts on qiskit_qubit_num qubits, which in general must be at least maximum(qiskit_qubit_map) + 1, and the mapping of the qubits upon which the circuit acts to the qubits in the Qiskit circuit is controlled by qiskit_qubit_map, which is a vector whose length is the number of qubits upon which the circuit acts.\n\n\n\n\n\n","category":"method"},{"location":"internal/noise/","page":"noise.jl","title":"noise.jl","text":"CollapsedDocStrings = true","category":"page"},{"location":"internal/noise/#noise.jl","page":"noise.jl","title":"noise.jl","text":"","category":"section"},{"location":"internal/noise/#Public-functions","page":"noise.jl","title":"Public functions","text":"","category":"section"},{"location":"internal/noise/","page":"noise.jl","title":"noise.jl","text":"Modules = [QuantumACES]\nPages = [\"src/noise.jl\"]\nPrivate = false","category":"page"},{"location":"internal/noise/#QuantumACES.GateData","page":"noise.jl","title":"QuantumACES.GateData","text":"GateData\n\nAn object that stores all of the gate indices and data.\n\nFields\n\ngate_indices::Vector{GateIndex}: Indices for all gates.\nG::Int32: Number of gates.\nN::Int32: Number of indices.\nN_pad::Int32: Number of padded indices.\nN_marginal::Int32: Number of marginal indices.\nN_pad_marginal::Int32: Number of padded marginal indices.\nN_relative::Int32: Number of relative indices.\nN_pad_relative::Int32: Number of padded relative indices.\ncombined::Bool: Whether to treat Pauli X, Y, and Z basis SPAM noise as the same.\nstrict::Bool: Whether to be strict about whether gates are deemed to be estimable to additive or relative precision.\n\n\n\n\n\n","category":"type"},{"location":"internal/noise/#QuantumACES.GateIndex","page":"noise.jl","title":"QuantumACES.GateIndex","text":"GateIndex\n\nAn object that stores all of the different indices of a gate.\n\nFields\n\ngate::Gate: The gate.\nindices::Vector{Int32}: Gate eigenvalue or probability indices.\npad_indices::Vector{Int32}: Padded gate eigenvalue or probability indices.\nmarg_indices::Vector{Int32}: Marginal gate eigenvalue or probability indices.\npad_marg_indices::Vector{Int32}: Padded marginal gate eigenvalue or probability indices.\nrel_indices::Vector{Int32}: Relative gate eigenvalue or probability indices.\npad_rel_indices::Vector{Int32}: Padded relative gate eigenvalue or probability indices.\n\n\n\n\n\n","category":"type"},{"location":"internal/noise/#QuantumACES.get_average_gate_probabilities-Tuple{Dict{Gate, Vector{Float64}}}","page":"noise.jl","title":"QuantumACES.get_average_gate_probabilities","text":"get_average_gate_probabilities(gate_probabilities::Dict{Gate, Vector{Float64}})\nget_average_gate_probabilities(gate_probabilities::Dict{Gate, Vector{Float64}}, gate_data::GateData)\n\nReturns the averaged gate probabilities obtained from the gate probabilities gate_probabilities by averaging error probabilities within the orbits of each of the gates.\n\n\n\n\n\n","category":"method"},{"location":"internal/noise/#QuantumACES.get_combined_gate_probabilities-Tuple{Dict{Gate, Vector{Float64}}, GateData}","page":"noise.jl","title":"QuantumACES.get_combined_gate_probabilities","text":"get_combined_gate_probabilities(gate_probabilities::Dict{Gate, Vector{Float64}}, gate_data::GateData)\n\nReturns the combined gate probabilities obtained from the gate probabilities gate_probabilities by averaging SPAM noise parameters on each qubit, calculated using combined gate data gate_data.\n\n\n\n\n\n","category":"method"},{"location":"internal/noise/#QuantumACES.get_full_average_gate_probabilities-Tuple{Dict{Gate, Vector{Float64}}}","page":"noise.jl","title":"QuantumACES.get_full_average_gate_probabilities","text":"get_full_average_gate_probabilities(gate_probabilities::Dict{Gate, Vector{Float64}})\nget_full_average_gate_probabilities(gate_probabilities::Dict{Gate, Vector{Float64}}, gate_data::GateData)\n\nReturns the fully averaged gate probabilities obtained from the gate probabilities gate_probabilities by averaging all error probabilities within each of the gates.\n\n\n\n\n\n","category":"method"},{"location":"internal/noise/#QuantumACES.get_gate_data-Tuple{Vector{Gate}}","page":"noise.jl","title":"QuantumACES.get_gate_data","text":"get_gate_data(total_gates::Vector{Gate}; combined::Bool = false, strict::Bool = false)\n\nReturns the gate data for the gates total_gates in the form of a GateData object, combining Pauli X, Y, and Z basis SPAM noise if combined is true, and being strict about which gates count as estimable to additive or relative precision if strict is true.\n\n\n\n\n\n","category":"method"},{"location":"internal/noise/#QuantumACES.get_gate_eigenvalues-Tuple{Dict{Gate, Vector{Float64}}, GateData}","page":"noise.jl","title":"QuantumACES.get_gate_eigenvalues","text":"get_gate_eigenvalues(gate_probabilities::Dict{Gate, Vector{Float64}}, gate_data::GateData)\n\nReturns the gate eigenvalues for the gate probabilities gate_probabilities calculated using the gate data gate_data.\n\n\n\n\n\n","category":"method"},{"location":"internal/noise/#QuantumACES.get_gate_probabilities-Tuple{Vector{Float64}, GateData}","page":"noise.jl","title":"QuantumACES.get_gate_probabilities","text":"get_gate_probabilities(gate_eigenvalues::Vector{Float64}, gate_data::GateData)\n\nReturns the gate probabilities for the gate eigenvalues gate_eigenvalues calculated using the gate data gate_data.\n\n\n\n\n\n","category":"method"},{"location":"internal/noise/#QuantumACES.get_marginal_gate_eigenvalues-Tuple{Vector{Float64}, GateData}","page":"noise.jl","title":"QuantumACES.get_marginal_gate_eigenvalues","text":"get_marginal_gate_eigenvalues(gate_eigenvalues::Vector{Float64}, gate_data::GateData)\n\nReturns the marginal gate eigenvalues corresponding to the gate eigenvalues gate_eigenvalues calculated using the gate data gate_data.\n\n\n\n\n\n","category":"method"},{"location":"internal/noise/#QuantumACES.get_marginal_gate_probabilities-Tuple{Dict{Gate, Vector{Float64}}}","page":"noise.jl","title":"QuantumACES.get_marginal_gate_probabilities","text":"get_marginal_gate_probabilities(gate_probabilities::Dict{Gate, Vector{Float64}})\nget_marginal_gate_probabilities(gate_probabilities::Dict{Gate, Vector{Float64}}, gate_data::GateData)\n\nReturns the marginal gate probabilities obtained from the gate probabilities gate_probabilities by marginalising error probabilities across the orbits of each of the gates.\n\n\n\n\n\n","category":"method"},{"location":"internal/noise/#QuantumACES.get_marginal_wht_matrix-Tuple{Gate}","page":"noise.jl","title":"QuantumACES.get_marginal_wht_matrix","text":"get_marginal_wht_matrix(gate::Gate; inverse::Bool = false)\n\nReturns the symplectically ordered Walsh-Hadamard transform matrix for the gate gate, marginalised over gate orbits, which maps the marginal Pauli error probability distribution to its marginal eigenvalues, or the inverse transform if inverse is true.\n\n\n\n\n\n","category":"method"},{"location":"internal/noise/#QuantumACES.get_orbit_indices_dict-Tuple{}","page":"noise.jl","title":"QuantumACES.get_orbit_indices_dict","text":"get_orbit_indices_dict()\n\nReturns a hard-coded dictionary of the Pauli orbit indices for each gate type, tested by comparing the results to get_orbit_indices.\n\n\n\n\n\n","category":"method"},{"location":"internal/noise/#QuantumACES.get_pad_transform-Tuple{GateData}","page":"noise.jl","title":"QuantumACES.get_pad_transform","text":"get_pad_transform(gate_data::GateData; probabilities::Bool = false)\n\nReturns a transform matrix that pads gate eigenvalues, or gate error probabilities if probabilities is true, with identity eigenvaleus or error probabilities respectively, up to a constant given by get_pad_mask, calculated using the gate data gate_data.\n\n\n\n\n\n","category":"method"},{"location":"internal/noise/#QuantumACES.get_relative_gate_eigenvalues-Tuple{Vector{Float64}, GateData}","page":"noise.jl","title":"QuantumACES.get_relative_gate_eigenvalues","text":"get_relative_gate_eigenvalues(gate_eigenvalues::Vector{Float64}, gate_data::GateData)\n\nReturns the marginal gate eigenvalues for gates estimable to relative precision corresponding to the gate eigenvalues gate_eigenvalues calculated using the gate data gate_data.\n\n\n\n\n\n","category":"method"},{"location":"internal/noise/#QuantumACES.get_relative_gate_probabilities-Tuple{Dict{Gate, Vector{Float64}}, GateData}","page":"noise.jl","title":"QuantumACES.get_relative_gate_probabilities","text":"get_relative_gate_probabilities(gate_probabilities::Dict{Gate, Vector{Float64}}, gate_data::GateData)\n\nReturns the marginal gate probabilities obtained from the gate probabilities gate_probabilities by marginalising error probabilities across the orbits of each of the gates which are estimable to relative precision.\n\n\n\n\n\n","category":"method"},{"location":"internal/noise/#QuantumACES.get_wht_matrix-Tuple{Integer}","page":"noise.jl","title":"QuantumACES.get_wht_matrix","text":"get_wht_matrix(n::Integer; inverse::Bool = false)\nget_wht_matrix(gate::Gate; inverse::Bool = false)\n\nReturns the symplectically ordered Walsh-Hadamard transform matrix of order n, the number of qubits on which the gate gate acts, which maps an n-qubit Pauli error probability distribution to its eigenvalues, or the inverse transform if inverse is true.\n\n\n\n\n\n","category":"method"},{"location":"internal/noise/#QuantumACES.get_wht_transform-Tuple{GateData}","page":"noise.jl","title":"QuantumACES.get_wht_transform","text":"get_wht_transform(gate_data::GateData; inverse::Bool = false)\n\nReturns a transform matrix that maps padded gate error probabilities to padded gate eigenvalues, or the inverse transform if inverse is true, calculated using the gate data gate_data.\n\n\n\n\n\n","category":"method"},{"location":"internal/noise/#Private-functions","page":"noise.jl","title":"Private functions","text":"","category":"section"},{"location":"internal/noise/","page":"noise.jl","title":"noise.jl","text":"Modules = [QuantumACES]\nPages = [\"src/noise.jl\"]\nPublic = false","category":"page"},{"location":"internal/noise/#QuantumACES.get_gate_index_dict-Tuple{GateData}","page":"noise.jl","title":"QuantumACES.get_gate_index_dict","text":"get_gate_index_dict(gate_data::GateData)\n\nReturns a dictionary that maps each gate to its index.\n\n\n\n\n\n","category":"method"},{"location":"internal/noise/#QuantumACES.get_gate_probabilities_dict-Tuple{Vector{Float64}, GateData}","page":"noise.jl","title":"QuantumACES.get_gate_probabilities_dict","text":"get_gate_probabilities_dict(gate_probabilities_vec::Vector{Float64}, gate_data::GateData)\n\nReturns the gate probabilities dictionary obtained from the corresponding vector gate_probabilities_vec calculated using the gate data gate_data.\n\n\n\n\n\n","category":"method"},{"location":"internal/noise/#QuantumACES.get_gate_probabilities_vec-Tuple{Dict{Gate, Vector{Float64}}, GateData}","page":"noise.jl","title":"QuantumACES.get_gate_probabilities_vec","text":"get_gate_probabilities_vec(gate_probabilities::Dict{Gate, Vector{Float64}}, gate_data::GateData)\n\nReturns the gate probabilities vector obtained from the corresponding dictionary gate_probabilities calculated using the gate data gate_data.\n\n\n\n\n\n","category":"method"},{"location":"internal/noise/#QuantumACES.get_marginal_gate_probabilities_dict-Tuple{Vector{Float64}, GateData}","page":"noise.jl","title":"QuantumACES.get_marginal_gate_probabilities_dict","text":"get_marginal_gate_probabilities_dict(marginal_gate_probabilities_vec::Vector{Float64}, gate_data::GateData)\n\nReturns the marginal gate probabilities dictionary obtained from the corresponding vector marginal_gate_probabilities_vec calculated using the gate data gate_data.\n\n\n\n\n\n","category":"method"},{"location":"internal/noise/#QuantumACES.get_marginal_gate_probabilities_vec-Tuple{Dict{Gate, Vector{Float64}}, GateData}","page":"noise.jl","title":"QuantumACES.get_marginal_gate_probabilities_vec","text":"get_marginal_gate_probabilities_vec(marginal_gate_probabilities::Dict{Gate, Vector{Float64}}, gate_data::GateData)\n\nReturns the marginal gate probabilities vector obtained from the corresponding dictionary marginal_gate_probabilities calculated using the gate data gate_data.\n\n\n\n\n\n","category":"method"},{"location":"internal/noise/#QuantumACES.get_marginal_pad_mask-Tuple{GateData}","page":"noise.jl","title":"QuantumACES.get_marginal_pad_mask","text":"get_marginal_pad_mask(gate_data::GateData)\n\nReturns a mask vector that sets the values of the identity marginal gate eigenvalues or marginal gate error probabilites, calculated using the gate data gate_data.\n\n\n\n\n\n","category":"method"},{"location":"internal/noise/#QuantumACES.get_marginal_pad_transform-Tuple{GateData}","page":"noise.jl","title":"QuantumACES.get_marginal_pad_transform","text":"get_marginal_pad_transform(gate_data::GateData; probabilities::Bool = false)\n\nReturns a transform matrix that pads marginal gate eigenvalues, or marginal gate error probabilities if probabilities is true, with identity eigenvaleus or error probabilities respectively, up to a constant given by get_marginal_pad_mask, calculated using the gate data gate_data.\n\n\n\n\n\n","category":"method"},{"location":"internal/noise/#QuantumACES.get_marginal_transform-Tuple{GateData}","page":"noise.jl","title":"QuantumACES.get_marginal_transform","text":"get_marginal_transform(gate_data::GateData)\n\nReturns a transform matrix that maps gate eigenvalues to marginal gate eigenvalues, calculated using the gate data gate_data.\n\n\n\n\n\n","category":"method"},{"location":"internal/noise/#QuantumACES.get_marginal_wht_transform-Tuple{GateData}","page":"noise.jl","title":"QuantumACES.get_marginal_wht_transform","text":"get_marginal_wht_transform(gate_data::GateData; inverse::Bool = false)\n\nReturns a transform matrix that maps padded marginal gate error probabilities to padded marginal gate eigenvalues, or the inverse transform if inverse is true, calculated using the gate data gate_data.\n\n\n\n\n\n","category":"method"},{"location":"internal/noise/#QuantumACES.get_ordinary_transform-Tuple{GateData}","page":"noise.jl","title":"QuantumACES.get_ordinary_transform","text":"get_ordinary_transform(gate_data::GateData)\n\nReturns an identity transform matrix that maps gate eigenvalues to themselves, calculated using the gate data gate_data.\n\n\n\n\n\n","category":"method"},{"location":"internal/noise/#QuantumACES.get_pad_mask-Tuple{GateData}","page":"noise.jl","title":"QuantumACES.get_pad_mask","text":"get_pad_mask(gate_data::GateData)\n\nReturns a mask vector that sets the values of the identity gate eigenvalues or gate error probabilites, calculated using the gate data gate_data.\n\n\n\n\n\n","category":"method"},{"location":"internal/noise/#QuantumACES.get_relative_gate_probabilities_dict-Tuple{Vector{Float64}, GateData}","page":"noise.jl","title":"QuantumACES.get_relative_gate_probabilities_dict","text":"get_relative_gate_probabilities_dict(relative_gate_probabilities_vec::Vector{Float64}, gate_data::GateData)\n\nReturns the marginal gate probabilities dictionary for those gates estimable to relative precision obtained from the corresponding vector relative_gate_probabilities_vec calculated using the gate data gate_data.\n\n\n\n\n\n","category":"method"},{"location":"internal/noise/#QuantumACES.get_relative_gate_probabilities_vec-Tuple{Dict{Gate, Vector{Float64}}, GateData}","page":"noise.jl","title":"QuantumACES.get_relative_gate_probabilities_vec","text":"get_relative_gate_probabilities_vec(relative_gate_probabilities::Dict{Gate, Vector{Float64}}, gate_data::GateData)\n\nReturns the marginal gate probabilities vector for those gates estimable to relative precision obtained from the corresponding dictionary relative_gate_probabilities calculated using the gate data gate_data.\n\n\n\n\n\n","category":"method"},{"location":"internal/noise/#QuantumACES.get_relative_pad_mask-Tuple{GateData}","page":"noise.jl","title":"QuantumACES.get_relative_pad_mask","text":"get_relative_pad_mask(gate_data::GateData)\n\nReturns a mask vector that sets the values of the identity marginal gate eigenvalues for gates estimable to relative precision, calculated using the gate data gate_data.\n\n\n\n\n\n","category":"method"},{"location":"internal/noise/#QuantumACES.get_relative_pad_transform-Tuple{GateData}","page":"noise.jl","title":"QuantumACES.get_relative_pad_transform","text":"get_relative_pad_transform(gate_data::GateData; probabilities::Bool = false)\n\nReturns a transform matrix that pads marginal gate eigenvalues, or marginal gate error probabilities if probabilities is true, for gates estimable to relative precision, with identity eigenvaleus or error probabilities respectively, up to a constant given by get_relative_pad_mask, calculated using the gate data gate_data.\n\n\n\n\n\n","category":"method"},{"location":"internal/noise/#QuantumACES.get_relative_transform-Tuple{GateData}","page":"noise.jl","title":"QuantumACES.get_relative_transform","text":"get_relative_transform(gate_data::GateData)\n\nReturns a transform matrix that maps gate eigenvalues to the marginal gate eigenvalues for gates estimable to relative precision, calculated using the gate data gate_data.\n\n\n\n\n\n","category":"method"},{"location":"internal/noise/#QuantumACES.get_relative_wht_transform-Tuple{GateData}","page":"noise.jl","title":"QuantumACES.get_relative_wht_transform","text":"get_relative_wht_transform(gate_data::GateData; inverse::Bool = false)\n\nReturns a transform matrix that maps padded marginal gate error probabilities to padded marginal gate eigenvalues for gates estimable to relative precision, or the inverse transform if inverse is true, calculated using the gate data gate_data.\n\n\n\n\n\n","category":"method"},{"location":"creation/#Creating-Circuits-and-Noise-Models","page":"Creating Circuits and Noise Models","title":"Creating Circuits and Noise Models","text":"","category":"section"},{"location":"creation/","page":"Creating Circuits and Noise Models","title":"Creating Circuits and Noise Models","text":"QuantumACES makes it easy to create new circuits and noise models. At a high level, we create new parameter types for the circuit or noise model and then create new methods for the functions get_circuit and init_gate_probabilities, respectively, that take these parameter types as arguments. Then get_circuit uses the circuit and noise model parameters to create a Circuit object.","category":"page"},{"location":"creation/","page":"Creating Circuits and Noise Models","title":"Creating Circuits and Noise Models","text":"The Circuit object enables the functionality we saw in Example usage, with two exceptions. First, calculating performance predictions requires the circuit to be parameterised by a dist parameter, typically the distance of the code underlying the syndrome extraction circuit. Second, simulating memory experiments in Stim requires the circuit to be a syndrome extraction annotated with the appropriate information. The Circuit object contains an extra_fields field which is a dictionary that can store additional parameters to enable functionality such as this. In particular, syndrome extraction circuits must store a CodeParametersobject in this dictionary, which is then used to generate the detectors in Stim for memory experiment circuits, enabling decoding.","category":"page"},{"location":"creation/","page":"Creating Circuits and Noise Models","title":"Creating Circuits and Noise Models","text":"Let us begin by creating a new circuit, following the example circuit shown in Figure 2 of arXiv:2404.06545. The first step is to create a parameter object for the circuit, which must be a subtype of AbstractCircuitParameters and contain the necessary fields params and circuit_name, using the StructEquality package to automatically generate hash and equality relationships for the object to enable comparisons for the resulting Circuit objects.","category":"page"},{"location":"creation/","page":"Creating Circuits and Noise Models","title":"Creating Circuits and Noise Models","text":"using QuantumACES, StructEquality\nstruct ExampleParameters <: AbstractCircuitParameters\n    params::Dict{Symbol, Any}\n    circuit_name::String\n    # Default constructor\n    function ExampleParameters(params::Dict{Symbol, Any}, circuit_name::String)\n        # Check circuit parameters are present\n        @assert haskey(params, :pad_identity) \"The pad identity flag is missing.\"\n        @assert haskey(params, :layer_time_dict) \"The layer time dictionary is missing.\"\n        pad_identity = params[:pad_identity]\n        layer_time_dict = params[:layer_time_dict]\n        # Check some conditions\n        @assert haskey(layer_time_dict, :single_qubit) \"The layer time dictionary must contain the key :single_qubit.\"\n        @assert haskey(layer_time_dict, :two_qubit) \"The layer time dictionary must contain the key :two_qubit.\"\n        @assert haskey(layer_time_dict, :meas_reset) \"The layer time dictionary must contain the key :meas_reset.\"\n        @assert layer_time_dict[:single_qubit] > 0.0 \"The single-qubit layer time must be positive.\"\n        @assert layer_time_dict[:two_qubit] > 0.0 \"The two-qubit layer time must be positive.\"\n        @assert layer_time_dict[:meas_reset] > 0.0 \"The measurement and reset time must be positive.\"\n        # Set the circuit name\n        new_circuit_name = \"example_circuit\"\n        if pad_identity != true\n            circuit_name *= \"_no_pad_identity\"\n        end\n        # Return parameters\n        return new(params, new_circuit_name)::ExampleParameters\n    end\nend\n\n@struct_hash_equal_isequal ExampleParameters","category":"page"},{"location":"creation/","page":"Creating Circuits and Noise Models","title":"Creating Circuits and Noise Models","text":"We need a function to construct the parameter object.","category":"page"},{"location":"creation/","page":"Creating Circuits and Noise Models","title":"Creating Circuits and Noise Models","text":"function get_example_param(;\n    pad_identity = true,\n    single_qubit_time::Real = 29,\n    two_qubit_time::Real = 29,\n    meas_reset_time::Real = 660,\n)\n    # Construct the layer time dictionary\n    layer_time_dict = Dict{Symbol, Float64}(\n        :single_qubit => single_qubit_time,\n        :two_qubit => two_qubit_time,\n        :meas_reset => meas_reset_time,\n    )\n    # Construct the circuit parameters\n    params = Dict{Symbol, Any}(\n        :pad_identity => pad_identity,\n        :layer_time_dict => layer_time_dict,\n    )\n    # Return parameters\n    example_param = ExampleParameters(params, \"example_circuit\")\n    return example_param::ExampleParameters\nend","category":"page"},{"location":"creation/","page":"Creating Circuits and Noise Models","title":"Creating Circuits and Noise Models","text":"And we need a function to create the circuit from the parameter object.","category":"page"},{"location":"creation/","page":"Creating Circuits and Noise Models","title":"Creating Circuits and Noise Models","text":"function example_circuit(example_param::ExampleParameters)\n    # Set up variables\n    pad_identity = example_param.params[:pad_identity]\n    layer_time_dict = example_param.params[:layer_time_dict]\n    single_qubit_type = :single_qubit\n    two_qubit_type = :two_qubit\n    # Generate the circuit\n    qubit_num = 3\n    circuit = [\n        Layer([Gate(\"CZ\", 0, [2; 3])], qubit_num),\n        Layer([Gate(\"CZ\", 0, [1; 2]), Gate(\"H\", 0, [3])], qubit_num),\n        Layer([Gate(\"H\", 0, [1]), Gate(\"S\", 0, [2]), Gate(\"H\", 0, [3])], qubit_num),\n    ]\n    layer_types = [two_qubit_type, two_qubit_type, single_qubit_type]\n    layer_times = get_layer_times(layer_types, layer_time_dict)\n    extra_fields = Dict{Symbol, Any}()\n    # Pad each layer with identity gates if appropriate\n    if pad_identity\n        circuit = [pad_layer(l) for l in circuit]\n    end\n    return (\n        circuit::Vector{Layer},\n        layer_types::Vector{Symbol},\n        layer_times::Vector{Float64},\n        extra_fields::Dict{Symbol, Any},\n    )\nend","category":"page"},{"location":"creation/","page":"Creating Circuits and Noise Models","title":"Creating Circuits and Noise Models","text":"Finally, we create a function that generates the circuit in the form of a Circuit object. We do this by adding a method to get_circuit which uses the new parameter object as an argument, leveraging this circuit creation function.","category":"page"},{"location":"creation/","page":"Creating Circuits and Noise Models","title":"Creating Circuits and Noise Models","text":"function QuantumACES.get_circuit(\n    example_param::ExampleParameters,\n    noise_param::T;\n    noisy_prep::Bool = false,\n    noisy_meas::Bool = true,\n    combined::Bool = haskey(noise_param.params, :combined) ? noise_param.params[:combined] :\n                     false,\n    strict::Bool = false,\n) where {T <: AbstractNoiseParameters}\n    (circuit, layer_types, layer_times, extra_fields) = example_circuit(example_param)\n    c = get_circuit(\n        circuit,\n        layer_types,\n        layer_times,\n        noise_param;\n        circuit_param = example_param,\n        extra_fields = extra_fields,\n        noisy_prep = noisy_prep,\n        noisy_meas = noisy_meas,\n        combined = combined,\n        strict = strict,\n    )\n    return c::Circuit\nend","category":"page"},{"location":"creation/","page":"Creating Circuits and Noise Models","title":"Creating Circuits and Noise Models","text":"Circuit creation works similarly for more complicated circuits, such as the syndrome extraction circuits generated for RotatedPlanarParameters, UnrotatedPlanarParameters, and HeavyHexParameters. These each have specialised methods added to get_circuit which uses these parameter structs as arguments.","category":"page"},{"location":"creation/","page":"Creating Circuits and Noise Models","title":"Creating Circuits and Noise Models","text":"If you wish to add additional information to a Circuit object, store it in the extra_fields field, which for example can contain a CodeParameters object that enables the construction and simulation of a memory circuit through get_stim_memory_circuit and simulate_memory.","category":"page"},{"location":"creation/","page":"Creating Circuits and Noise Models","title":"Creating Circuits and Noise Models","text":"Next, we will create a phenomenological noise model where each Pauli error probability has some probability p of occurring, so that two-qubit errors have a probability p^2. As with the circuit, we begin by creating a parameter object for the noise model, which must be a subtype of AbstractNoiseParameters and contains the noise parameters in the necessary field params, as well as a name in the necessary field noise_name. Including a combined field in the noise model specifies to the circuit and experimental design whether to treat Pauli X, Y, and Z basis SPAM noise as the same.","category":"page"},{"location":"creation/","page":"Creating Circuits and Noise Models","title":"Creating Circuits and Noise Models","text":"struct PhenomenologicalParameters <: AbstractNoiseParameters\n    params::Dict{Symbol, Any}\n    noise_name::String\n    # Default constructor\n    function PhenomenologicalParameters(params::Dict{Symbol, Any}, noise_name::String)\n        # Check noise parameters are present\n        @assert haskey(params, :p) \"The phenomenological gate error probability is missing.\"\n        @assert haskey(params, :m) \"The measurement error probability is missing.\"\n        @assert haskey(params, :m_r) \"The measurement reset error probability is missing.\"\n        @assert haskey(params, :m_i) \"The measurement idle error probability is missing.\"\n        @assert haskey(params, :combined) \"The combined flag is missing.\"\n        p = params[:p]\n        m = params[:m]\n        m_r = params[:m_r]\n        m_i = params[:m_i]\n        combined = params[:combined]\n        # Check some conditions\n        @assert (p >= 0) && (p <= 1 / 10) \"The phenomenological gate error probability $(p) is out of bounds.\"\n        @assert (m >= 0) && (m <= 1 / 2) \"The phenomenological measurement error probability $(m) is out of bounds.\"\n        @assert (m_r >= 0) && (m_r <= 1 / 2) \"The phenomenological measurement reset error probability $(m_r) is out of bounds.\"\n        @assert (m_i >= 0) && (m_i <= 1 / 4) \"The phenomenological measurement idle error probability $(m_i) is out of bounds.\"\n        @assert typeof(combined) == Bool \"The combined flag $(combined) is not a Bool.\"\n        # Return parameters with the appropriate name\n        sigdigits = 3\n        new_noise_name = \"phenomenological_$(round(p; sigdigits = sigdigits))_$(round(m; sigdigits = sigdigits))_$(round(m_r; sigdigits = sigdigits))_$(round(m_i; sigdigits = sigdigits))_$(combined)\"\n        return new(params, new_noise_name)::PhenomenologicalParameters\n    end\nend","category":"page"},{"location":"creation/","page":"Creating Circuits and Noise Models","title":"Creating Circuits and Noise Models","text":"We need a function to construct the parameter object.","category":"page"},{"location":"creation/","page":"Creating Circuits and Noise Models","title":"Creating Circuits and Noise Models","text":"function get_phen_param(\n    p::Float64,\n    m::Float64;\n    m_r::Real = m,\n    m_i::Real = m / 3,\n    combined::Bool = false,\n)\n    params =\n        Dict{Symbol, Any}(:p => p, :m => m, :m_r => m_r, :m_i => m_i, :combined => combined)\n    phen_param = PhenomenologicalParameters(params, \"phenomenological\")\n    return phen_param::PhenomenologicalParameters\nend","category":"page"},{"location":"creation/","page":"Creating Circuits and Noise Models","title":"Creating Circuits and Noise Models","text":"And we need a function to create the noise model for a set of gates from the parameter object. As with the circuit, we add a method to init_gate_probabilities which uses the new parameter object as an argument.","category":"page"},{"location":"creation/","page":"Creating Circuits and Noise Models","title":"Creating Circuits and Noise Models","text":"function QuantumACES.init_gate_probabilities(\n    total_gates::Vector{Gate},\n    phen_param::PhenomenologicalParameters,\n)\n    # Set up variables\n    p = phen_param.params[:p]\n    m = phen_param.params[:m]\n    m_r = phen_param.params[:m_r]\n    m_i = phen_param.params[:m_i]\n    # Determine the weights of the Pauli errors\n    one_qubit_support_size = ones(3)\n    n = 2\n    two_qubit_support_size = Vector{Int}()\n    bit_array = BitArray(undef, 2n + 1)\n    for bit_array.chunks[1] in 1:(4^n - 1)\n        two_qubit_pauli = Pauli(convert(Vector{Bool}, bit_array), n)\n        push!(two_qubit_support_size, length(get_support(two_qubit_pauli)))\n    end\n    @assert sum(two_qubit_support_size .== 1) == 6\n    @assert sum(two_qubit_support_size .== 2) == 9\n    @assert length(two_qubit_support_size) == 15\n    # Generate the noise\n    gate_probabilities = Dict{Gate, Vector{Float64}}()\n    for gate in total_gates\n        if is_spam(gate)\n            gate_probs = [m]\n        elseif is_mid_meas_reset(gate)\n            gate_probs = [m_r]\n        elseif is_meas_idle(gate)\n            gate_probs = m_i .^ one_qubit_support_size\n        else\n            gate_support_size = length(gate.targets)\n            if gate_support_size == 1\n                gate_probs = p .^ one_qubit_support_size\n            elseif gate_support_size == 2\n                gate_probs = p .^ two_qubit_support_size\n            else\n                throw(error(\"The gate $(gate) is unsupported.\"))\n            end\n        end\n        @assert sum(gate_probs) < 1\n        gate_probabilities[gate] = [1 - sum(gate_probs); gate_probs]\n    end\n    return gate_probabilities::Dict{Gate, Vector{Float64}}\nend","category":"page"},{"location":"creation/","page":"Creating Circuits and Noise Models","title":"Creating Circuits and Noise Models","text":"Noise model creation should follow the form of this example, much like the noise models DepolarisingParameters and LognormalParameters.","category":"page"},{"location":"creation/","page":"Creating Circuits and Noise Models","title":"Creating Circuits and Noise Models","text":"Now we are ready to reprise the basic usage example for this example circuit. First, parameterise depolarising and phenomenological noise models.","category":"page"},{"location":"creation/","page":"Creating Circuits and Noise Models","title":"Creating Circuits and Noise Models","text":"p = 0.025 / 100\nm = 2.0 / 100\nr_1 = 0.075 / 100\nr_2 = 0.5 / 100\nr_m = 2.0 / 100\nphen_param = get_phen_param(p, m)\ndep_param = get_dep_param(r_1, r_2, r_m)","category":"page"},{"location":"creation/","page":"Creating Circuits and Noise Models","title":"Creating Circuits and Noise Models","text":"Then construct the circuit.","category":"page"},{"location":"creation/","page":"Creating Circuits and Noise Models","title":"Creating Circuits and Noise Models","text":"example_param = get_example_param()\ncircuit_example = get_circuit(example_param, dep_param)","category":"page"},{"location":"creation/","page":"Creating Circuits and Noise Models","title":"Creating Circuits and Noise Models","text":"The default optimisation target is the generalised least squares (GLS) estimator, as it performs best, even if it cannot be scaled up to very large numbers of qubits. This is not an issue here because because the circuit acts on only three qubits. QuantumACES is geared towards syndrome extraction circuits, which typically are performant when repeated an even number of times. This is not guaranteed for the example circuit, so we set add_circuit to be false, though note this is the default behaviour.","category":"page"},{"location":"creation/","page":"Creating Circuits and Noise Models","title":"Creating Circuits and Noise Models","text":"add_circuit = false\nrepeat_points = 3\nseed = UInt(0)\nd = optimise_design(\n    circuit_example;\n    options = OptimOptions(;\n        add_circuit = add_circuit,\n        repeat_points = repeat_points,\n        seed = seed,\n    ),\n)\nmerit = calc_merit(d)","category":"page"},{"location":"creation/","page":"Creating Circuits and Noise Models","title":"Creating Circuits and Noise Models","text":"Now create a randomised experimental design for the circuit. This is not necessary for simulations, but is when implementing the experimental design on an actual quantum device.","category":"page"},{"location":"creation/","page":"Creating Circuits and Noise Models","title":"Creating Circuits and Noise Models","text":"min_randomisations = 50\ntarget_shot_budget = 10^7\nexperiment_shots = 512\nd_rand = generate_rand_design(\n    d,\n    min_randomisations,\n    target_shot_budget,\n    experiment_shots;\n    seed = seed,\n)\nd_shot = get_design(d_rand)\nmerit_shot = calc_merit(d_shot)","category":"page"},{"location":"creation/","page":"Creating Circuits and Noise Models","title":"Creating Circuits and Noise Models","text":"Create a copy of the optimised design that associates phenomenological noise with the circuit to compare the predicted performance of the experimental design with depolarising and phenomenological noise. In particular, we can predict the expectation and mean of the normalised root-mean-square (RMS) error between the estimated and true gate eigenvalues: either for all of the gate eigenvalues; or after marginalising eigenvalues across the Pauli orbits for each gate; or for those marginalised eigenvalues which can be estimated to relative precision, namely those not associated with state preparation and measurement (SPAM) noise.","category":"page"},{"location":"creation/","page":"Creating Circuits and Noise Models","title":"Creating Circuits and Noise Models","text":"d_phen = update_noise(d_shot, phen_param)\nmerit_phen = calc_merit(d_phen)","category":"page"},{"location":"creation/","page":"Creating Circuits and Noise Models","title":"Creating Circuits and Noise Models","text":"We can also simulate noise characterisation experiments with this experimental design and phenomenological noise, and compare the performance to predictions by computing z-scores for the normalised RMS error with respect to the predicted expectation and variance. Note that the generalised least squares (GLS) estimator is the most performant and the focus here. It is implemented as an iterative feasible generalised least squares (FGLS) method.","category":"page"},{"location":"creation/","page":"Creating Circuits and Noise Models","title":"Creating Circuits and Noise Models","text":"budget_set = [10^6; 10^7; 10^8]\nrepetitions = 10\naces_data = simulate_aces(d_phen, budget_set; repetitions = repetitions, seed = seed)\npretty_print(aces_data, merit_phen)","category":"page"},{"location":"creation/","page":"Creating Circuits and Noise Models","title":"Creating Circuits and Noise Models","text":"As before, note that the distribution of the normalised RMS error between the estimated and true gate eigenvalues is not quite normally distributed. Hence the z-scores shown here, which are normalised by the predicted performance of the experimental design, will not quite be normally distributed.","category":"page"},{"location":"creation/","page":"Creating Circuits and Noise Models","title":"Creating Circuits and Noise Models","text":"Now we can examine one of the tuples in the design and the corresponding experiments used to estimate its circuit eigenvalues.","category":"page"},{"location":"creation/","page":"Creating Circuits and Noise Models","title":"Creating Circuits and Noise Models","text":"example_tuple = [2; 3; 2; 1; 1]\nidx = 9\n@assert d_shot.tuple_set[idx] == example_tuple\nexperiment_set = d_shot.experiment_ensemble[idx]\nexample_mappings =\n    [d_shot.mapping_ensemble[idx][experiment] for experiment in experiment_set]","category":"page"},{"location":"creation/","page":"Creating Circuits and Noise Models","title":"Creating Circuits and Noise Models","text":"We can also examine slices from the gate eigenvalue estimator covariance matrix corresponding to a particular gate.","category":"page"},{"location":"creation/","page":"Creating Circuits and Noise Models","title":"Creating Circuits and Noise Models","text":"gls_covariance = calc_gls_covariance(d_shot)\ngls_marginal_covariance = get_marginal_gate_covariance(d_shot, gls_covariance)\nh_22_gate_index = d_shot.c.gate_data.gate_indices[4]\nh_22_indices = h_22_gate_index.indices\nh_22_marg_indices = h_22_gate_index.marg_indices\ndisplay(gls_covariance[h_22_indices, h_22_indices])\ndisplay(gls_marginal_covariance[h_22_marg_indices, h_22_marg_indices])","category":"page"},{"location":"creation/","page":"Creating Circuits and Noise Models","title":"Creating Circuits and Noise Models","text":"For the Hadamard gate considered here, Pauli X and Z form one orbit, and Pauli Y forms the other. We see that the X and Z eigenvalues have large variance, but also large negative covariance, such that upon marginalisation over gate orbits, we see that the marginal orbit eigenvalue has small variance comparable to that of the Y eigenvalue. This demonstrates that ACES implicitly performs relative precision estimation of these marginal orbit eigenvalues.","category":"page"},{"location":"internal/merit/","page":"merit.jl","title":"merit.jl","text":"CollapsedDocStrings = true","category":"page"},{"location":"internal/merit/#merit.jl","page":"merit.jl","title":"merit.jl","text":"","category":"section"},{"location":"internal/merit/#Public-functions","page":"merit.jl","title":"Public functions","text":"","category":"section"},{"location":"internal/merit/","page":"merit.jl","title":"merit.jl","text":"Modules = [QuantumACES]\nPages = [\"src/merit.jl\"]\nPrivate = false","category":"page"},{"location":"internal/merit/#QuantumACES.Merit","page":"merit.jl","title":"QuantumACES.Merit","text":"Merit\n\nMerit parameters for an experimental design.\n\nFields\n\ncircuit_param::AbstractCircuitParameters: Circuit parameters.\nnoise_param::AbstractNoiseParameters: Noise parameters.\ntuple_set_data::TupleSetData: TupleSetData object that generates the tuple set.\ntuple_times::Vector{Float64}: Time taken to implement the circuit corresponding to each tuple, normalised according to the basic tuple set.\nshot_weights::Vector{Float64}: Shot weights for each tuple in the set, which add to 1.\nexperiment_numbers::Vector{Int}: Number of experiments for each tuple in the set.\nexperiment_number::Int: Total number of experiments.\nN::Int: Number of gate eigenvalues.\nN_marginal::Int: Number of marginal gate eigenvalues.\nN_relative::Int: Number of relative precision marginal gate eigenvalues.\nG::Int: Total number of gates.\ngls_expectation::Float64: Expected normalised RMS error for the generalised least squares (GLS) gate eigenvalue estimator vector.\ngls_variance::Float64: Normalised RMS error variance for the GLS gate eigenvalue estimator vector.\ngls_cov_eigenvalues::Vector{Float64}: Eigenvalues of the GLS gate eigenvalue estimator covariance matrix.\ngls_marginal_expectation::Float64: Expected normalised RMS error for the marginal GLS gate eigenvalue estimator vector.\ngls_marginal_variance::Float64: Normalised RMS error variance for the marginal GLS gate eigenvalue estimator vector.\ngls_marginal_cov_eigenvalues::Vector{Float64}: Eigenvalues of the marginal GLS gate eigenvalue estimator covariance matrix.\ngls_relative_expectation::Float64: Expected normalised RMS error for the relative precision marginal GLS gate eigenvalue estimator vector.\ngls_relative_variance::Float64: Normalised RMS error variance for the relative precision marginal GLS gate eigenvalue estimator vector.\ngls_relative_cov_eigenvalues::Vector{Float64}: Eigenvalues of the relative precision marginal GLS gate eigenvalue estimator covariance matrix.\nwls_expectation::Float64: Expected normalised RMS error for the weighted least squares (WLS) gate eigenvalue estimator vector.\nwls_variance::Float64: Normalised RMS error variance for the WLS gate eigenvalue estimator vector.\nwls_cov_eigenvalues::Vector{Float64}: Eigenvalues of the WLS gate eigenvalue estimator covariance matrix.\nwls_marginal_expectation::Float64: Expected normalised RMS error for the marginal WLS gate eigenvalue estimator vector.\nwls_marginal_variance::Float64: Normalised RMS error variance for the marginal WLS gate eigenvalue estimator vector.\nwls_marginal_cov_eigenvalues::Vector{Float64}: Eigenvalues of the marginal WLS gate eigenvalue estimator covariance matrix.\nwls_relative_expectation::Float64: Expected normalised RMS error for the relative precision marginal WLS gate eigenvalue estimator vector.\nwls_relative_variance::Float64: Normalised RMS error variance for the relative precision marginal WLS gate eigenvalue estimator vector.\nwls_relative_cov_eigenvalues::Vector{Float64}: Eigenvalues of the relative precision marginal WLS gate eigenvalue estimator covariance matrix.\nols_expectation::Float64: Expected normalised RMS error for the ordinary least squares (OLS) gate eigenvalue estimator vector.\nols_variance::Float64: Normalised RMS error variance for the OLS gate eigenvalue estimator vector.\nols_cov_eigenvalues::Vector{Float64}: Eigenvalues of the OLS gate eigenvalue estimator covariance matrix.\nols_marginal_expectation::Float64: Expected normalised RMS error for the marginal OLS gate eigenvalue estimator vector.\nols_marginal_variance::Float64: Normalised RMS error variance for the marginal OLS gate eigenvalue estimator vector.\nols_marginal_cov_eigenvalues::Vector{Float64}: Eigenvalues of the marginal OLS gate eigenvalue estimator covariance matrix.\nols_relative_expectation::Float64: Expected normalised RMS error for the relative precision marginal OLS gate eigenvalue estimator vector.\nols_relative_variance::Float64: Normalised RMS error variance for the relative precision marginal OLS gate eigenvalue estimator vector.\nols_relative_cov_eigenvalues::Vector{Float64}: Eigenvalues of the relative precision marginal OLS gate eigenvalue estimator covariance matrix.\ncond_num::Float64: Condition number of the design matrix, the ratio of the largest and smallest singular values.\npinv_norm::Float64: Pseudoinverse norm of the design matrix, the inverse of the smallest singular value.\n\n\n\n\n\n","category":"type"},{"location":"internal/merit/#QuantumACES.calc_covariance-Tuple{Design, Vector{Vector{Float64}}, Vector{Vector{Float64}}}","page":"merit.jl","title":"QuantumACES.calc_covariance","text":"calc_covariance(d::Design; epsilon::Real = 1e-10, weight_time::Bool = true, warning::Bool = true)\ncalc_covariance(d::Design, gate_eigenvalues::Vector{Float64}; epsilon::Real = 1e-10, weight_time::Bool = true, warning::Bool = true)\ncalc_covariance(d::Design, eigenvalues_ensemble::Vector{Vector{Float64}}, covariance_ensemble::Vector{Vector{Float64}}; epsilon::Real = 1e-10, weight_time::Bool = true, warning::Bool = true)\ncalc_covariance(d::Design, eigenvalues_experiment_ensemble::Vector{Vector{Vector{Float64}}}, covariance_experiment_ensemble::Vector{Vector{Vector{Float64}}}; epsilon::Real = 1e-10, weight_time::Bool = true, warning::Bool = true)\n\nReturns the circuit eigenvalue estimator covariance matrix for the design d with gate eigenvalues gate_eigenvalues, eigenvalue ensemble eigenvalues_ensemble, and covariance eigenvalue ensemble covariance_ensemble. Eigenvalue variances are set to a minimum value epsilon and the covariance matrix is adjusted by the times factor if weight_time is true, and if warning is true, warns that if d.full_covariance is false this will only generate the diagonal of the covariance matrix.\n\n\n\n\n\n","category":"method"},{"location":"internal/merit/#QuantumACES.calc_covariance_log-Tuple{SparseArrays.SparseMatrixCSC{Float64, Int64}, Vector{Float64}}","page":"merit.jl","title":"QuantumACES.calc_covariance_log","text":"calc_covariance_log(covariance::SparseMatrixCSC{Float64, Int}, eigenvalues::Vector{Float64})\ncalc_covariance_log(d::Design; warning::Bool = true)\n\nReturns the covariance matrix of the circuit log-eigenvalues corresponding to the circuit eigenvalues eigenvalues with covariance matrix covariance, using values generated from the design d and, if warning is true, warns that if d.full_covariance is false then this will only generate the diagonal of the covariance matrix.\n\n\n\n\n\n","category":"method"},{"location":"internal/merit/#QuantumACES.calc_gate_probabilities_covariance-Tuple{Design, SparseArrays.SparseMatrixCSC{Float64, Int64}}","page":"merit.jl","title":"QuantumACES.calc_gate_probabilities_covariance","text":"calc_gate_probabilities_covariance(d::Design; ls_type::Symbol = :gls, est_type::Symbol = :ordinary, unpad::Bool = false)\ncalc_gate_probabilities_covariance(d::Design, covariance_log::SparseMatrixCSC{Float64, Int}; ls_type::Symbol = :gls, est_type::Symbol = :ordinary, unpad::Bool = false)\n\nReturns the padded gate error probabilities estimator covariance matrix for the least squares estimator specified by ls_type (:gls, :wls, or :ols) corresponding to the design d with circuit log-eigenvalue estimator covariance matrix covariance_log, with estimator type est_type (:ordinary, :marginal, or :relative). Instead returns the unpadded gate error probabilities estimator covariance matrix if unpad is true, which is stripped of the covariance with the identity error probabilities.\n\n\n\n\n\n","category":"method"},{"location":"internal/merit/#QuantumACES.calc_gls_covariance-Tuple{Design, SparseArrays.SparseMatrixCSC{Float64, Int64}}","page":"merit.jl","title":"QuantumACES.calc_gls_covariance","text":"calc_gls_covariance(d::Design)\ncalc_gls_covariance(d::Design, covariance_log::SparseMatrixCSC{Float64, Int})\n\nReturns the gate eigenvalue estimator covariance matrix for the generalised least squares (GLS) estimator corresponding to the design d with circuit log-eigenvalue estimator covariance matrix covariance_log.\n\n\n\n\n\n","category":"method"},{"location":"internal/merit/#QuantumACES.calc_gls_moments-Tuple{Design, SparseArrays.SparseMatrixCSC{Float64, Int64}}","page":"merit.jl","title":"QuantumACES.calc_gls_moments","text":"calc_gls_moments(d::Design; est_type::Symbol = :ordinary)\ncalc_gls_moments(d::Design, covariance_log::SparseMatrixCSC{Float64, Int}; est_type::Symbol = :ordinary)\n\nReturns the expectation and variance of the normalised RMS error for the generalised least squares (GLS) estimator corresponding to the design d with circuit log-eigenvalue estimator covariance matrix covariance_log, with estimator type est_type (:ordinary, :marginal, or :relative).\n\n\n\n\n\n","category":"method"},{"location":"internal/merit/#QuantumACES.calc_ls_covariance-Tuple{Design, SparseArrays.SparseMatrixCSC{Float64, Int64}}","page":"merit.jl","title":"QuantumACES.calc_ls_covariance","text":"calc_ls_covariance(d::Design; ls_type::Symbol = :gls, est_type::Symbol = :ordinary)\ncalc_ls_covariance(d::Design, covariance_log::SparseMatrixCSC{Float64, Int}; ls_type::Symbol = :gls, est_type::Symbol = :ordinary)\n\nReturns the gate eigenvalue estimator covariance matrix for the least squares estimator specified by ls_type (:gls, :wls, or :ols) corresponding to the design d with circuit log-eigenvalue estimator covariance matrix covariance_log, with estimator type est_type (:ordinary, :marginal, or :relative).\n\n\n\n\n\n","category":"method"},{"location":"internal/merit/#QuantumACES.calc_ls_moments-Tuple{Design, SparseArrays.SparseMatrixCSC{Float64, Int64}}","page":"merit.jl","title":"QuantumACES.calc_ls_moments","text":"calc_ls_moments(d::Design; ls_type::Symbol = :gls, est_type::Symbol = :ordinary, est_weight::Float64 = 0.5)\ncalc_ls_moments(d::Design, covariance_log::SparseMatrixCSC{Float64, Int}; ls_type::Symbol = :gls, est_type::Symbol = :ordinary, est_weight::Float64 = 0.5)\n\nReturns the expectation and variance of the normalised RMS error for the least squares estimator specified by ls_type (:gls, :wls, or :ols) corresponding to the design d with circuit log-eigenvalue estimator covariance matrix covariance_log, with estimator type est_type (:ordinary, :marginal, or :relative). If est_type is instead set to :sum or :prod, computes the arithmetic or geometric mean of the ordinary and relative precision moments, weighted by est_weight, the weighting allocated to the ordinary precision moments.\n\n\n\n\n\n","category":"method"},{"location":"internal/merit/#QuantumACES.calc_merit-Tuple{Design}","page":"merit.jl","title":"QuantumACES.calc_merit","text":"calc_merit(d::Design; warning::Bool = true)\ncalc_merit(d_rand::RandDesign; warning::Bool = true)\n\nReturns a Merit object corresponding to the design d or randomised design d_rand, displaying a warning if the design does not have full covariance matrix data and warning is true.\n\n\n\n\n\n","category":"method"},{"location":"internal/merit/#QuantumACES.calc_ols_covariance-Tuple{Design, SparseArrays.SparseMatrixCSC{Float64, Int64}}","page":"merit.jl","title":"QuantumACES.calc_ols_covariance","text":"calc_ols_covariance(d::Design)\ncalc_ols_covariance(d::Design, covariance_log::SparseMatrixCSC{Float64, Int})\n\nReturns the gate eigenvalue estimator covariance matrix for the ordinary least squares (OLS) estimator corresponding to the design d with circuit log-eigenvalue estimator covariance matrix covariance_log.\n\n\n\n\n\n","category":"method"},{"location":"internal/merit/#QuantumACES.calc_ols_moments-Tuple{Design, SparseArrays.SparseMatrixCSC{Float64, Int64}}","page":"merit.jl","title":"QuantumACES.calc_ols_moments","text":"calc_ols_moments(d::Design; est_type::Symbol = :ordinary)\ncalc_ols_moments(d::Design, covariance_log::SparseMatrixCSC{Float64, Int}; est_type::Symbol = :ordinary)\n\nReturns the expectation and variance of the normalised RMS error for the ordinary least squares (OLS) estimator corresponding to the design d with circuit log-eigenvalue estimator covariance matrix covariance_log, with estimator type est_type (:ordinary, :marginal, or :relative).\n\n\n\n\n\n","category":"method"},{"location":"internal/merit/#QuantumACES.calc_precision_matrix-Tuple{SparseArrays.SparseMatrixCSC{Float64, Int64}, Vector{Float64}, SparseArrays.SparseMatrixCSC{Float64, Int64}}","page":"merit.jl","title":"QuantumACES.calc_precision_matrix","text":"calc_precision_matrix(design_matrix::SparseMatrixCSC{Float64, Int}, gate_eigenvalues::Vector{Float64}, covariance_log_inv::SparseMatrixCSC{Float64, Int})\ncalc_precision_matrix(d::Design, gate_eigenvalues::Vector{Float64}; diagonal::Bool = false)\ncalc_precision_matrix(d::Design; diagonal::Bool = false)\n\nReturns the precision matrix, namely the inverse of the generalised least squares gate eigenvalue estimator covariance matrix, corresponding to the design d with design matrix design_matrix, gate eigenvalues gate_eigenvalues and circuit log-eigenvalue estimator covariance matrix inverse covariance_log_inv. Ordinarily this yields the precision matrix for generalise least squares, but if diagonal is true it calculates the inverse of the diagonal of the covariance matrix, rather than the inverse of the full matrix, yielding the precision matrix for both generalised and weighted least squares if the circuit eigenvalue estimators were uncorrelated.\n\n\n\n\n\n","category":"method"},{"location":"internal/merit/#QuantumACES.calc_wls_covariance-Tuple{Design, SparseArrays.SparseMatrixCSC{Float64, Int64}}","page":"merit.jl","title":"QuantumACES.calc_wls_covariance","text":"calc_wls_covariance(d::Design)\ncalc_wls_covariance(d::Design, covariance_log::SparseMatrixCSC{Float64, Int})\n\nReturns the gate eigenvalue estimator covariance matrix for the weighted least squares (WLS) estimator corresponding to the design d with circuit log-eigenvalue estimator covariance matrix covariance_log.\n\n\n\n\n\n","category":"method"},{"location":"internal/merit/#QuantumACES.calc_wls_moments-Tuple{Design, SparseArrays.SparseMatrixCSC{Float64, Int64}}","page":"merit.jl","title":"QuantumACES.calc_wls_moments","text":"calc_wls_moments(d::Design; est_type::Symbol = :ordinary)\ncalc_wls_moments(d::Design, covariance_log::SparseMatrixCSC{Float64, Int}; est_type::Symbol = :ordinary)\n\nReturns the expectation and variance of the normalised RMS error for the weighted least squares (WLS) estimator corresponding to the design d with circuit log-eigenvalue estimator covariance matrix covariance_log, with estimator type est_type (:ordinary, :marginal, or :relative).\n\n\n\n\n\n","category":"method"},{"location":"internal/merit/#QuantumACES.get_marginal_gate_covariance-Tuple{Design, LinearAlgebra.Symmetric{Float64, Matrix{Float64}}}","page":"merit.jl","title":"QuantumACES.get_marginal_gate_covariance","text":"get_marginal_gate_covariance(d::Design, gate_eigenvalues_cov::Symmetric{Float64, Matrix{Float64}})\n\nReturns the marginal gate eigenvalue estimator covariance matrix corresponding to the gate eigenvalue estimator covariance matrix gate_eigenvalues_cov for the design d.\n\n\n\n\n\n","category":"method"},{"location":"internal/merit/#QuantumACES.get_pad_transform-Tuple{Design, Symbol}","page":"merit.jl","title":"QuantumACES.get_pad_transform","text":"get_pad_transform(d::Design, est_type::Symbol; probabilities::Bool = false)\n\nReturns a transform matrix that pads gate eigenvalues, or gate error probabilities if probabilities is true, whose type depends on the estimator type est_type (:ordinary, :marginal, or :relative), with identity eigenvaleus or error probabilities, respectively, calculated using the gate data of the design d.\n\n\n\n\n\n","category":"method"},{"location":"internal/merit/#QuantumACES.get_relative_gate_covariance-Tuple{Design, LinearAlgebra.Symmetric{Float64, Matrix{Float64}}}","page":"merit.jl","title":"QuantumACES.get_relative_gate_covariance","text":"get_relative_gate_covariance(d::Design, gate_eigenvalues_cov::Symmetric{Float64, Matrix{Float64}})\n\nReturns the relative gate eigenvalue estimator covariance matrix corresponding to the gate eigenvalue estimator covariance matrix gate_eigenvalues_cov for the design d.\n\n\n\n\n\n","category":"method"},{"location":"internal/merit/#QuantumACES.get_transform-Tuple{Design, Symbol}","page":"merit.jl","title":"QuantumACES.get_transform","text":"get_transform(d::Design, est_type::Symbol)\n\nReturns a transform matrix that maps gate eigenvalues to gate eigenvalues of type depending on the estimator type est_type (:ordinary, :marginal, or :relative), calculated using the gate data of the design d.\n\n\n\n\n\n","category":"method"},{"location":"internal/merit/#QuantumACES.get_wht_transform-Tuple{Design, Symbol}","page":"merit.jl","title":"QuantumACES.get_wht_transform","text":"get_wht_transform(d::Design, est_type::Symbol; inverse::Bool = false)\n\nReturns a transform matrix that maps padded gate error probabilities to padded gate eigenvalues, or the inverse transform if inverse is true, whose type depends on the estimator type est_type (:ordinary, :marginal, or:relative), calculated using the gate data of the designd`.\n\n\n\n\n\n","category":"method"},{"location":"internal/merit/#QuantumACES.nrmse_pdf-Tuple{Vector{Float64}, Vector{Float64}}","page":"merit.jl","title":"QuantumACES.nrmse_pdf","text":"nrmse_pdf(cov_eigenvalues::Vector{Float64}, nrmse_values::Vector{Float64}; epsilon::Real = 1e-5)\n\nReturns the probability density function (PDF) for the normalised RMS error (NRMSE) of the gate eigenvalue estimator vector, which follows a generalised chi-squared distribution and whose covariance matrix has eigenvalues cov_eigenvalues, at the coordinates specified by nrmse_values. Does not calculate values when the normal approximation to the PDF is less than a factor of epsilon of its maximum value.\n\nCalculation follows Eq. 3.2 of Computing the distribution of quadratic forms in normal variables by J. P. Imhof (1961).\n\n\n\n\n\n","category":"method"},{"location":"internal/merit/#QuantumACES.sparse_covariance_inv-Tuple{SparseArrays.SparseMatrixCSC{Float64, Int64}, Vector{Int64}}","page":"merit.jl","title":"QuantumACES.sparse_covariance_inv","text":"sparse_covariance_inv(covariance_log::SparseMatrixCSC{Float64, Int}, mapping_lengths::Vector{Int}; epsilon::Real = 1e-12, warning::Bool = true)\n\nReturns the inverse of the sparse block diagonal circuit log-eigenvalue estimator covariance matrix covariance_log, where the block sizes are specified by mapping_lengths, ensuring a smallest eigenvalue epsilon if the Cholesky factorisation fails, and warning if warning is true.\n\n\n\n\n\n","category":"method"},{"location":"internal/merit/#Private-functions","page":"merit.jl","title":"Private functions","text":"","category":"section"},{"location":"internal/merit/","page":"merit.jl","title":"merit.jl","text":"Modules = [QuantumACES]\nPages = [\"src/merit.jl\"]\nPublic = false","category":"page"},{"location":"internal/merit/#QuantumACES.calc_covariance_eigenvalues-Tuple{Design, Vector{Float64}}","page":"merit.jl","title":"QuantumACES.calc_covariance_eigenvalues","text":"calc_covariance_eigenvalues(d::Design)\ncalc_covariance_eigenvalues(d::Design, gate_eigenvalues::Vector{Float64})\n\nReturns the covariance matrix eigenvalue ensemble for the design d with gate eigenvalues gate_eigenvalues.\n\n\n\n\n\n","category":"method"},{"location":"internal/merit/#QuantumACES.get_covariance_mapping_data-Tuple{Design}","page":"merit.jl","title":"QuantumACES.get_covariance_mapping_data","text":"get_covariance_mapping_data(d::Design)\n\nReturns covariance matrix mapping index data for the design d.\n\n\n\n\n\n","category":"method"},{"location":"internal/merit/#QuantumACES.nrmse_moments-Tuple{LinearAlgebra.Symmetric{Float64, Matrix{Float64}}}","page":"merit.jl","title":"QuantumACES.nrmse_moments","text":"nrmse_moments(gate_eigenvalues_cov::Symmetric{Float64, Matrix{Float64}})    \nnrmse_moments(gate_eigenvalues_cov_eigenvalues::Vector{Float64})\n\nReturns the expectation and variance of the normalised RMS error, as determined either by the gate eigenvalue estimator covariance matrix gate_eigenvalues_cov or its eigenvalues gate_eigenvalues_cov_eigenvalues.\n\n\n\n\n\n","category":"method"},{"location":"internal/merit/#QuantumACES.nrmse_pdf_integrand-Tuple{Float64, Float64, Vector{Float64}}","page":"merit.jl","title":"QuantumACES.nrmse_pdf_integrand","text":"nrmse_pdf_integrand(u::Float64, x::Float64, norm_cov_eigenvalues::Vector{Float64})\n\nReturns the integrand of the Imhof method CDF for the distribution of the NRMSE.\n\nCalculation follows Eq. 3.2 of Computing the distribution of quadratic forms in normal variables by J. P. Imhof (1961).\n\n\n\n\n\n","category":"method"},{"location":"internal/merit/#QuantumACES.sparse_covariance_inv_factor-Tuple{SparseArrays.SparseMatrixCSC{Float64, Int64}, Vector{Int64}}","page":"merit.jl","title":"QuantumACES.sparse_covariance_inv_factor","text":"sparse_covariance_inv_factor(covariance_log::SparseMatrixCSC{Float64, Int}, mapping_lengths::Vector{Int}; epsilon::Real = 1e-12, warning::Bool = true)\n\nReturns the inverse of the lower Cholesky factor of the sparse block diagonal circuit log-eigenvalue estimator covariance matrix covariance_log, where the block sizes are specified by mapping_lengths, ensuring a smallest eigenvalue epsilon if the Cholesky factorisation fails, and warning if warning is true.\n\n\n\n\n\n","category":"method"},{"location":"internal/estimate/","page":"estimate.jl","title":"estimate.jl","text":"CollapsedDocStrings = true","category":"page"},{"location":"internal/estimate/#estimate.jl","page":"estimate.jl","title":"estimate.jl","text":"","category":"section"},{"location":"internal/estimate/#Public-functions","page":"estimate.jl","title":"Public functions","text":"","category":"section"},{"location":"internal/estimate/","page":"estimate.jl","title":"estimate.jl","text":"Modules = [QuantumACES]\nPages = [\"src/estimate.jl\"]\nPrivate = false","category":"page"},{"location":"internal/estimate/#QuantumACES.NoiseError","page":"estimate.jl","title":"QuantumACES.NoiseError","text":"NoiseError\n\nNoise estimate error data structure containing normalised root-mean-square errors (NRMSE) for a NoiseEstimate.\n\nFields\n\ngls_nrmse::Float64: Generalised least squares normalised root-mean-square error.\ngls_proj_nrmse::Float64: Generalised least squares projected normalised root-mean-square error.\ngls_marginal_nrmse::Float64: Generalised least squares marginal normalised root-mean-square error.\ngls_proj_marginal_nrmse::Float64: Generalised least squares projected marginal normalised root-mean-square error.\ngls_relative_nrmse::Float64: Generalised least squares relative normalised root-mean-square error.\ngls_proj_relative_nrmse::Float64: Generalised least squares projected relative normalised root-mean-square error.\nwls_nrmse::Float64: Weighted least squares normalised root-mean-square error.\nwls_proj_nrmse::Float64: Weighted least squares projected normalised root-mean-square error.\nwls_marginal_nrmse::Float64: Weighted least squares marginal normalised root-mean-square error.\nwls_proj_marginal_nrmse::Float64: Weighted least squares projected marginal normalised root-mean-square error.\nwls_relative_nrmse::Float64: Weighted least squares relative normalised root-mean-square error.\nwls_proj_relative_nrmse::Float64: Weighted least squares projected relative normalised root-mean-square error.\nols_nrmse::Float64: Ordinary least squares normalised root-mean-square error.\nols_proj_nrmse::Float64: Ordinary least squares projected normalised root-mean-square error.\nols_marginal_nrmse::Float64: Ordinary least squares marginal normalised root-mean-square error.\nols_proj_marginal_nrmse::Float64: Ordinary least squares projected marginal normalised root-mean-square error.\nols_relative_nrmse::Float64: Ordinary least squares relative normalised root-mean-square error.\nols_proj_relative_nrmse::Float64: Ordinary least squares projected relative normalised root-mean-square error.\n\n\n\n\n\n","category":"type"},{"location":"internal/estimate/#QuantumACES.NoiseEstimate","page":"estimate.jl","title":"QuantumACES.NoiseEstimate","text":"NoiseEstimate\n\nNoise estimate data structure.\n\nFields\n\neigenvalues_experiment_ensemble::Vector{Vector{Vector{Float64}}}: Circuit eigenvalue estimates for each tuple and circuit eigenvalue.\ncovariance_experiment_ensemble::Vector{Vector{Vector{Float64}}}: Covariance circuit eigenvalue estimates for each tuple and covariance circuit eigenvalue.\nshot_budget::Int: Shot budget for the (potentially randomised) experimental ensemble.\ngls_unproj_gate_eigenvalues::Vector{Float64}: Generalised least squares unprojected gate eigenvalues.\ngls_gate_eigenvalues::Vector{Float64}: Generalised least squares projected gate eigenvalues.\ngls_unproj_gate_probabilities::Dict{Gate, Vector{Float64}}: Generalised least squares unprojected gate error probabilities.\ngls_gate_probabilities::Dict{Gate, Vector{Float64}}: Generalised least squares projected gate error probabilities.\ngls_unproj_marginal_gate_eigenvalues::Vector{Float64}: Generalised least squares unprojected marginal gate eigenvalues.\ngls_marginal_gate_eigenvalues::Vector{Float64}: Generalised least squares projected marginal gate eigenvalues.\ngls_unproj_marginal_gate_probabilities::Dict{Gate, Vector{Float64}}: Generalised least squares unprojected marginal gate error probabilities.\ngls_marginal_gate_probabilities::Dict{Gate, Vector{Float64}}: Generalised least squares projected marginal gate error probabilities.\ngls_unproj_relative_gate_eigenvalues::Vector{Float64}: Generalised least squares unprojected relative gate eigenvalues.\ngls_relative_gate_eigenvalues::Vector{Float64}: Generalised least squares projected relative gate eigenvalues.\nwls_unproj_gate_eigenvalues::Vector{Float64}: Weighted least squares unprojected gate eigenvalues.\nwls_gate_eigenvalues::Vector{Float64}: Weighted least squares projected gate eigenvalues.\nwls_unproj_gate_probabilities::Dict{Gate, Vector{Float64}}: Weighted least squares unprojected gate error probabilities.\nwls_gate_probabilities::Dict{Gate, Vector{Float64}}: Weighted least squares projected gate error probabilities.\nwls_unproj_marginal_gate_eigenvalues::Vector{Float64}: Weighted least squares unprojected marginal gate eigenvalues.\nwls_marginal_gate_eigenvalues::Vector{Float64}: Weighted least squares projected marginal gate eigenvalues.\nwls_unproj_marginal_gate_probabilities::Dict{Gate, Vector{Float64}}: Weighted least squares unprojected marginal gate error probabilities.\nwls_marginal_gate_probabilities::Dict{Gate, Vector{Float64}}: Weighted least squares projected marginal gate error probabilities.\nwls_unproj_relative_gate_eigenvalues::Vector{Float64}: Weighted least squares unprojected relative gate eigenvalues.\nwls_relative_gate_eigenvalues::Vector{Float64}: Weighted least squares projected relative gate eigenvalues.\nols_unproj_gate_eigenvalues::Vector{Float64}: Ordinary least squares unprojected gate eigenvalues.\nols_gate_eigenvalues::Vector{Float64}: Ordinary least squares projected gate eigenvalues.\nols_unproj_gate_probabilities::Dict{Gate, Vector{Float64}}: Ordinary least squares unprojected gate error probabilities.\nols_gate_probabilities::Dict{Gate, Vector{Float64}}: Ordinary least squares projected gate error probabilities.\nols_unproj_marginal_gate_eigenvalues::Vector{Float64}: Ordinary least squares unprojected marginal gate eigenvalues.\nols_marginal_gate_eigenvalues::Vector{Float64}: Ordinary least squares projected marginal gate eigenvalues.\nols_unproj_marginal_gate_probabilities::Dict{Gate, Vector{Float64}}: Ordinary least squares unprojected marginal gate error probabilities.\nols_marginal_gate_probabilities::Dict{Gate, Vector{Float64}}: Ordinary least squares projected marginal gate error probabilities.\nols_unproj_relative_gate_eigenvalues::Vector{Float64}: Ordinary least squares unprojected relative gate eigenvalues.\nols_relative_gate_eigenvalues::Vector{Float64}: Ordinary least squares projected relative gate eigenvalues.\n\n\n\n\n\n","category":"type"},{"location":"internal/estimate/#QuantumACES.NoiseScore","page":"estimate.jl","title":"QuantumACES.NoiseScore","text":"NoiseScore\n\nNoise estimate error z-score data structure, containing the z-scores for a NoiseError with respect to some predicted Merit.\n\nFields\n\ngls_z_score::Float64: Generalised least squares z-score.\ngls_proj_z_score::Float64: Generalised least squares projected z-score.\ngls_marginal_z_score::Float64: Generalised least squares marginal z-score.\ngls_proj_marginal_z_score::Float64: Generalised least squares projected marginal z-score.\ngls_relative_z_score::Float64: Generalised least squares relative z-score.\ngls_proj_relative_z_score::Float64: Generalised least squares projected relative z-score.\nwls_z_score::Float64: Weighted least squares z-score.\nwls_proj_z_score::Float64: Weighted least squares projected z-score.\nwls_marginal_z_score::Float64: Weighted least squares marginal z-score.\nwls_proj_marginal_z_score::Float64: Weighted least squares projected marginal z-score.\nwls_relative_z_score::Float64: Weighted least squares relative z-score.\nwls_proj_relative_z_score::Float64: Weighted least squares projected relative z-score.\nols_z_score::Float64: Ordinary least squares z-score.\nols_proj_z_score::Float64: Ordinary least squares projected z-score.\nols_marginal_z_score::Float64: Ordinary least squares marginal z-score.\nols_proj_marginal_z_score::Float64: Ordinary least squares projected marginal z-score.\nols_relative_z_score::Float64: Ordinary least squares relative z-score.\nols_proj_relative_z_score::Float64: Ordinary least squares projected relative z-score.\n\n\n\n\n\n","category":"type"},{"location":"internal/estimate/#QuantumACES.calc_covariance-Tuple{Design, NoiseEstimate}","page":"estimate.jl","title":"QuantumACES.calc_covariance","text":"calc_covariance(d::Design, noise_est::NoiseEstimate; weight_time::Bool = false)\ncalc_covariance(d_rand::RandDesign, noise_est::NoiseEstimate; weight_time::Bool = false)\n\nReturns the estimated covariance matrix for a noise estimate noise_est associated with the design d or randomised design d_rand, weighting the shot budget by the time factor if weight_time is true.\n\n\n\n\n\n","category":"method"},{"location":"internal/estimate/#QuantumACES.estimate_gate_noise-Tuple{Design, Vector{Vector{Vector{Float64}}}, Vector{Vector{Vector{Float64}}}, Int64}","page":"estimate.jl","title":"QuantumACES.estimate_gate_noise","text":"estimate_gate_noise(d::Design, noise_est::NoiseEstimate; kwargs...)\nestimate_gate_noise(d_rand::RandDesign, noise_est::NoiseEstimate; kwargs...)\nestimate_gate_noise(d::Design, est_eigenvalues_experiment_ensemble::Vector{Vector{Vector{Float64}}}, est_covariance_experiment_ensemble::Vector{Vector{Vector{Float64}}}, shot_budget::Int; kwargs...)\nestimate_gate_noise(d_rand::RandDesign, est_eigenvalues_experiment_ensemble::Vector{Vector{Vector{Float64}}}, est_covariance_experiment_ensemble::Vector{Vector{Vector{Float64}}}; kwargs...)\n\nReturns a NoiseEstimate of the gate noise for the design d or randomised design d_rand derived from estimated circuit eigenvalues, either already contained in a noise estimate noise_est, or as estimated circuit eigenvalues est_eigenvalues_experiment_ensemble and covariance circuit eigenvalues est_covariance_experiment_ensemble, with shot budget shot_budget.\n\nArguments\n\nd::Design: Experimental design.\nd_rand::RandDesign: Randomised experimental design.\nnoise_est::NoiseEstimate: Noise estimate.\nest_eigenvalues_experiment_ensemble::Vector{Vector{Vector{Float64}}}: Estimated ensemble of circuit eigenvalues.\nest_covariance_experiment_ensemble::Vector{Vector{Vector{Float64}}}: Estimated ensemble of covariance circuit eigenvalues.\nshot_budget::Int: Noise estimate shot budget.\n\nKeword arguments\n\nmin_eigenvalue::Float64 = 0.1: The minimum eigenvalue threshold for clipping.\nclip_warning::Bool = true: Whether to warn if eigenvalues are clipped.\nN_warn_split::Integer = 5 * 10^3: The number of gate eigenvalues above which to warn about splitting.\nsplit::Bool = (d.c.gate_data.N < N_warn_split ? false : true): Whether to split the gate eigenvalue projection across gates or simultaneously project all gate eigenvalues.\nsplit_warning::Bool = true: Whether to warn if the gate eigenvalue projection is not split.\nprecision::Real = 1e-8: The solver precision for the gate eigenvalue projection.\n\n\n\n\n\n","category":"method"},{"location":"internal/estimate/#QuantumACES.get_aic-Tuple{Design, NoiseEstimate}","page":"estimate.jl","title":"QuantumACES.get_aic","text":"get_aic(d::Design, noise_est::NoiseEstimate; projected::Bool = false)\nget_aic(d_rand::RandDesign, noise_est::NoiseEstimate; projected::Bool = false)\n\nReturns the Akaike information criterion (AIC) corresponding to the noise estimate noise_est, given the design d or alternatively the randomised design d_rand, calculating with the projected gate eigenvalues if projected is true.\n\n\n\n\n\n","category":"method"},{"location":"internal/estimate/#QuantumACES.get_bic-Tuple{Design, NoiseEstimate}","page":"estimate.jl","title":"QuantumACES.get_bic","text":"get_bic(d::Design, noise_est::NoiseEstimate; projected::Bool = false)\nget_bic(d_rand::RandDesign, noise_est::NoiseEstimate; projected::Bool = false)\n\nReturns the Bayesian information criterion (BIC) corresponding to the noise estimate noise_est, given the design d or alternatively the randomised design d_rand, calculating with the projected gate eigenvalues if projected is true.\n\n\n\n\n\n","category":"method"},{"location":"internal/estimate/#QuantumACES.get_eigenvalues-Tuple{NoiseEstimate}","page":"estimate.jl","title":"QuantumACES.get_eigenvalues","text":"get_eigenvalues(noise_est::NoiseEstimate)\n\nReturns the estimated circuit eigenvalues of noise estimate noise_est.\n\n\n\n\n\n","category":"method"},{"location":"internal/estimate/#QuantumACES.get_model_violation-Tuple{Design, NoiseEstimate}","page":"estimate.jl","title":"QuantumACES.get_model_violation","text":"get_model_violation(d::Design, noise_est::NoiseEstimate; projected::Bool = false)\nget_model_violation(d_rand::RandDesign, noise_est::NoiseEstimate; projected::Bool = false)\nget_model_violation(d::Design, noise_est_vector::Vector{NoiseEstimate}; projected::Bool = false)\nget_model_violation(d::Design, noise_est_matrix::Matrix{NoiseEstimate}; projected::Bool = false)\n\nReturns the noise model violation z-score for the generalised residual sum of squares corresponding to the noise estimate noise_est, given the design d or alternatively the randomised design d_rand, calculating with the projected gate eigenvalues if projected is true.\n\n\n\n\n\n","category":"method"},{"location":"internal/estimate/#QuantumACES.get_noise_error-Tuple{Design, NoiseEstimate}","page":"estimate.jl","title":"QuantumACES.get_noise_error","text":"get_noise_error(d::Design, noise_est::NoiseEstimate)\nget_noise_error(d_rand::RandDesign, noise_est::NoiseEstimate)\n\nReturns a NoiseError object containing the normalised root-mean-square errors (NRMSEs) for the gate noise estimates in noise_est and the true gate eigenvalues for the design d, or alternatively the randomised design d_rand.\n\n\n\n\n\n","category":"method"},{"location":"internal/estimate/#QuantumACES.get_noise_score-Tuple{NoiseError, Merit}","page":"estimate.jl","title":"QuantumACES.get_noise_score","text":"get_noise_score(noise_error::NoiseError, merit::Merit)\nget_noise_score(noise_error_vector::Vector{NoiseError}, merit::Merit)\nget_noise_score(noise_error_matrix::Matrix{NoiseError}, merit::Merit)\n\nReturns a NoiseScore object containing the z-scores for the supplied normalised root-mean-square error (NRMSE) data in noise_error given the merit merit.\n\n\n\n\n\n","category":"method"},{"location":"internal/estimate/#QuantumACES.get_rss-Tuple{Design, NoiseEstimate}","page":"estimate.jl","title":"QuantumACES.get_rss","text":"get_rss(d::Design, noise_est::NoiseEstimate; projected::Bool = false)\nget_rss(d_rand::RandDesign, noise_est::NoiseEstimate; projected::Bool = false)\n\nReturns the generalised residual sum of squares corresponding to the noise estimate noise_est, given the design d or alternatively the randomised design d_rand, calculating with the projected gate eigenvalues if projected is true.\n\n\n\n\n\n","category":"method"},{"location":"internal/estimate/#QuantumACES.is_score_expected-Tuple{NoiseScore, Real, Real}","page":"estimate.jl","title":"QuantumACES.is_score_expected","text":"is_score_expected(noise_score::NoiseScore, z_score_cutoff::Real)\nis_score_expected(noise_score::NoiseScore, z_score_cutoff_lower::Real, z_score_cutoff_upper::Real)\n\nReturns a Boolean indicating whether the z-scores in noise_score are within the specified cutoffs, and projection improves the z-scores as expected.\n\n\n\n\n\n","category":"method"},{"location":"internal/estimate/#Private-functions","page":"estimate.jl","title":"Private functions","text":"","category":"section"},{"location":"internal/estimate/","page":"estimate.jl","title":"estimate.jl","text":"Modules = [QuantumACES]\nPages = [\"src/estimate.jl\"]\nPublic = false","category":"page"},{"location":"internal/estimate/#QuantumACES.estimate_experiment-Tuple{Union{Dict{String, Int64}, Matrix{UInt8}}, Vector{Vector{Int64}}, Vector{Bool}, Integer}","page":"estimate.jl","title":"QuantumACES.estimate_experiment","text":"estimate_experiment(counts::Union{Matrix{UInt8}, Dict{String, Int}}, experiment_meas_indices::Vector{Vector{Int}}, experiment_pauli_signs::Vector{Bool}, shots_value::Integer)\n\nReturns the sample average estimator contributions estimated from the counts counts for the circuit eigenvalues measured at experiment_meas_indices whose Pauli mappings have signs experiment_pauli_signs, across shots_value samples.\n\n\n\n\n\n","category":"method"},{"location":"internal/estimate/#QuantumACES.estimate_gate_eigenvalues-Tuple{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, Vector{Float64}}","page":"estimate.jl","title":"QuantumACES.estimate_gate_eigenvalues","text":"estimate_gate_eigenvalues(design_matrix::SparseMatrixCSC{Float64, Int}, est_covariance_log_inv_factor::SparseMatrixCSC{Float64, Int}, est_eigenvalues::Vector{Float64}; constrain::Bool = false)\nestimate_gate_eigenvalues(design_matrix::SparseMatrixCSC{Float64, Int}, est_eigenvalues::Vector{Float64}; constrain::Bool = false)\n\nReturns the gate eigenvalues estimated from the estimated circuit eigenvalues est_eigenvalues by least squares inversion with the design matrix design_matrix, both weighted by the factor est_covariance_log_inv_factor if appropriate, constraining the gate eigenvalues to be at most 1 if constrain is true.\n\n\n\n\n\n","category":"method"},{"location":"internal/estimate/#QuantumACES.full_project_gate_eigenvalues-Tuple{Vector{Float64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, GateData}","page":"estimate.jl","title":"QuantumACES.full_project_gate_eigenvalues","text":"full_project_gate_eigenvalues(est_unproj_gate_eigenvalues::Vector{Float64}, est_precision_matrix::SparseMatrixCSC{Float64, Int64}, gate_data::GateData; precision::Real = 1e-8, diagnostics::Bool = false)\n\nReturns the projection into the probability simplex of the gate eigenvalues est_unproj_gate_eigenvalues and the corresponding gate probabilities, projecting in the Mahalanobis distance using the precision matrix est_precision_matrix, with corresponding gate data gate_data. The solver precision is controlled by precision, and solver diagnostics are printed if diagnostics is true.\n\n\n\n\n\n","category":"method"},{"location":"internal/estimate/#QuantumACES.get_clipped_indices-Tuple{Vector{Float64}}","page":"estimate.jl","title":"QuantumACES.get_clipped_indices","text":"get_clipped_indices(est_eigenvalues::Vector{Float64}; min_eigenvalue::Real = 0.1, warning::Bool = true)\n\nReturns clipped indices for the estimated circuit eigenvalues est_eigenvalues that not less than min_eigenvalue, warning if eigenvalues are clipped and warning is true.\n\n\n\n\n\n","category":"method"},{"location":"internal/estimate/#QuantumACES.get_clipped_mapping_lengths-Tuple{Vector{Int64}, Vector{Int64}}","page":"estimate.jl","title":"QuantumACES.get_clipped_mapping_lengths","text":"get_clipped_mapping_lengths(mapping_lengths::Vector{Int}, clipped_indices::Vector{Int})\n\nReturns updated mapping_lengths given the clipped indices clipped_indices.\n\n\n\n\n\n","category":"method"},{"location":"internal/estimate/#QuantumACES.get_covariance_experiment_data-Tuple{Design, Vector{Vector{CartesianIndex{2}}}, Vector{Dict{CartesianIndex{2}, Int64}}}","page":"estimate.jl","title":"QuantumACES.get_covariance_experiment_data","text":"get_covariance_experiment_data(d::Design, covariance_keys_ensemble::Vector{Vector{CartesianIndex{2}}}, covariance_key_indices_ensemble::Vector{Dict{CartesianIndex{2}, Int}}; qiskit_qubit_map::Union{Vector{Int}, Nothing} = nothing)\n\nReturns the covariance experiment data for the design d, including the covariance experiment ensemble, covariance measurement indices ensemble, and covariance Pauli sign ensemble.\n\n\n\n\n\n","category":"method"},{"location":"internal/estimate/#QuantumACES.get_experiment_data-Tuple{Design}","page":"estimate.jl","title":"QuantumACES.get_experiment_data","text":"get_experiment_data(d::Design; qiskit_qubit_map::Union{Vector{Int}, Nothing} = nothing)\n\nReturns the experiment data for the design d, including the experiment ensemble, measurement indices ensemble, and Pauli sign ensemble.\n\n\n\n\n\n","category":"method"},{"location":"internal/estimate/#QuantumACES.pauli_estimate-Tuple{Matrix{UInt8}, Vector{Int64}, Integer}","page":"estimate.jl","title":"QuantumACES.pauli_estimate","text":"pauli_estimate(stim_counts::Matrix{UInt8}, pauli_meas_indices::Vector{Int}, shots_value::Integer)\npauli_estimate(qiskit_counts::Dict{String,Int}, pauli_meas_indices::Vector{Int}, shots_value::Integer)\n\nReturns the sample average from the counts stim_counts or qiskit_counts of the Pauli operator measured at the indices pauli_meas_indices across shots_value samples.\n\nNote that parse_qiskit_dict parses Qiskit formatted counts into Stim formatted counts.\n\n\n\n\n\n","category":"method"},{"location":"internal/estimate/#QuantumACES.simple_project_gate_eigenvalues-Tuple{Vector{Float64}, GateData}","page":"estimate.jl","title":"QuantumACES.simple_project_gate_eigenvalues","text":"simple_project_gate_eigenvalues(est_unproj_gate_eigenvalues::Vector{Float64}, gate_data::GateData)\n\nReturns the projection into the probability simplex of the gate eigenvalues est_unproj_gate_eigenvalues and the corresponding gate probabilities, projecting in the Euclidean distance with corresponding gate data gate_data.\n\n\n\n\n\n","category":"method"},{"location":"internal/estimate/#QuantumACES.split_project_gate_eigenvalues-Tuple{Vector{Float64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, GateData}","page":"estimate.jl","title":"QuantumACES.split_project_gate_eigenvalues","text":"split_project_gate_eigenvalues(est_unproj_gate_eigenvalues::Vector{Float64}, est_precision_matrix::SparseMatrixCSC{Float64, Int64}, gate_data::GateData; precision::Real = 1e-8, diagnostics::Bool = false)\n\nReturns the projection into the probability simplex of the gate eigenvalues est_unproj_gate_eigenvalues and the corresponding gate probabilities, projecting separately for each gate in the Mahalanobis distance using the relevant slice of the precision matrix est_precision_matrix, with corresponding gate data gate_data. The solver precision is controlled by precision, and solver diagnostics are printed if diagnostics is true.\n\n\n\n\n\n","category":"method"},{"location":"internal/circuits/heavy_hex/","page":"circuits/heavy_hex.jl","title":"circuits/heavy_hex.jl","text":"CollapsedDocStrings = true","category":"page"},{"location":"internal/circuits/heavy_hex/#heavy_hex.jl","page":"circuits/heavy_hex.jl","title":"heavy_hex.jl","text":"","category":"section"},{"location":"internal/circuits/heavy_hex/#Public-functions","page":"circuits/heavy_hex.jl","title":"Public functions","text":"","category":"section"},{"location":"internal/circuits/heavy_hex/","page":"circuits/heavy_hex.jl","title":"circuits/heavy_hex.jl","text":"Modules = [QuantumACES]\nPages = [\"src/circuits/heavy_hex.jl\"]\nPrivate = false","category":"page"},{"location":"internal/circuits/heavy_hex/#QuantumACES.HeavyHexParameters","page":"circuits/heavy_hex.jl","title":"QuantumACES.HeavyHexParameters","text":"HeavyHexParameters\n\nParameters for the syndrome extraction circuit of a heavy hex code.\n\nFields\n\nparams::Dict{Symbol, Any}: Dictionary of the circuit parameters described below.\ncircuit_name::String: Name of the circuit used for saving data.\n\nParameters\n\nvertical_dist::Int: Vertical (Z) distance of the code.\nhorizontal_dist::Int: Horizontal (X) distance of the code.\nflipped::Bool: Whether ancilla qubit layout is flipped left to right.\ngate_type::Symbol: Type of two-qubit gate used in the circuit, which must be :cx.\nancilla_measurement::Bool: Whether to include mid-circuit ancilla measurements.\npad_identity::Bool: Whether to pad layers with single-qubit identity gates.\nlayer_time_dict::Dict{Symbol, Float64}: Dictionary of layer times.\n\n\n\n\n\n","category":"type"},{"location":"internal/circuits/heavy_hex/#QuantumACES.get_circuit-Union{Tuple{T}, Tuple{HeavyHexParameters, T}} where T<:AbstractNoiseParameters","page":"circuits/heavy_hex.jl","title":"QuantumACES.get_circuit","text":"get_circuit(hex_param::HeavyHexParameters, noise_param::AbstractNoiseParameters; kwargs...)\n\nReturns a heavy hex code syndrome extraction circuit in the form of a Circuit object parameterised by the supplied circuit and noise parameters.\n\nArguments\n\nhex_param::HeavyHexParameters: Parameters for a heavy hex code.\nnoise_param::AbstractNoiseParameters: Noise parameters for the circuit.\n\nKeyword arguments\n\nnoisy_prep::Bool = false: Whether to treat preparations as noisy and characterise the associated noise, defaulting to false; a full-rank design cannot be produced if both noisy_prep and noisy_meas are true.\nnoisy_meas::Bool = true: Whether to treat measurements as noisy and characterise the associated noise, defaulting to true; a full-rank design cannot be produced if both noisy_prep and noisy_meas are true.\ncombined::Bool = haskey(noise_param.params, :combined) ? noise_param.params[:combined] : false,: Whether to treat Pauli X, Y, and Z basis SPAM noise as the same.\nstrict::Bool = false: Whether to be strict about which gates count as estimable to relative precision.\n\n\n\n\n\n","category":"method"},{"location":"internal/circuits/heavy_hex/#QuantumACES.get_hex_param-Tuple{Integer, Integer}","page":"circuits/heavy_hex.jl","title":"QuantumACES.get_hex_param","text":"get_hex_param(vertical_dist::Integer, horizontal_dist::Integer; kwargs...)\nget_hex_param(dist::Integer; kwargs...)\n\nReturns a HeavyHexParameters object that parameterises the syndrome extraction circuit of a heavy hex code.\n\nDefault gate layer times are estimated from IBM Torino in 2024.\n\nArguments\n\nvertical_dist::Int: Vertical distance of the code.\nhorizontal_dist::Int: Horizontal distance of the code.\ndist::Int: Distance of the code; this is equivalent to setting vertical_dist = dist and horizontal_dist = dist.\n\nKeyword arguments\n\nflipped::Bool = false: Whether to flip the ancilla qubit layout left to right.\ngate_type::Symbol = :cx: Type of two-qubit gate used in the circuit.\nancilla_measurement::Bool = true: Whether to include mid-circuit reset.\npad_identity::Bool = true: Whether to pad layers with single-qubit identity gates.\nsingle_qubit_time::Real = 32: Time taken to implement a single-qubit gate in nanoseconds.\ntwo_qubit_time::Real = 200: Time taken to implement a two-qubit gate in nanoseconds.\nmeas_reset_time::Real = 2500: Time taken to perform measurement and reset at the end of the circuit in nanoseconds.\nmeas_reset_time::Real = 2500: Time taken to perform mid-circuit reset in nanoseconds.\n\n\n\n\n\n","category":"method"},{"location":"internal/circuits/heavy_hex/#Private-functions","page":"circuits/heavy_hex.jl","title":"Private functions","text":"","category":"section"},{"location":"internal/circuits/heavy_hex/","page":"circuits/heavy_hex.jl","title":"circuits/heavy_hex.jl","text":"Modules = [QuantumACES]\nPages = [\"src/circuits/heavy_hex.jl\"]\nPublic = false","category":"page"},{"location":"internal/circuits/heavy_hex/#QuantumACES.heavy_hex_circuit-Tuple{HeavyHexParameters}","page":"circuits/heavy_hex.jl","title":"QuantumACES.heavy_hex_circuit","text":"heavy_hex_circuit(hex_param::HeavyHexParameters)\n\nReturns fields used to construct the syndrome extraction circuit of a heavy hex code based on the supplied parameters hex_param.\n\n\n\n\n\n","category":"method"},{"location":"#QuantumACES.jl","page":"Home","title":"QuantumACES.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"QuantumACES is a package for designing and simulating scalable and performant Pauli noise characterisation experiments for stabiliser circuits with averaged circuit eigenvalue sampling (ACES). It focuses on the context of quantum error correction and fault-tolerant circuits and, in particular, on the syndrome extraction circuits of topological quantum error correcting codes. It interfaces with Stim for stabiliser circuit simulation, PyMatching and BeliefMatching for decoding, and Qiskit for implementation on quantum devices.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Typical usage of QuantumACES involves first doing the following:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Construct the circuit and the noise model that you aim to characterise, either using existing functions or your own.\nOptimise an ACES experimental design for noise characterisation of a small-scale instance of the circuit, typically according to a deterministic noise model, such as depolarising noise, with roughly the same average error rates as the noise you aim to characterise.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This subsequently enables:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Transferring the optimised experimental design to larger-scale instances of the circuit, including with different noise models.\nSimulate noise characterisation experiments with ACES experimental designs, including at large scales, using Stim.\nCalculating performance predictions for experimental designs at small scales and fitting the performance predictions, in particular for syndrome extraction circuits as a function of the distance of the underlying code, to predict performance at large scales.\nSimulating memory experiments for syndrome extraction circuits using Stim, and then decoding with PyMatching or BeliefMatching with decoder priors informed by a range of noise models, including ACES noise estimates.\nCreating Pauli frame randomised ACES experimental designs, exporting them to Qiskit circuits, and processing the results, enabling implementation on quantum devices.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The methods used in this package are based on arXiv:2404.06545 and arXiv:2502.21044, and they build on the original ACES protocol introduced in arXiv:2108.05803.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The code for arXiv:2404.06545 can be found in the scalable_aces folder on the scalable_aces branch.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The code for arXiv:2502.21044 can be found in the aces_decoding folder on the aces_decoding branch.","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you find this package helpful for your research, please cite it using the supplied CITATION.cff file, and consider citing the associated papers if appropriate. If you wish to contribute to this package, please refer to the CONTRIBUTING.md file.","category":"page"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The Package Guide describes how you can start using QuantumACES, and Creating Circuits and Noise Models described the creation of new circuits and noise models to which the methods of QuantumACES can be applied.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The Package Performance section describes some important performance optimisations in QuantumACES.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The package reference documents the functions and types in QuantumACES, including internal functions. When making heavy use of the internal functions, you may find it convenient to import the package as ACES.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using QuantumACES\nimport QuantumACES as ACES","category":"page"},{"location":"internal/tuples/","page":"tuples.jl","title":"tuples.jl","text":"CollapsedDocStrings = true","category":"page"},{"location":"internal/tuples/#tuples.jl","page":"tuples.jl","title":"tuples.jl","text":"","category":"section"},{"location":"internal/tuples/#Public-functions","page":"tuples.jl","title":"Public functions","text":"","category":"section"},{"location":"internal/tuples/","page":"tuples.jl","title":"tuples.jl","text":"Modules = [QuantumACES]\nPages = [\"src/tuples.jl\"]\nPrivate = false","category":"page"},{"location":"internal/tuples/#QuantumACES.TupleSetData","page":"tuples.jl","title":"QuantumACES.TupleSetData","text":"TupleSetData\n\nData parameterising a tuple set.\n\nFields\n\ntuple_set::Vector{Vector{Int}}: The main tuple set, whose tuples are not repeated.\nrepeat_tuple_set::Vector{Vector{Int}}: The repeat tuple set, whose tuples are repeated according to the repeat_numbers.\nrepeat_numbers::Vector{Int}: The number of repetitions for tuples in the repeat tuple set repeat_tuple_set.\nrepeat_indices::Vector{Tuple{Int, Int}}: Indexes pairs (repeat_tuple, repeat_number) from (repeat_tuple_set, repeat_numbers) such that the repeated tuple set consists of repeat_tuple repeated repeat_number times for all indexed pairs.\n\n\n\n\n\n","category":"type"},{"location":"internal/tuples/#QuantumACES.get_augmented_tuple_set_data-Tuple{TupleSetData, Integer}","page":"tuples.jl","title":"QuantumACES.get_augmented_tuple_set_data","text":"get_augmented_tuple_set_data(tuple_set_data::TupleSetData, repeat_points::Integer; initial_shrink_factor::Real = 2^(repeat_points - 1))\n\nReturns an augmented version of the tuple set data tuple_set_data, where each of the repetition numbers is augmented to have repeat_points total repetition numbers, spaced logarithmically between the repetition number and the repetition number shrunk by a factor of initial_shrink_factor.\n\n\n\n\n\n","category":"method"},{"location":"internal/tuples/#QuantumACES.get_basic_tuple_set-Tuple{T} where T<:AbstractCircuit","page":"tuples.jl","title":"QuantumACES.get_basic_tuple_set","text":"get_basic_tuple_set(c::AbstractCircuit)\n\nReturns the basic tuple set for the circuit c.\n\n\n\n\n\n","category":"method"},{"location":"internal/tuples/#QuantumACES.get_circuit_tuple-Tuple{T} where T<:AbstractCircuit","page":"tuples.jl","title":"QuantumACES.get_circuit_tuple","text":"get_circuit_tuple(c::AbstractCircuit; include_reset::Bool = false)\n\nReturns the circuit tuple corresponding to the circuit c, including reset layers if include_reset is true.\n\n\n\n\n\n","category":"method"},{"location":"internal/tuples/#QuantumACES.get_tuple_set-Tuple{TupleSetData}","page":"tuples.jl","title":"QuantumACES.get_tuple_set","text":"get_tuple_set(tuple_set_data::TupleSetData)\n\nReturns the tuple set corresponding to the data tuple_set_data.\n\n\n\n\n\n","category":"method"},{"location":"internal/tuples/#QuantumACES.get_tuple_set_data-Union{Tuple{T}, Tuple{T, Vector{Vector{Int64}}}} where T<:AbstractCircuit","page":"tuples.jl","title":"QuantumACES.get_tuple_set_data","text":"get_tuple_set_data(c::AbstractCircuit; error_target::Real = 0.1, add_circuit::Bool = false)\nget_tuple_set_data(c::AbstractCircuit, tuple_set::Vector{Vector{Int}}; error_target::Real = 0.1, add_circuit::Bool = false)\n\nReturns the tuple set data corresponding to the circuit c, with the non-repeated tuples either being the supplied tuple_set or the basic tuple set for c. The repeat numbers are initialised to be inversely proportional to the average noise on the gates in the layers, which heuristically roughly target an error rate error_target, and the original circuit is added to the repeat tuples if add_circuit is true.\n\nNote that it appears best to use repeat tuples of order 2 (up to Paulis), with odd repeat numbers where this is efficient for measurement (such as repeating the same circuit layer many times), and even repeat numbers otherwise (such as syndrome extraction circuits).\n\n\n\n\n\n","category":"method"},{"location":"internal/tuples/#Private-functions","page":"tuples.jl","title":"Private functions","text":"","category":"section"},{"location":"internal/tuples/","page":"tuples.jl","title":"tuples.jl","text":"Modules = [QuantumACES]\nPages = [\"src/tuples.jl\"]\nPublic = false","category":"page"},{"location":"internal/tuples/#QuantumACES.check_tuple!-Union{Tuple{T}, Tuple{T, Vector{Int64}}} where T<:AbstractCircuit","page":"tuples.jl","title":"QuantumACES.check_tuple!","text":"check_tuple!(c::AbstractCircuit, circuit_tuple::Vector{Int})\ncheck_tuple!(c::AbstractCircuit, tuple_set::Vector{Vector{Int}})\n\nChecks that the tuple circuit_tuple, or each tuple in the tuple set tuple_set, is valid for the circuit c.\n\n\n\n\n\n","category":"method"},{"location":"internal/tuples/#QuantumACES.get_basic_experiment_numbers-Tuple{T} where T<:AbstractCircuit","page":"tuples.jl","title":"QuantumACES.get_basic_experiment_numbers","text":"get_basic_experiment_numbers(c::AbstractCircuit)\n\nReturns the experiment numbers corresponding to the basic tuple set for the circuit c.\n\nBEWARE: This currently assumes that circuit eigenvalues for Paulis supported on n qubits require preparing exactly and only 2^n sign configurations. Errors will occur if this is not the case, and they are not guaranteed to be noisy. If creating a circuit where this is not the case, you will need to provide new methods for this function.\n\n\n\n\n\n","category":"method"},{"location":"internal/tuples/#QuantumACES.get_basic_times_harm_mean-Tuple{T} where T<:AbstractCircuit","page":"tuples.jl","title":"QuantumACES.get_basic_times_harm_mean","text":"get_basic_times_harm_mean(c::AbstractCircuit)\n\nReturns the harmonic mean of the experiment times corresponding to the basic tuple set for the circuit c.\n\n\n\n\n\n","category":"method"},{"location":"internal/tuples/#QuantumACES.get_tuple_set_params-Union{Tuple{T}, Tuple{T, Vector{Vector{Int64}}, Vector{Int64}}} where T<:AbstractCircuit","page":"tuples.jl","title":"QuantumACES.get_tuple_set_params","text":"get_tuple_set_params(c::AbstractCircuit, tuple_set::Vector{Vector{Int}}, experiment_numbers::Vector{Int}; weight_experiments::Bool = true)\n\nReturns the time taken to implement each tuple and the default shot weights for each tuple orresponding to the circuit c with the tuple set tuple_set and the experiment numbers experiment_numbers. If weight_experiments is true, allocate the same sampling time to each experiment for each tuple; otherwise, allocate the same sampling time to each tuple overall. The default times allocate the same sampling time to each experiment for each tuple; this seems to be more performant than allocating the same sampling time to each tuple overall, as it allocates more samples to tuples that require more experiments.\n\n\n\n\n\n","category":"method"}]
}
