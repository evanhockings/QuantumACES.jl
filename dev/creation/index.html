<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Creating Circuits and Noise Models · QuantumACES.jl</title><meta name="title" content="Creating Circuits and Noise Models · QuantumACES.jl"/><meta property="og:title" content="Creating Circuits and Noise Models · QuantumACES.jl"/><meta property="twitter:title" content="Creating Circuits and Noise Models · QuantumACES.jl"/><meta name="description" content="Documentation for QuantumACES.jl."/><meta property="og:description" content="Documentation for QuantumACES.jl."/><meta property="twitter:description" content="Documentation for QuantumACES.jl."/><meta property="og:url" content="https://evanhockings.github.io/QuantumACES.jl/creation/"/><meta property="twitter:url" content="https://evanhockings.github.io/QuantumACES.jl/creation/"/><link rel="canonical" href="https://evanhockings.github.io/QuantumACES.jl/creation/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">QuantumACES.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../guide/">Package Guide</a></li><li class="is-active"><a class="tocitem" href>Creating Circuits and Noise Models</a></li><li><a class="tocitem" href="../performance/">Package Performance</a></li></ul></li><li><span class="tocitem">Reference</span><ul><li><input class="collapse-toggle" id="menuitem-3-1" type="checkbox"/><label class="tocitem" for="menuitem-3-1"><span class="docs-label">API</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../internal/QuantumACES/">QuantumACES.jl</a></li><li><a class="tocitem" href="../internal/tableau/">tableau.jl</a></li><li><a class="tocitem" href="../internal/noise/">noise.jl</a></li><li><a class="tocitem" href="../internal/noises/depolarising/">noises/depolarising.jl</a></li><li><a class="tocitem" href="../internal/noises/lognormal/">noises/lognormal.jl</a></li><li><a class="tocitem" href="../internal/circuit/">circuit.jl</a></li><li><a class="tocitem" href="../internal/circuits/rotated_planar/">circuits/rotated_planar.jl</a></li><li><a class="tocitem" href="../internal/circuits/unrotated_planar/">circuits/unrotated_planar.jl</a></li><li><a class="tocitem" href="../internal/circuits/heavy_hex/">circuits/heavy_hex.jl</a></li><li><a class="tocitem" href="../internal/stim/">stim.jl</a></li><li><a class="tocitem" href="../internal/tuples/">tuples.jl</a></li><li><a class="tocitem" href="../internal/design/">design.jl</a></li><li><a class="tocitem" href="../internal/rand_design/">rand_design.jl</a></li><li><a class="tocitem" href="../internal/merit/">merit.jl</a></li><li><a class="tocitem" href="../internal/optimise_weights/">optimise_weights.jl</a></li><li><a class="tocitem" href="../internal/optimise_tuples/">optimise_tuples.jl</a></li><li><a class="tocitem" href="../internal/estimate/">estimate.jl</a></li><li><a class="tocitem" href="../internal/simulate/">simulate.jl</a></li><li><a class="tocitem" href="../internal/device/">device.jl</a></li><li><a class="tocitem" href="../internal/scaling/">scaling.jl</a></li><li><a class="tocitem" href="../internal/kwargs/">kwargs.jl</a></li><li><a class="tocitem" href="../internal/utils/">utils.jl</a></li><li><a class="tocitem" href="../internal/io/">io.jl</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Creating Circuits and Noise Models</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Creating Circuits and Noise Models</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/evanhockings/QuantumACES.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/evanhockings/QuantumACES.jl/blob/main/docs/src/creation.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Creating-Circuits-and-Noise-Models"><a class="docs-heading-anchor" href="#Creating-Circuits-and-Noise-Models">Creating Circuits and Noise Models</a><a id="Creating-Circuits-and-Noise-Models-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-Circuits-and-Noise-Models" title="Permalink"></a></h1><p>QuantumACES makes it easy to create new circuits and noise models. At a high level, we create new parameter types for the circuit or noise model and then create new methods for the functions <a href="../internal/circuit/#QuantumACES.get_circuit-Union{Tuple{U}, Tuple{T}, Tuple{Vector{Layer}, Vector{Symbol}, Vector{Float64}, T}} where {T&lt;:AbstractNoiseParameters, U&lt;:AbstractCircuitParameters}"><code>get_circuit</code></a> and <a href="../internal/noises/depolarising/#QuantumACES.init_gate_probabilities-Tuple{Vector{Gate}, DepolarisingParameters}"><code>init_gate_probabilities</code></a>, respectively, that take these parameter types as arguments. Then <a href="../internal/circuit/#QuantumACES.get_circuit-Union{Tuple{U}, Tuple{T}, Tuple{Vector{Layer}, Vector{Symbol}, Vector{Float64}, T}} where {T&lt;:AbstractNoiseParameters, U&lt;:AbstractCircuitParameters}"><code>get_circuit</code></a> uses the circuit and noise model parameters to create a <a href="../internal/circuit/#QuantumACES.Circuit"><code>Circuit</code></a> object.</p><p>The <a href="../internal/circuit/#QuantumACES.Circuit"><code>Circuit</code></a> object enables the functionality we saw in <a href="../guide/#Example-usage">Example usage</a>, with two exceptions. First, calculating performance predictions requires the circuit to be parameterised by a <code>dist</code> parameter, typically the distance of the code underlying the syndrome extraction circuit. Second, simulating memory experiments in Stim requires the circuit to be a syndrome extraction annotated with the appropriate information. The <a href="../internal/circuit/#QuantumACES.Circuit"><code>Circuit</code></a> object contains an <code>extra_fields</code> field which is a dictionary that can store additional parameters to enable functionality such as this. In particular, syndrome extraction circuits must store a <a href="../internal/circuit/#QuantumACES.CodeParameters"><code>CodeParameters</code></a>object in this dictionary, which is then used to generate the detectors in Stim for memory experiment circuits, enabling decoding.</p><p>Let us begin by creating a new circuit, following the example circuit shown in Figure 2 of <a href="https://arxiv.org/abs/2404.06545">arXiv:2404.06545</a>. The first step is to create a parameter object for the circuit, which must be a subtype of <a href="../internal/QuantumACES/#QuantumACES.AbstractCircuitParameters"><code>AbstractCircuitParameters</code></a> and contain the necessary fields <code>params</code> and <code>circuit_name</code>, using the <code>StructEquality</code> package to automatically generate hash and equality relationships for the object to enable comparisons for the resulting <a href="../internal/circuit/#QuantumACES.Circuit"><code>Circuit</code></a> objects.</p><pre><code class="language-julia hljs">using QuantumACES, StructEquality
struct ExampleParameters &lt;: AbstractCircuitParameters
    params::Dict{Symbol, Any}
    circuit_name::String
    # Default constructor
    function ExampleParameters(params::Dict{Symbol, Any}, circuit_name::String)
        # Check circuit parameters are present
        @assert haskey(params, :pad_identity) &quot;The pad identity flag is missing.&quot;
        @assert haskey(params, :layer_time_dict) &quot;The layer time dictionary is missing.&quot;
        pad_identity = params[:pad_identity]
        layer_time_dict = params[:layer_time_dict]
        # Check some conditions
        @assert haskey(layer_time_dict, :single_qubit) &quot;The layer time dictionary must contain the key :single_qubit.&quot;
        @assert haskey(layer_time_dict, :two_qubit) &quot;The layer time dictionary must contain the key :two_qubit.&quot;
        @assert haskey(layer_time_dict, :meas_reset) &quot;The layer time dictionary must contain the key :meas_reset.&quot;
        @assert layer_time_dict[:single_qubit] &gt; 0.0 &quot;The single-qubit layer time must be positive.&quot;
        @assert layer_time_dict[:two_qubit] &gt; 0.0 &quot;The two-qubit layer time must be positive.&quot;
        @assert layer_time_dict[:meas_reset] &gt; 0.0 &quot;The measurement and reset time must be positive.&quot;
        # Set the circuit name
        new_circuit_name = &quot;example_circuit&quot;
        if pad_identity != true
            circuit_name *= &quot;_no_pad_identity&quot;
        end
        # Return parameters
        return new(params, new_circuit_name)::ExampleParameters
    end
end

@struct_hash_equal_isequal ExampleParameters</code></pre><p>We need a function to construct the parameter object.</p><pre><code class="language-julia hljs">function get_example_param(;
    pad_identity = true,
    single_qubit_time::Real = 29,
    two_qubit_time::Real = 29,
    meas_reset_time::Real = 660,
)
    # Construct the layer time dictionary
    layer_time_dict = Dict{Symbol, Float64}(
        :single_qubit =&gt; single_qubit_time,
        :two_qubit =&gt; two_qubit_time,
        :meas_reset =&gt; meas_reset_time,
    )
    # Construct the circuit parameters
    params = Dict{Symbol, Any}(
        :pad_identity =&gt; pad_identity,
        :layer_time_dict =&gt; layer_time_dict,
    )
    # Return parameters
    example_param = ExampleParameters(params, &quot;example_circuit&quot;)
    return example_param::ExampleParameters
end</code></pre><p>And we need a function to create the circuit from the parameter object.</p><pre><code class="language-julia hljs">function example_circuit(example_param::ExampleParameters)
    # Set up variables
    pad_identity = example_param.params[:pad_identity]
    layer_time_dict = example_param.params[:layer_time_dict]
    single_qubit_type = :single_qubit
    two_qubit_type = :two_qubit
    # Generate the circuit
    qubit_num = 3
    circuit = [
        Layer([Gate(&quot;CZ&quot;, 0, [2; 3])], qubit_num),
        Layer([Gate(&quot;CZ&quot;, 0, [1; 2]), Gate(&quot;H&quot;, 0, [3])], qubit_num),
        Layer([Gate(&quot;H&quot;, 0, [1]), Gate(&quot;S&quot;, 0, [2]), Gate(&quot;H&quot;, 0, [3])], qubit_num),
    ]
    layer_types = [two_qubit_type, two_qubit_type, single_qubit_type]
    layer_times = get_layer_times(layer_types, layer_time_dict)
    extra_fields = Dict{Symbol, Any}()
    # Pad each layer with identity gates if appropriate
    if pad_identity
        circuit = [pad_layer(l) for l in circuit]
    end
    return (
        circuit::Vector{Layer},
        layer_types::Vector{Symbol},
        layer_times::Vector{Float64},
        extra_fields::Dict{Symbol, Any},
    )
end</code></pre><p>Finally, we create a function that generates the circuit in the form of a <a href="../internal/circuit/#QuantumACES.Circuit"><code>Circuit</code></a> object. We do this by adding a method to <a href="../internal/circuit/#QuantumACES.get_circuit-Union{Tuple{U}, Tuple{T}, Tuple{Vector{Layer}, Vector{Symbol}, Vector{Float64}, T}} where {T&lt;:AbstractNoiseParameters, U&lt;:AbstractCircuitParameters}"><code>get_circuit</code></a> which uses the new parameter object as an argument, leveraging this circuit creation function.</p><pre><code class="language-julia hljs">function QuantumACES.get_circuit(
    example_param::ExampleParameters,
    noise_param::T;
    noisy_prep::Bool = false,
    noisy_meas::Bool = true,
    combined::Bool = haskey(noise_param.params, :combined) ? noise_param.params[:combined] :
                     false,
    strict::Bool = false,
) where {T &lt;: AbstractNoiseParameters}
    (circuit, layer_types, layer_times, extra_fields) = example_circuit(example_param)
    c = get_circuit(
        circuit,
        layer_types,
        layer_times,
        noise_param;
        circuit_param = example_param,
        extra_fields = extra_fields,
        noisy_prep = noisy_prep,
        noisy_meas = noisy_meas,
        combined = combined,
        strict = strict,
    )
    return c::Circuit
end</code></pre><p>Circuit creation works similarly for more complicated circuits, such as the syndrome extraction circuits generated for <a href="../internal/circuits/rotated_planar/#QuantumACES.RotatedPlanarParameters"><code>RotatedPlanarParameters</code></a>, <a href="../internal/circuits/unrotated_planar/#QuantumACES.UnrotatedPlanarParameters"><code>UnrotatedPlanarParameters</code></a>, and <a href="../internal/circuits/heavy_hex/#QuantumACES.HeavyHexParameters"><code>HeavyHexParameters</code></a>. These each have specialised methods added to <a href="../internal/circuit/#QuantumACES.get_circuit-Union{Tuple{U}, Tuple{T}, Tuple{Vector{Layer}, Vector{Symbol}, Vector{Float64}, T}} where {T&lt;:AbstractNoiseParameters, U&lt;:AbstractCircuitParameters}"><code>get_circuit</code></a> which uses these parameter structs as arguments.</p><p>If you wish to add additional information to a <a href="../internal/circuit/#QuantumACES.Circuit"><code>Circuit</code></a> object, store it in the <code>extra_fields</code> field, which for example can contain a <a href="../internal/circuit/#QuantumACES.CodeParameters"><code>CodeParameters</code></a> object that enables the construction and simulation of a memory circuit through <a href="../internal/stim/#QuantumACES.get_stim_memory_circuit-Union{Tuple{T}, Tuple{T, Dict{Gate, Vector{Float64}}, Symbol, Integer}} where T&lt;:AbstractCircuit"><code>get_stim_memory_circuit</code></a> and <a href="../internal/stim/#QuantumACES.simulate_memory-Union{Tuple{T}, Tuple{T, Integer, Integer}} where T&lt;:AbstractCircuit"><code>simulate_memory</code></a>.</p><p>Next, we will create a phenomenological noise model where each Pauli error probability has some probability <code>p</code> of occurring, so that two-qubit errors have a probability <code>p^2</code>. As with the circuit, we begin by creating a parameter object for the noise model, which must be a subtype of <a href="../internal/QuantumACES/#QuantumACES.AbstractNoiseParameters"><code>AbstractNoiseParameters</code></a> and contains the noise parameters in the necessary field <code>params</code>, as well as a name in the necessary field <code>noise_name</code>. Including a <code>combined</code> field in the noise model specifies to the circuit and experimental design whether to treat Pauli X, Y, and Z basis SPAM noise as the same.</p><pre><code class="language-julia hljs">struct PhenomenologicalParameters &lt;: AbstractNoiseParameters
    params::Dict{Symbol, Any}
    noise_name::String
    # Default constructor
    function PhenomenologicalParameters(params::Dict{Symbol, Any}, noise_name::String)
        # Check noise parameters are present
        @assert haskey(params, :p) &quot;The phenomenological gate error probability is missing.&quot;
        @assert haskey(params, :m) &quot;The measurement error probability is missing.&quot;
        @assert haskey(params, :m_r) &quot;The measurement reset error probability is missing.&quot;
        @assert haskey(params, :m_i) &quot;The measurement idle error probability is missing.&quot;
        @assert haskey(params, :combined) &quot;The combined flag is missing.&quot;
        p = params[:p]
        m = params[:m]
        m_r = params[:m_r]
        m_i = params[:m_i]
        combined = params[:combined]
        # Check some conditions
        @assert (p &gt;= 0) &amp;&amp; (p &lt;= 1 / 10) &quot;The phenomenological gate error probability $(p) is out of bounds.&quot;
        @assert (m &gt;= 0) &amp;&amp; (m &lt;= 1 / 2) &quot;The phenomenological measurement error probability $(m) is out of bounds.&quot;
        @assert (m_r &gt;= 0) &amp;&amp; (m_r &lt;= 1 / 2) &quot;The phenomenological measurement reset error probability $(m_r) is out of bounds.&quot;
        @assert (m_i &gt;= 0) &amp;&amp; (m_i &lt;= 1 / 4) &quot;The phenomenological measurement idle error probability $(m_i) is out of bounds.&quot;
        @assert typeof(combined) == Bool &quot;The combined flag $(combined) is not a Bool.&quot;
        # Return parameters with the appropriate name
        sigdigits = 3
        new_noise_name = &quot;phenomenological_$(round(p; sigdigits = sigdigits))_$(round(m; sigdigits = sigdigits))_$(round(m_r; sigdigits = sigdigits))_$(round(m_i; sigdigits = sigdigits))_$(combined)&quot;
        return new(params, new_noise_name)::PhenomenologicalParameters
    end
end</code></pre><p>We need a function to construct the parameter object.</p><pre><code class="language-julia hljs">function get_phen_param(
    p::Float64,
    m::Float64;
    m_r::Real = m,
    m_i::Real = m / 3,
    combined::Bool = false,
)
    params =
        Dict{Symbol, Any}(:p =&gt; p, :m =&gt; m, :m_r =&gt; m_r, :m_i =&gt; m_i, :combined =&gt; combined)
    phen_param = PhenomenologicalParameters(params, &quot;phenomenological&quot;)
    return phen_param::PhenomenologicalParameters
end</code></pre><p>And we need a function to create the noise model for a set of gates from the parameter object. As with the circuit, we add a method to <a href="../internal/noises/depolarising/#QuantumACES.init_gate_probabilities-Tuple{Vector{Gate}, DepolarisingParameters}"><code>init_gate_probabilities</code></a> which uses the new parameter object as an argument.</p><pre><code class="language-julia hljs">function QuantumACES.init_gate_probabilities(
    total_gates::Vector{Gate},
    phen_param::PhenomenologicalParameters,
)
    # Set up variables
    p = phen_param.params[:p]
    m = phen_param.params[:m]
    m_r = phen_param.params[:m_r]
    m_i = phen_param.params[:m_i]
    # Determine the weights of the Pauli errors
    one_qubit_support_size = ones(3)
    n = 2
    two_qubit_support_size = Vector{Int}()
    bit_array = BitArray(undef, 2n + 1)
    for bit_array.chunks[1] in 1:(4^n - 1)
        two_qubit_pauli = Pauli(convert(Vector{Bool}, bit_array), n)
        push!(two_qubit_support_size, length(get_support(two_qubit_pauli)))
    end
    @assert sum(two_qubit_support_size .== 1) == 6
    @assert sum(two_qubit_support_size .== 2) == 9
    @assert length(two_qubit_support_size) == 15
    # Generate the noise
    gate_probabilities = Dict{Gate, Vector{Float64}}()
    for gate in total_gates
        if is_spam(gate)
            gate_probs = [m]
        elseif is_mid_meas_reset(gate)
            gate_probs = [m_r]
        elseif is_meas_idle(gate)
            gate_probs = m_i .^ one_qubit_support_size
        else
            gate_support_size = length(gate.targets)
            if gate_support_size == 1
                gate_probs = p .^ one_qubit_support_size
            elseif gate_support_size == 2
                gate_probs = p .^ two_qubit_support_size
            else
                throw(error(&quot;The gate $(gate) is unsupported.&quot;))
            end
        end
        @assert sum(gate_probs) &lt; 1
        gate_probabilities[gate] = [1 - sum(gate_probs); gate_probs]
    end
    return gate_probabilities::Dict{Gate, Vector{Float64}}
end</code></pre><p>Noise model creation should follow the form of this example, much like the noise models <a href="../internal/noises/depolarising/#QuantumACES.DepolarisingParameters"><code>DepolarisingParameters</code></a> and <a href="../internal/noises/lognormal/#QuantumACES.LognormalParameters"><code>LognormalParameters</code></a>.</p><p>Now we are ready to reprise the basic usage example for this example circuit. First, parameterise depolarising and phenomenological noise models.</p><pre><code class="language-julia hljs">p = 0.025 / 100
m = 2.0 / 100
r_1 = 0.075 / 100
r_2 = 0.5 / 100
r_m = 2.0 / 100
phen_param = get_phen_param(p, m)
dep_param = get_dep_param(r_1, r_2, r_m)</code></pre><p>Then construct the circuit.</p><pre><code class="language-julia hljs">example_param = get_example_param()
circuit_example = get_circuit(example_param, dep_param)</code></pre><p>The default optimisation target is the generalised least squares (GLS) estimator, as it performs best, even if it cannot be scaled up to very large numbers of qubits. This is not an issue here because because the circuit acts on only three qubits. QuantumACES is geared towards syndrome extraction circuits, which typically are performant when repeated an even number of times. This is not guaranteed for the example circuit, so we set <code>add_circuit</code> to be <code>false</code>, though note this is the default behaviour.</p><pre><code class="language-julia hljs">add_circuit = false
repeat_points = 3
seed = UInt(0)
d = optimise_design(
    circuit_example;
    options = OptimOptions(;
        add_circuit = add_circuit,
        repeat_points = repeat_points,
        seed = seed,
    ),
)
merit = calc_merit(d)</code></pre><p>Now create a randomised experimental design for the circuit. This is not necessary for simulations, but is when implementing the experimental design on an actual quantum device.</p><pre><code class="language-julia hljs">min_randomisations = 50
target_shot_budget = 10^7
experiment_shots = 512
d_rand = generate_rand_design(
    d,
    min_randomisations,
    target_shot_budget,
    experiment_shots;
    seed = seed,
)
d_shot = get_design(d_rand)
merit_shot = calc_merit(d_shot)</code></pre><p>Create a copy of the optimised design that associates phenomenological noise with the circuit to compare the predicted performance of the experimental design with depolarising and phenomenological noise. In particular, we can predict the expectation and mean of the normalised root-mean-square (RMS) error between the estimated and true gate eigenvalues: either for all of the gate eigenvalues; or after marginalising eigenvalues across the Pauli orbits for each gate; or for those marginalised eigenvalues which can be estimated to relative precision, namely those not associated with state preparation and measurement (SPAM) noise.</p><pre><code class="language-julia hljs">d_phen = update_noise(d_shot, phen_param)
merit_phen = calc_merit(d_phen)</code></pre><p>We can also simulate noise characterisation experiments with this experimental design and phenomenological noise, and compare the performance to predictions by computing z-scores for the normalised RMS error with respect to the predicted expectation and variance. Note that the generalised least squares (GLS) estimator is the most performant and the focus here. It is implemented as an iterative feasible generalised least squares (FGLS) method.</p><pre><code class="language-julia hljs">budget_set = [10^6; 10^7; 10^8]
repetitions = 10
aces_data = simulate_aces(d_phen, budget_set; repetitions = repetitions, seed = seed)
pretty_print(aces_data, merit_phen)</code></pre><p>As before, note that the distribution of the normalised RMS error between the estimated and true gate eigenvalues is not quite normally distributed. Hence the z-scores shown here, which are normalised by the predicted performance of the experimental design, will not quite be normally distributed.</p><p>Now we can examine one of the tuples in the design and the corresponding experiments used to estimate its circuit eigenvalues.</p><pre><code class="language-julia hljs">example_tuple = [2; 3; 2; 1; 1]
idx = 9
@assert d_shot.tuple_set[idx] == example_tuple
experiment_set = d_shot.experiment_ensemble[idx]
example_mappings =
    [d_shot.mapping_ensemble[idx][experiment] for experiment in experiment_set]</code></pre><p>We can also examine slices from the gate eigenvalue estimator covariance matrix corresponding to a particular gate.</p><pre><code class="language-julia hljs">gls_covariance = calc_gls_covariance(d_shot)
gls_marginal_covariance = get_marginal_gate_covariance(d_shot, gls_covariance)
h_22_gate_index = d_shot.c.gate_data.gate_indices[4]
h_22_indices = h_22_gate_index.indices
h_22_marg_indices = h_22_gate_index.marg_indices
display(gls_covariance[h_22_indices, h_22_indices])
display(gls_marginal_covariance[h_22_marg_indices, h_22_marg_indices])</code></pre><p>For the Hadamard gate considered here, Pauli X and Z form one orbit, and Pauli Y forms the other. We see that the X and Z eigenvalues have large variance, but also large negative covariance, such that upon marginalisation over gate orbits, we see that the marginal orbit eigenvalue has small variance comparable to that of the Y eigenvalue. This demonstrates that ACES implicitly performs relative precision estimation of these marginal orbit eigenvalues.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../guide/">« Package Guide</a><a class="docs-footer-nextpage" href="../performance/">Package Performance »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.10.1 on <span class="colophon-date" title="Tuesday 1 April 2025 04:33">Tuesday 1 April 2025</span>. Using Julia version 1.11.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
