<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Package Guide · QuantumACES.jl</title><meta name="title" content="Package Guide · QuantumACES.jl"/><meta property="og:title" content="Package Guide · QuantumACES.jl"/><meta property="twitter:title" content="Package Guide · QuantumACES.jl"/><meta name="description" content="Documentation for QuantumACES.jl."/><meta property="og:description" content="Documentation for QuantumACES.jl."/><meta property="twitter:description" content="Documentation for QuantumACES.jl."/><meta property="og:url" content="https://evanhockings.github.io/QuantumACES.jl/guide/"/><meta property="twitter:url" content="https://evanhockings.github.io/QuantumACES.jl/guide/"/><link rel="canonical" href="https://evanhockings.github.io/QuantumACES.jl/guide/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">QuantumACES.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Manual</span><ul><li class="is-active"><a class="tocitem" href>Package Guide</a><ul class="internal"><li><a class="tocitem" href="#Installation-and-setup"><span>Installation and setup</span></a></li><li><a class="tocitem" href="#Example-usage"><span>Example usage</span></a></li></ul></li><li><a class="tocitem" href="../creation/">Creating Circuits and Noise Models</a></li><li><a class="tocitem" href="../performance/">Package Performance</a></li></ul></li><li><span class="tocitem">Reference</span><ul><li><input class="collapse-toggle" id="menuitem-3-1" type="checkbox"/><label class="tocitem" for="menuitem-3-1"><span class="docs-label">API</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../internal/QuantumACES/">QuantumACES.jl</a></li><li><a class="tocitem" href="../internal/tableau/">tableau.jl</a></li><li><a class="tocitem" href="../internal/noise/">noise.jl</a></li><li><a class="tocitem" href="../internal/noises/depolarising/">noises/depolarising.jl</a></li><li><a class="tocitem" href="../internal/noises/lognormal/">noises/lognormal.jl</a></li><li><a class="tocitem" href="../internal/circuit/">circuit.jl</a></li><li><a class="tocitem" href="../internal/circuits/rotated_planar/">circuits/rotated_planar.jl</a></li><li><a class="tocitem" href="../internal/circuits/unrotated_planar/">circuits/unrotated_planar.jl</a></li><li><a class="tocitem" href="../internal/circuits/heavy_hex/">circuits/heavy_hex.jl</a></li><li><a class="tocitem" href="../internal/stim/">stim.jl</a></li><li><a class="tocitem" href="../internal/tuples/">tuples.jl</a></li><li><a class="tocitem" href="../internal/design/">design.jl</a></li><li><a class="tocitem" href="../internal/rand_design/">rand_design.jl</a></li><li><a class="tocitem" href="../internal/merit/">merit.jl</a></li><li><a class="tocitem" href="../internal/optimise_weights/">optimise_weights.jl</a></li><li><a class="tocitem" href="../internal/optimise_tuples/">optimise_tuples.jl</a></li><li><a class="tocitem" href="../internal/estimate/">estimate.jl</a></li><li><a class="tocitem" href="../internal/simulate/">simulate.jl</a></li><li><a class="tocitem" href="../internal/device/">device.jl</a></li><li><a class="tocitem" href="../internal/scaling/">scaling.jl</a></li><li><a class="tocitem" href="../internal/kwargs/">kwargs.jl</a></li><li><a class="tocitem" href="../internal/utils/">utils.jl</a></li><li><a class="tocitem" href="../internal/io/">io.jl</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Package Guide</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Package Guide</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/evanhockings/QuantumACES.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/evanhockings/QuantumACES.jl/blob/main/docs/src/guide.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Package-Guide"><a class="docs-heading-anchor" href="#Package-Guide">Package Guide</a><a id="Package-Guide-1"></a><a class="docs-heading-anchor-permalink" href="#Package-Guide" title="Permalink"></a></h1><p>QuantumACES is a package for designing and simulating scalable and performant Pauli noise characterisation experiments for stabiliser circuits with averaged circuit eigenvalue sampling (ACES). It focuses on the context of quantum error correction and fault-tolerant circuits and, in particular, on the syndrome extraction circuits of topological quantum error correcting codes. It interfaces with <a href="https://github.com/quantumlib/Stim">Stim</a> for stabiliser circuit simulation, <a href="https://github.com/oscarhiggott/PyMatching">PyMatching</a> and <a href="https://github.com/oscarhiggott/BeliefMatching">BeliefMatching</a> for decoding, and <a href="https://github.com/Qiskit/qiskit">Qiskit</a> for implementation on quantum devices.</p><p>Typical usage of QuantumACES involves first doing the following:</p><ul><li>Construct the circuit and the noise model that you aim to characterise, either using existing functions or your own.</li><li>Optimise an ACES experimental design for noise characterisation of a small-scale instance of the circuit, typically according to a deterministic noise model, such as depolarising noise, with roughly the same average error rates as the noise you aim to characterise.</li></ul><p>This subsequently enables:</p><ul><li>Transferring the optimised experimental design to larger-scale instances of the circuit, including with different noise models.</li><li>Simulate noise characterisation experiments with ACES experimental designs, including at large scales, using Stim.</li><li>Calculating performance predictions for experimental designs at small scales and fitting the performance predictions, in particular for syndrome extraction circuits as a function of the distance of the underlying code, to predict performance at large scales.</li><li>Simulating memory experiments for syndrome extraction circuits using Stim, and then decoding with PyMatching or BeliefMatching with decoder priors informed by a range of noise models, including ACES noise estimates.</li><li>Creating Pauli frame randomised ACES experimental designs, exporting them to Qiskit circuits, and processing the results, enabling implementation on quantum devices.</li></ul><p>The methods used in this package are based on <a href="https://arxiv.org/abs/2404.06545">arXiv:2404.06545</a> and <a href="https://arxiv.org/abs/2502.21044">arXiv:2502.21044</a>, and they build on the original ACES protocol introduced in <a href="https://arxiv.org/abs/2108.05803">arXiv:2108.05803</a>.</p><p>The code for <a href="https://arxiv.org/abs/2404.06545">arXiv:2404.06545</a> can be found in the <code>scalable_aces</code> folder on the <a href="https://github.com/evanhockings/QuantumACES.jl/tree/scalable_aces">scalable_aces</a> branch.</p><p>The code for <a href="https://arxiv.org/abs/2502.21044">arXiv:2502.21044</a> can be found in the <code>aces_decoding</code> folder on the <a href="https://github.com/evanhockings/QuantumACES.jl/tree/aces_decoding">aces_decoding</a> branch.</p><p>If you find this package helpful for your research, please cite it using the supplied <code>CITATION.cff</code> file, and consider citing the associated papers if appropriate. If you wish to contribute to this package, please refer to the <code>CONTRIBUTING.md</code> file.</p><h2 id="Installation-and-setup"><a class="docs-heading-anchor" href="#Installation-and-setup">Installation and setup</a><a id="Installation-and-setup-1"></a><a class="docs-heading-anchor-permalink" href="#Installation-and-setup" title="Permalink"></a></h2><p>To install this package, run the following command in the Julia REPL.</p><pre><code class="nohighlight hljs">] add QuantumACES</code></pre><p>BEWARE: This package uses <a href="https://github.com/JuliaPy/PythonCall.jl">PythonCall</a> to call a number of Python packages. If PythonCall and these packages are not configured correctly, associated functions will not work. The packages attempts to load the following Python packages:</p><ul><li><a href="https://github.com/quantumlib/Stim">Stim</a>, installed with <code>pip install stim</code>.</li><li><a href="https://github.com/oscarhiggott/PyMatching">PyMatching</a>, installed with <code>pip install pymatching</code>.</li><li><a href="https://github.com/oscarhiggott/BeliefMatching">BeliefMatching</a>, installed with <code>pip install beliefmatching</code>.</li><li><a href="https://github.com/Qiskit/qiskit">Qiskit</a>, installed with <code>pip install qiskit</code>.</li><li><a href="https://github.com/Qiskit/qiskit-aer">Aer</a>, installed with <code>pip install qiskit-aer</code>.</li></ul><p>By default, PythonCall creates its own Python environment, but you may wish to use an existing Python installation.</p><p>One helpful method for managing Python versions is <a href="https://github.com/pyenv/pyenv">pyenv</a>, or for Windows, <a href="https://github.com/pyenv-win/pyenv-win">pyenv-win</a>; these are analogous to <a href="https://github.com/JuliaLang/juliaup">Juliaup</a> for Julia. The following assumes you are using pyenv or pyenv-win.</p><p>On Windows, to instruct PythonCall to use the Python version set by pyenv, configure PythonCall&#39;s environment variables by adding the following to your <code>~/.julia/config/startup.jl</code> file</p><pre><code class="language-julia hljs">ENV[&quot;JULIA_CONDAPKG_BACKEND&quot;] = &quot;Null&quot;
python_exe = readchomp(`cmd /C pyenv which python`)
ENV[&quot;JULIA_PYTHONCALL_EXE&quot;] = python_exe</code></pre><p>On Unix systems, shell commands are parsed directly by Julia and appear to be unaware of your PATH variable, and I am not sure how to work around this. Therefore, you may need to manually supply <code>python_exe</code> for the Python version <code>&lt;version&gt;</code> as</p><pre><code class="language-julia hljs">python_exe = homedir() * &quot;/.pyenv/versions/&lt;version&gt;/bin/python&quot;</code></pre><h2 id="Example-usage"><a class="docs-heading-anchor" href="#Example-usage">Example usage</a><a id="Example-usage-1"></a><a class="docs-heading-anchor-permalink" href="#Example-usage" title="Permalink"></a></h2><p>Beware that the examples shown below can take a long time to run. Ensure that Julia is set up to use as many threads as your CPU can handle. For example usage that is faster to run, see <a href="../creation/#Creating-Circuits-and-Noise-Models">Creating Circuits and Noise Models</a>.</p><p>First parameterise a depolarising noise model with single-qubit gate infidelity <code>r_1</code>, two-qubit gate infidelity <code>r_2</code>, and measurement infidelity <code>r_m</code>, and a log-normal random Pauli noise model with the same gate infidelities and a standard deviation of the underlying normal distributions <code>total_std_log</code>, specifying the seed <code>seed</code> for reproducibility.</p><pre><code class="language-julia hljs">using QuantumACES
r_1 = 0.05 / 100
r_2 = 0.4 / 100
r_m = 0.8 / 100
total_std_log = 0.5
seed = UInt(0)
dep_param = get_dep_param(r_1, r_2, r_m)
log_param = get_log_param(r_1, r_2, r_m, total_std_log; seed = seed)</code></pre><p>Similarly, we create circuit parameters for the syndrome extraction circuit of a distance <code>dist</code> (rotated) surface code.</p><pre><code class="language-julia hljs">dist = 3
rotated_param = get_rotated_param(dist)</code></pre><p>Next, we create versions of this circuit with both noise models.</p><pre><code class="language-julia hljs">circuit_dep = get_circuit(rotated_param, dep_param)
circuit_log = get_circuit(rotated_param, log_param)</code></pre><p>Now we can generate an experimental design for this circuit.</p><pre><code class="language-julia hljs">d = generate_design(circuit_dep)</code></pre><p>Alternatively, we can optimise an experimental design to improve its sample efficiency, configuring the optimisation with the parameters associated with <a href="../internal/kwargs/#QuantumACES.OptimOptions"><code>OptimOptions</code></a>.</p><pre><code class="language-julia hljs">d = optimise_design(circuit_dep; options = OptimOptions(; seed = seed))</code></pre><p>There are a number of options that allow you to reduce the optimisation time. For example, we can disable cyclic coordinate descent optimisation of the circuit depth of repeated tuples in the design by setting <code>max_cycles = 0</code>. We can also allow the greedy search over ordinary tuples to terminate once they are left unchanged by single excursion in the search by setting <code>excursions_unchanged = 1</code>.</p><pre><code class="language-julia hljs">d = optimise_design(
    circuit_dep;
    options = OptimOptions(; max_cycles = 0, excursions_unchanged = 1, seed = seed),
)</code></pre><p>This experimental design can be transferred to the circuit with the log-normal Pauli noise model.</p><pre><code class="language-julia hljs">d_log = generate_design(circuit_log, d)</code></pre><p>If we only wish to update the noise model, however, we can do this more efficiently.</p><pre><code class="language-julia hljs">d_log = update_noise(d, circuit_log)</code></pre><p>Now we can simulate <code>repetitions</code> instances of ACES noise characterisation across a range of measurement budgets <code>budget_set</code>, which are measurement shots normalised by the time taken to perform the experiment.</p><pre><code class="language-julia hljs">budget_set = [10^6; 10^7; 10^8]
repetitions = 20
aces_data = simulate_aces(d_log, budget_set; repetitions = repetitions, seed = seed)</code></pre><p>We can compare the performance to predictions, although we note that the z-scores will not quite be normally distributed as the underlying distribution is not quite normal.</p><pre><code class="language-julia hljs">merit_log = calc_merit(d_log)
pretty_print(aces_data, merit_log)</code></pre><p>We can also simulate ACES noise characterisation at scale. First create a new design at a large code distance <code>dist_big</code>. Setting <code>full_covariance</code> to be false means only the diagonal circuit eigenvalue estimator covariance matrix is generated, which saves a substantial amount of time. It also prevents the design from attempting to perform generalised least squares (GLS) with the full covariance matrix, which can consume large amounts of memory at large scales, restricting the design to weighted least squares (WLS).</p><pre><code class="language-julia hljs">dist_big = 13
rotated_param_big = get_rotated_param(dist_big)
circuit_big = get_circuit(rotated_param_big, dep_param)
circuit_big_log = get_circuit(rotated_param_big, log_param)
d_big = generate_design(circuit_big_log, d; full_covariance = false, diagnostics = true)</code></pre><p>Now simulate this new design, setting <code>split</code> to be <code>true</code> to avoid memory issues by splitting projection of the gate error probabilities into the simplex across each of the gates, rather than doing all gates collectively.</p><pre><code class="language-julia hljs">aces_data_big = simulate_aces(d_big, budget_set; seed = seed, split = true)</code></pre><p>It is expensive to directly calculate the performance of the experimental design at this scale. Instead, we calculate the performance scaling of the experimental design at small code distances and then extrapolate. We can do this for depolarising noise, and for an average over instances of log-normal Pauli noise, calculating up to <code>dist_max</code>, and then extracting fits.</p><pre><code class="language-julia hljs">dist_max = 7
merit_scaling = calc_merit_scaling(d, dist_max)
scaling_fit = get_scaling_fit(merit_scaling)
ensemble_scaling = calc_ensemble_scaling(d_log, dist_max; seed = seed)
ensemble_fit = get_ensemble_fit(ensemble_scaling)</code></pre><p>This allows us to predict expectations and variances, and compare them to the true values, for both the ordinary figure of merit and the relative precision figure of merit. These are not exactly z-scores in particular because the simulation was for a single instance of log-normal Pauli noise, whereas the predictions are averaged over instances. In practice, performance appears to be self-averaging so prediction works well at scale.</p><pre><code class="language-julia hljs">wls_pred_expectation = ensemble_fit.wls_expectation_model(dist_big)
wls_pred_variance = ensemble_fit.wls_variance_model(dist_big)
wls_scores_big = [
    (noise_error.wls_nrmse .- wls_pred_expectation) / sqrt(wls_pred_variance) for
    noise_error in aces_data_big.noise_error_coll[1, :]
]
wls_pred_relative_expectation = ensemble_fit.wls_relative_expectation_model(dist_big)
wls_pred_relative_variance = ensemble_fit.wls_relative_variance_model(dist_big)
wls_relative_scores_big = [
    (noise_error.wls_relative_nrmse .- wls_pred_relative_expectation) /
    sqrt(wls_pred_relative_variance) for
    noise_error in aces_data_big.noise_error_coll[1, :]
]</code></pre><p>We can now use Stim to simulate a memory experiment with <code>big_rounds</code> rounds, sampling <code>big_shots</code> shots. We inform the decoder, PyMatching by default, with a range of noise models including our noise estimates.</p><pre><code class="language-julia hljs">big_rounds = dist_big
big_shots = 5 * 10^6
decoder_gate_probabilities = [
    circuit_big_log.gate_probabilities
    circuit_big.gate_probabilities
    [noise_est.wls_gate_probabilities 
    for noise_est in aces_data_big.noise_est_coll[1, :]
    ]
]
decoder_labels = [
    &quot;True&quot;
    &quot;Depolarising&quot;
    [&quot;ACES S=$(budget)&quot; for budget in budget_set]
]
big_memory_data = simulate_memory(circuit_big_log, big_rounds, big_shots;
    seed = seed,
    decoder_gate_probabilities = decoder_gate_probabilities,
    decoder_labels = decoder_labels,
    diagnostics = true,
)
big_memory_summary = get_memory_summary(big_memory_data)</code></pre><p>To implement this experimental design on an actual quantum device, we need to first construct a Pauli frame randomised version of the experimental design and generate corresponding Qiskit circuits. We specify a minimum number of randomisations <code>min_randomisations</code> and a target shot budget <code>target_shot_budget</code>, and <code>experiment_shots</code> shots per randomised experiment.</p><pre><code class="language-julia hljs">min_randomisations = 64
target_shot_budget = 5 * 10^6
experiment_shots = 64
d_rand = generate_rand_design(
    d_log,
    min_randomisations,
    target_shot_budget,
    experiment_shots;
    seed = seed,
)</code></pre><p>This modifies the shot weights, so we can calculate the merit of this new design.</p><pre><code class="language-julia hljs">d_shot = get_design(d_rand)
merit_shot = calc_merit(d_shot)</code></pre><p>Now we simultaneously generate ensembles of Stim and Qiskit circuits that implement this experimental design. The Qiskit circuits act on <code>qiskit_qubit_num</code> qubits and <code>qiskit_qubit_map</code> maps QuantumACES qubit indices to Qiskit qubit indices, noting that Julia indexes from 1 whereas Python indexes from 0.</p><pre><code class="language-julia hljs">qiskit_qubit_num = 17
qiskit_qubit_map = collect(0:(qiskit_qubit_num - 1))
(stim_ensemble, qiskit_ensemble) =
    get_stim_qiskit_ensemble(d_rand, qiskit_qubit_num, qiskit_qubit_map)</code></pre><p>We only simulate in Stim as the Qiskit stabiliser circuit simulator is much slower.</p><pre><code class="language-julia hljs">simulate_stim_ensemble(d_rand, stim_ensemble, experiment_shots; seed = seed)
rand_noise_est = estimate_stim_ensemble(d_rand, experiment_shots; simulation_seed = seed)
rand_noise_error = get_noise_error(d_rand, rand_noise_est)
rand_noise_score = get_noise_score(rand_noise_error, merit_shot)</code></pre><p>Suppose we then run the Qiskit circuits on a quantum device. The results must be stored in an appropriate folder to be processed. Given a prefix <code>backend</code>, which typically describes the device on which the circuits are run, the results must be stored relative to the current directory in a folder whose name is given by <code>qiskit_results_folder</code>.</p><pre><code class="language-julia hljs">backend = &quot;backend&quot;
d_rand_filename = rand_design_filename(d_rand)
@assert d_rand_filename[(end - 4):end] == &quot;.jld2&quot;
qiskit_results_folder = &quot;data/$(backend)_$(d_rand_filename[1:(end - 5)])&quot;</code></pre><p>The ensemble <code>qiskit_ensemble</code> is a vector containing vectors of Qiskit circuits, each of which comprise a job. Each job should be stored as a pickle in <code>qiskit_results_folder</code> with prefix <code>prefix</code>, followed by an underscore and the job index, starting from 1.</p><pre><code class="language-julia hljs">prefix = &quot;job&quot;
example_job_1_filename = &quot;$(qiskit_results_folder)/$(prefix)_1.pickle&quot;</code></pre><p>Then it is simple to process the data and estimate the noise.</p><pre><code class="language-julia hljs">process_qiskit_ensemble(
    d_rand,
    qiskit_qubit_num,
    qiskit_qubit_map,
    experiment_shots;
    backend = backend,
    prefix = prefix,
)
noise_est =
    estimate_qiskit_ensemble(d_rand, qiskit_qubit_map, experiment_shots; backend = backend)</code></pre><p>Finally, we can analyse the consistency of this noise estimate with our noise model.</p><pre><code class="language-julia hljs">model_violation = get_model_violation(d_shot, noise_est)</code></pre><p>This quantity is a z-score which is approximately normally distributed if the circuit-level Pauli noise model is upheld, as it is in simulation. Note the model violation score is substantially larger when calculated for the projected noise estimates, that is, the noise estimates after projecting the Pauli error probabilities into the probability simplex even in simulation. By default, then, this function calculates the model violation for the unprojected noise estimates.</p><p>We can also create a version of the experimental design corresponding to a combined noise model for which Pauli <span>$X$</span>, <span>$Z$</span>, and <span>$Y$</span> basis SPAM noise are combined into a single parameter for each qubit, so that for <span>$n$</span> qubits we have <span>$n$</span> SPAM noise parameters. Previously, we considered <span>$3n$</span> SPAM noise parameters for each Pauli basis, which we will call the ordinary noise model. Then we can estimate the noise with the combined noise model and calculate its model violation.</p><pre><code class="language-julia hljs">d_comb = get_combined_design(d_shot)
comb_noise_est = estimate_gate_noise(d_comb, noise_est)
comb_model_violation = get_model_violation(d_comb, comb_noise_est)</code></pre><p>We might want to perform model selection with the Akaike information criterion (AIC) or the Bayesian information criterion (BIC), which are straightforward to calculate.</p><pre><code class="language-julia hljs">aic = get_aic(d_shot, noise_est)
bic = get_bic(d_shot, noise_est)
comb_aic = get_aic(d_comb, comb_noise_est)
comb_bic = get_bic(d_comb, comb_noise_est)</code></pre><p>The preferred model is the one that minimises the AIC or BIC, depending on the metric of choice. In practice, the combined noise model tends not to be formally preferred but is nevertheless more parsimonious as the SPAM noise estimates in the ordinary noise model differ across Pauli bases more than can reasonably be expected. Therefore we tend not to use this model selection procedure.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../creation/">Creating Circuits and Noise Models »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.10.2 on <span class="colophon-date" title="Tuesday 6 May 2025 18:03">Tuesday 6 May 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
