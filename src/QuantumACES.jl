"""
QuantumACES is a package for designing and simulating scalable and performant Pauli noise characterisation experiments for stabiliser circuits with averaged circuit eigenvalue sampling (ACES).
It focuses on the context of quantum error correction and fault-tolerant circuits and, in particular, on the syndrome extraction circuits of topological quantum error correcting codes.
It interfaces with [Stim](https://github.com/quantumlib/Stim) for stabiliser circuit simulation, [PyMatching](https://github.com/oscarhiggott/PyMatching) and [BeliefMatching](https://github.com/oscarhiggott/BeliefMatching) for decoding, and [Qiskit](https://github.com/Qiskit/qiskit) for implementation on quantum devices.

The methods used in this package are based on [arXiv:2404.06545](https://arxiv.org/abs/2404.06545) and [arXiv:2502.21044](https://arxiv.org/abs/2502.21044), and they build on the original ACES protocol introduced in [arXiv:2108.05803](https://arxiv.org/abs/2108.05803).

The code for [arXiv:2404.06545](https://arxiv.org/abs/2404.06545) can be found in the `scalable_aces` folder on the [scalable_aces](https://github.com/evanhockings/QuantumACES.jl/tree/scalable_aces) branch.

The code for [arXiv:2502.21044](https://arxiv.org/abs/2502.21044) can be found in the `aces_decoding` folder on the [aces_decoding](https://github.com/evanhockings/QuantumACES.jl/tree/aces_decoding) branch.
"""
module QuantumACES

# Core imports
using Base.Threads, PythonCall, LinearAlgebra, SparseArrays, StatsBase, Random

# Utility imports
using Accessors, StructEquality, PrettyTables, JLD2

# Calculation imports
import Arpack, SCS, QuadGK, FiniteDifferences, LsqFit

# Python imports
const pickle = PythonCall.pynew()
const stim = PythonCall.pynew()
const Matching = PythonCall.pynew()
const BeliefMatching = PythonCall.pynew()
const qiskit = PythonCall.pynew()
const aer = PythonCall.pynew()
const pickle_load = Ref{Bool}(false)
const stim_load = Ref{Bool}(false)
const Matching_load = Ref{Bool}(false)
const BeliefMatching_load = Ref{Bool}(false)
const qiskit_load = Ref{Bool}(false)
const aer_load = Ref{Bool}(false)
function __init__()
    try
        PythonCall.pycopy!(pickle, pyimport("pickle"))
        pickle_load[] = true
    catch
        @warn "Failed to import `pickle`. Associated functions will not work."
    end
    try
        PythonCall.pycopy!(stim, pyimport("stim"))
        stim_load[] = true
    catch
        @warn "Failed to import `stim`. Associated functions will not work."
    end
    try
        PythonCall.pycopy!(Matching, pyimport("pymatching" => "Matching"))
        Matching_load[] = true
    catch
        @warn "Failed to import the `pymatching` decoder. Associated functions will not work."
    end
    try
        PythonCall.pycopy!(BeliefMatching, pyimport("beliefmatching" => "BeliefMatching"))
        BeliefMatching_load[] = true
    catch
        @warn "Failed to import the `beliefmatching` decoder. Associated functions will not work."
    end
    try
        PythonCall.pycopy!(qiskit, pyimport("qiskit"))
        qiskit_load[] = true
    catch
        @warn "Failed to import `qiskit`. Associated functions will not work."
    end
    try
        PythonCall.pycopy!(aer, pyimport("qiskit_aer"))
        aer_load[] = true
    catch
        @warn "Failed to import `qiskit_aer`. Associated functions will not work."
    end
    return nothing
end

# Abstract types
"""
    AbstractNoiseParameters

Noise parameters should be stored in a subtype `T <: AbstractNoiseParameters`.

Noise models should be generated by a method of [`init_gate_probabilities`](@ref), which generates Pauli error probabilities for the supplied gates according to some supplied noise parameters.

# Necessary fields

  - `params::Dict{Symbol, Any}`: Dictionary of the noise parameters.
  - `noise_name::String`: Name of the noise model, which should implicitly describe parameter settings.
"""
abstract type AbstractNoiseParameters end

"""
    AbstractCircuitParameters

Circuit parameters should be stored in a subtype `T <: AbstractCircuitParameters`.

Then add a method to [`get_circuit`](@ref) that generates a circuit according to these parameters.
Such a circuit should either be a [`Circuit`](@ref) object, or a subtype `T <: AbstractCircuit`.

# Necessary fields

  - `params::Dict{Symbol, Any}`: Dictionary of the circuit parameters, which should in particular include a `layer_time_dict` field, which is a dictionary of the times taken to implement the different types of layers in the circuit, including the time for measurement and reset.
  - `circuit_name::String`: Name of the circuit, which should implicitly describe parameter settings.
"""
abstract type AbstractCircuitParameters end

"""
    AbstractCircuit

Circuits should be stored in a subtype `T <: AbstractCircuit`, and generated by a method of [`get_circuit`](@ref).

# Necessary fields

  - `circuit_param::AbstractCircuitParameters`: Circuit parameters.
  - `circuit::Vector{Layer}`: Circuit.
  - `circuit_tuple::Vector{Int}`: Tuple which arranges the order of the circuit layers; this is initialised as trivial.
  - `qubit_num::Int`: Number of qubits in the circuit.
  - `unique_layer_indices::Vector{Int}`: Unique non-measurement gate layer indices of the circuit.
  - `layer_types::Vector{Symbol}`: Types of the layers in the circuit, used for layer times and dynamical decoupling.
  - `layer_times::Vector{Float64}`: Times taken to implement each layer in the circuit, as well as measurement and reset.
  - `gates::Vector{Gate}`: Gates in the circuit arranged by the tuple.
  - `total_gates::Vector{Gate}`: Total gates in the circuit, including preparations if `noisy_prep` and measurements if `noisy_meas`.
  - `gate_index::Dict{Gate, Int}`: Index of the gate eigenvalues for each gate in the original circuit.
  - `N::Int`: Number of gate eigenvalues.
  - `marginal_gate_index::Dict{Gate, Int}`: Index of the marginal gate eigenvalues for each gate in the original circuit, where the marginals are determined by the Pauli orbits specified in [`get_orbit_indices_dict`](@ref).
  - `N_marginal::Int`: Number of marginal gate eigenvalues.
  - `N_relative::Int`: Number of relative gate eigenvalues.
  - `noise_param::AbstractNoiseParameters`: Noise parameters.
  - `gate_probabilities::Dict{Gate, Vector{Float64}}`: Pauli error probabilities for each gate, stored as a dictionary.
  - `gate_eigenvalues::Vector{Float64}`: Eigenvalues for each gate, stored as a vector whose order is determined by `gate_index`.
  - `marginal_gate_probabilities::Dict{Gate, Vector{Float64}}`: Marginal Pauli error probabilities for each gate, stored as a dictionary.
  - `marginal_gate_eigenvalues::Vector{Float64}`: Marginal eigenvalues for each gate, stored as a vector whose order is determined by `marginal_gate_index`.
  - `relative_gate_eigenvalues::Vector{Float64}`: Marginal eigenvalues for each gate whose marginal eigenvalues can be estimated to relative precision, namely those which are not preparation or measurement, stored as a vector whose order is determined by `marginal_gate_index`.
  - `noisy_prep::Bool`: Whether to treat preparations as noisy and characterise the associated noise, which should default to `false`; a full-rank design cannot be produced if both `noisy_prep` and `noisy_meas` are `true`.
  - `noisy_meas::Bool`: Whether to treat measurements as noisy and characterise the associated noise, which should default to `true`; a full-rank design cannot be produced if both `noisy_prep` and `noisy_meas` are `true`.
  - `extra_fields::Dict{Symbol, Any}`: Extra data for the circuit, including code parameters for syndrome extraction circuits stored as a `:code_param` field which is a [`CodeParameters`](@ref) object.
"""
abstract type AbstractCircuit end

"""
    AbstractCodeParameters

Code parameters for syndrome extraction circuits should be stored in subtypes `T <: AbstractCodeParameters`, usually a [`CodeParameters`](@ref) object.
"""
abstract type AbstractCodeParameters end

"""
    AbstractScalingData

Scaling data for the figure of merit should be stored in a subtype `T <: AbstractScalingData`.
"""
abstract type AbstractScalingData end

export AbstractNoiseParameters,
    AbstractCircuitParameters, AbstractCircuit, AbstractCodeParameters, AbstractScalingData

# Struct exports
export
    # kwargs.jl
    OptimOptions,
    # tableau.jl structs 
    Tableau,
    Gate,
    Layer,
    # noise.jl structs
    GateIndex,
    GateData,
    # noises/depolarising.jl structs
    DepolarisingParameters,
    # noises/lognormal.jl structs
    LognormalParameters,
    # circuit.jl structs
    Circuit,
    EmptyCircuitParameters,
    CodeParameters,
    # circuits/rotated_planar.jl structs
    RotatedPlanarParameters,
    # circuits/unrotated_planar.jl structs
    UnrotatedPlanarParameters,
    # circuits/heavy_hex.jl structs
    HeavyHexParameters,
    # stim.jl structs
    MemoryData,
    MemorySummary,
    # tuples.jl structs
    TupleSetData,
    # design.jl structs
    Pauli,
    Mapping,
    Design,
    # rand_design.jl structs
    RandDesign,
    # merit.jl structs
    Merit,
    # estimate.jl structs
    NoiseEstimate,
    NoiseError,
    NoiseScore,
    # simulate.jl structs
    ACESData,
    # scaling.jl structs
    MeritScaling,
    EnsembleScaling,
    ScalingFit,
    EnsembleFit

# Function exports
export
    # tableau.jl functions
    apply!,
    make_layer,
    get_one_qubit_gates,
    get_two_qubit_gates,
    is_state_prep,
    is_state_meas,
    is_spam,
    is_mid_meas,
    is_mid_reset,
    is_mid_meas_reset,
    is_meas_idle,
    is_additive,
    is_pauli,
    is_one_qubit,
    is_two_qubit,
    pad_layer,
    # noise.jl functions
    get_orbit_indices_dict,
    get_gate_data,
    get_wht_matrix,
    get_marginal_wht_matrix,
    get_gate_eigenvalues,
    get_gate_probabilities,
    get_combined_gate_probabilities,
    get_average_gate_probabilities,
    get_full_average_gate_probabilities,
    get_marginal_gate_probabilities,
    get_relative_gate_probabilities,
    get_marginal_gate_eigenvalues,
    get_relative_gate_eigenvalues,
    # noises functions
    init_gate_probabilities,
    # noises/depolarising.jl functions
    get_dep_param,
    # noises/lognormal.jl functions
    get_log_param,
    # circuit.jl functions
    update_noise,
    get_layer_times,
    get_circuit,
    get_combined_circuit,
    # circuits/rotated_planar.jl functions
    get_rotated_param,
    # circuits/unrotated_planar.jl functions
    get_unrotated_param,
    # circuits/heavy_hex.jl functions
    get_hex_param,
    # stim.jl functions
    get_stim_circuit,
    get_stim_memory_circuit,
    simulate_memory,
    get_memory_summary,
    round_exponential_model,
    fit_round_error,
    get_round_error,
    dist_linear_model,
    fit_dist_error,
    get_dist_error,
    calc_memory_distances,
    # tuples.jl functions
    get_basic_tuple_set,
    get_circuit_tuple,
    get_tuple_set_data,
    get_augmented_tuple_set_data,
    get_tuple_set,
    # design.jl functions
    get_eigenvalues,
    generate_design,
    get_full_design,
    get_diag_design,
    get_combined_design,
    # rand_design.jl functions
    get_randomisations,
    generate_rand_design,
    get_design,
    get_meas_budget,
    get_stim_qiskit_ensemble,
    # merit.jl functions
    calc_covariance,
    calc_covariance_log,
    sparse_covariance_inv,
    get_transform,
    get_marginal_gate_covariance,
    get_relative_gate_covariance,
    get_pad_transform,
    get_wht_transform,
    calc_gls_covariance,
    calc_wls_covariance,
    calc_ols_covariance,
    calc_ls_covariance,
    calc_gate_probabilities_covariance,
    calc_precision_matrix,
    calc_gls_moments,
    calc_wls_moments,
    calc_ols_moments,
    calc_ls_moments,
    calc_merit,
    nrmse_pdf,
    # optimise_weights.jl functions
    gls_optimise_weights,
    wls_optimise_weights,
    ols_optimise_weights,
    optimise_weights,
    # optimise_tuples.jl functions
    optimise_repetitions,
    optimise_tuple_set,
    optimise_design,
    # estimate.jl functions
    estimate_gate_noise,
    get_noise_error,
    get_noise_score,
    is_score_expected,
    get_rss,
    get_model_violation,
    get_aic,
    get_bic,
    # simulate.jl functions
    simulate_stim_estimate,
    simulate_aces,
    # device.jl functions
    simulate_stim_ensemble,
    simulate_qiskit_ensemble,
    process_qiskit_ensemble,
    estimate_stim_ensemble,
    estimate_qiskit_ensemble,
    # scaling.jl functions
    calc_merit_scaling,
    calc_ensemble_scaling,
    get_scaling_fit,
    get_ensemble_fit,
    # utils.jl functions
    get_paulis,
    get_support,
    get_pauli_string,
    get_mapping_string,
    get_random_pauli,
    pauli_to_string,
    string_to_pauli,
    calc_pauli,
    display_circuit,
    parse_uint8_vector,
    parse_bitstring,
    parse_qiskit_dict,
    pretty_print,
    eig_to_pair_idx,
    pair_to_eig_idx,
    # io.jl functions
    enter_folder,
    exit_folder,
    design_filename,
    scaling_filename,
    aces_data_filename,
    rand_design_filename,
    save_design,
    load_design,
    delete_design,
    save_scaling,
    load_scaling,
    delete_scaling,
    save_aces,
    load_aces,
    delete_aces,
    save_rand_design,
    load_rand_design,
    delete_rand_design,
    save_qiskit_ensemble,
    load_qiskit_ensemble,
    delete_qiskit_ensemble,
    save_rand_design_job,
    load_rand_design_job,
    delete_rand_design_job

# Include files
include("kwargs.jl")
include("tableau.jl")
include("noise.jl")
include("noises/depolarising.jl")
include("noises/lognormal.jl")
include("circuit.jl")
include("circuits/rotated_planar.jl")
include("circuits/unrotated_planar.jl")
include("circuits/heavy_hex.jl")
include("stim.jl")
include("tuples.jl")
include("design.jl")
include("rand_design.jl")
include("merit.jl")
include("optimise_weights.jl")
include("optimise_tuples.jl")
include("estimate.jl")
include("simulate.jl")
include("device.jl")
include("scaling.jl")
include("utils.jl")
include("io.jl")

# IntelliSense for Julia VSCode does not work properly, but this hacky trick fixes that
# It convinces the LSP that the following files are part of src
# But it also convinces the LSP that constants in the following files are defined twice...
# The LSP also doesn't like `if false`
# Source: https://discourse.julialang.org/t/lsp-missing-reference-woes/98231/16
@static if false
    include("../test/runtests.jl")
    include("../test/aqua_tests.jl")
    include("../test/noise_tests.jl")
    include("../test/stim_tests.jl")
    include("../test/merit_tests.jl")
    include("../test/design_tests.jl")
    include("../test/creation_tests.jl")
    include("../test/device_tests.jl")
end

end
